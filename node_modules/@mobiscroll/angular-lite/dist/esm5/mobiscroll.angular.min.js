/* eslint-disable */
import { Injectable, Directive, ElementRef, NgZone, Input as Input$1, Output, ViewContainerRef, EventEmitter, NgModule, ViewChild, Optional, Component, ChangeDetectionStrategy, ChangeDetectorRef, ViewChildren } from '@angular/core';
import { CommonModule } from '@angular/common';
import { NgControl, FormsModule } from '@angular/forms';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var mobiscroll = mobiscroll || {},
    util = {};

var os,
    vers,
    majorVersion,
    minorVersion,
    version = [],
    isBrowser = typeof window !== 'undefined',
    isDark = isBrowser && window.matchMedia && window.matchMedia('(prefers-color-scheme:dark)').matches,
    userAgent = isBrowser ? navigator.userAgent : '',
    platform = isBrowser ? navigator.platform : '',
    maxTouchPoints = isBrowser ? navigator.maxTouchPoints : 0,
    isSafari = /Safari/.test(userAgent),
    device = userAgent.match(/Android|iPhone|iPad|iPod|Windows Phone|Windows|MSIE/i),
    raf = isBrowser && window.requestAnimationFrame || function (func) {
  return setTimeout(func, 20);
};

if (/Android/i.test(device)) {
  os = 'android';
  vers = userAgent.match(/Android\s+([\d.]+)/i);

  if (vers) {
    version = vers[0].replace('Android ', '').split('.');
  }
} else if (/iPhone|iPad|iPod/i.test(device) || /iPhone|iPad|iPod/i.test(platform) || platform === 'MacIntel' && maxTouchPoints > 1) {
  // On iPad with iOS 13 desktop site request is automatically enabled in Safari,
  // so 'iPad' is no longer present in the user agent string.
  // In this case we check `navigator.platform` and `navigator.maxTouchPoints`.
  // maxTouchPoints is needed to exclude desktop Mac OS X.
  os = 'ios';
  vers = userAgent.match(/OS\s+([\d_]+)/i);

  if (vers) {
    version = vers[0].replace(/_/g, '.').replace('OS ', '').split('.');
  }
} else if (/Windows Phone/i.test(device)) {
  os = 'wp';
} else if (/Windows|MSIE/i.test(device)) {
  os = 'windows';
}

majorVersion = version[0];
minorVersion = version[1];

function testProps(props) {
  var i;

  for (i in props) {
    if (mod[props[i]] !== undefined) {
      return true;
    }
  }

  return false;
}

function testPrefix() {
  var prefixes = ['Webkit', 'Moz', 'O', 'ms'],
      p;

  for (p in prefixes) {
    if (testProps([prefixes[p] + 'Transform'])) {
      return '-' + prefixes[p].toLowerCase() + '-';
    }
  }

  return '';
}

function testTouch(e, elm) {
  if (e.type == 'touchstart') {
    elm.__mbscTouched = 1;
  } else if (elm.__mbscTouched) {
    delete elm.__mbscTouched;
    return false;
  }

  return true;
}

function listen(el, event, handler, opt) {
  if (el) {
    el.addEventListener(event, handler, opt);
  }
}

function unlisten(el, event, handler, opt) {
  if (el) {
    el.removeEventListener(event, handler, opt);
  }
}

function matches(element, selector) {
  if (!selector || !element || element.nodeType !== 1) {
    return false;
  }

  var matchesSelector = element.matches || element.matchesSelector || element.webkitMatchesSelector || element.mozMatchesSelector || element.msMatchesSelector;
  return matchesSelector.call(element, selector);
}

function closest(el, target, selector) {
  while (target) {
    if (matches(target, selector)) {
      return target;
    }

    target = target !== el ? target.parentNode : null;
  }

  return null;
}

function trigger(elm, name, data) {
  var evt;

  try {
    evt = new CustomEvent(name, {
      detail: data,
      bubbles: true,
      cancelable: true
    });
  } catch (e) {
    evt = document.createEvent('Event');
    evt.initEvent(name, true, true);
    evt.detail = data;
  }

  elm.dispatchEvent(evt);
}

var animEnd,
    canvas,
    mod,
    cssPrefix,
    hasGhostClick,
    hasTransition,
    isWebView,
    isWkWebView,
    jsPrefix,
    win;

if (isBrowser) {
  win = window;
  canvas = document.createElement('canvas');
  mod = document.createElement('modernizr').style;
  cssPrefix = testPrefix();
  jsPrefix = cssPrefix.replace(/^-/, '').replace(/-$/, '').replace('moz', 'Moz');
  animEnd = mod.animation !== undefined ? 'animationend' : 'webkitAnimationEnd';
  hasTransition = mod.transition !== undefined; // UIWebView on iOS still has the ghost click, 
  // WkWebView does not have a ghost click, but it's hard to tell if it's UIWebView or WkWebView
  // In addition in iOS 12.2 if we enable tap handling, it brakes the form inputs
  // (keyboard appears, but the cursor is not in the input).

  isWebView = os === 'ios' && !isSafari;
  isWkWebView = isWebView && win.webkit && win.webkit.messageHandlers;
  hasGhostClick = mod.touchAction === undefined || isWebView && !isWkWebView;
}

var cssNumber = {
  'column-count': 1,
  'columns': 1,
  'font-weight': 1,
  'line-height': 1,
  'opacity': 1,
  'z-index': 1,
  'zoom': 1
},
    propMap = {
  'readonly': 'readOnly'
},
    emptyArray = [],
    _slice = Array.prototype.slice;

function isFunction(value) {
  return typeof value === "function";
}

function isObject(obj) {
  return typeof obj === "object";
}

function likeArray(obj) {
  return typeof obj.length == 'number';
}

function camelize(str) {
  return str.replace(/-+(.)?/g, function (match, chr) {
    return chr ? chr.toUpperCase() : '';
  });
}

function extend(target, source, deep) {
  for (var key in source) {
    if (deep && ($.isPlainObject(source[key]) || $.isArray(source[key]))) {
      if ($.isPlainObject(source[key]) && !$.isPlainObject(target[key]) || $.isArray(source[key]) && !$.isArray(target[key])) {
        target[key] = {};
      }

      extend(target[key], source[key], deep);
    } else if (source[key] !== undefined) {
      target[key] = source[key];
    }
  }
}

function dasherize(str) {
  return str.replace(/::/g, '/').replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2').replace(/([a-z\d])([A-Z])/g, '$1_$2').replace(/_/g, '-').toLowerCase();
}

function maybeAddPx(name, value) {
  return typeof value == "number" && !cssNumber[dasherize(name)] ? value + "px" : value;
}

var Dom = function () {
  var Dom = function Dom(arr) {
    var _this = this,
        i = 0; // Create array-like object


    for (i = 0; i < arr.length; i++) {
      _this[i] = arr[i];
    }

    _this.length = arr.length; // Return collection with methods

    return $(this);
  };

  var $ = function $(selector, context) {
    var arr = [],
        i = 0;

    if (selector && !context) {
      if (selector instanceof Dom) {
        return selector;
      }
    }

    if (isFunction(selector)) {
      return $(document).ready(selector);
    }

    if (selector) {
      // String
      if (typeof selector === 'string') {
        var els, tempParent, html;
        selector = html = selector.trim();

        if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
          var toCreate = 'div';

          if (html.indexOf('<li') === 0) {
            toCreate = 'ul';
          }

          if (html.indexOf('<tr') === 0) {
            toCreate = 'tbody';
          }

          if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) {
            toCreate = 'tr';
          }

          if (html.indexOf('<tbody') === 0) {
            toCreate = 'table';
          }

          if (html.indexOf('<option') === 0) {
            toCreate = 'select';
          }

          tempParent = document.createElement(toCreate);
          tempParent.innerHTML = html;

          for (i = 0; i < tempParent.childNodes.length; i++) {
            arr.push(tempParent.childNodes[i]);
          }
        } else {
          if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
            // Pure ID selector
            els = [document.getElementById(selector.split('#')[1])];
          } else {
            if (context instanceof Dom) {
              context = context[0];
            } // Other selectors


            els = (context || document).querySelectorAll(selector);
          }

          for (i = 0; i < els.length; i++) {
            if (els[i]) {
              arr.push(els[i]);
            }
          }
        }
      } // Node/element
      else if (selector.nodeType || selector === window || selector === document) {
          arr.push(selector);
        } //Array of elements or instance of Dom
        else if (selector.length > 0 && selector[0].nodeType) {
            for (i = 0; i < selector.length; i++) {
              arr.push(selector[i]);
            }
          } else if ($.isArray(selector)) {
            arr = selector;
          }
    }

    return new Dom(arr);
  };

  Dom.prototype = {
    ready: function ready(callback) {
      if (document.attachEvent ? document.readyState == 'complete' : document.readyState != 'loading') {
        callback($);
      } else {
        document.addEventListener('DOMContentLoaded', function () {
          callback($);
        }, false);
      }

      return this;
    },
    concat: emptyArray.concat,
    empty: function empty() {
      return this.each(function () {
        this.innerHTML = '';
      });
    },
    map: function map(fn) {
      return $($.map(this, function (el, i) {
        return fn.call(el, i, el);
      }));
    },
    slice: function slice() {
      return $(_slice.apply(this, arguments));
    },
    // Classes and attriutes
    // NOTE: element.classList attribure is not supported on android 2.3!!!
    addClass: function addClass(className) {
      if (typeof className === 'undefined') {
        return this;
      }

      var classes = className.split(' ');

      for (var i = 0; i < classes.length; i++) {
        for (var j = 0; j < this.length; j++) {
          if (typeof this[j].classList !== 'undefined' && classes[i] !== '') {
            this[j].classList.add(classes[i]);
          }
        }
      }

      return this;
    },
    removeClass: function removeClass(className) {
      if (typeof className === 'undefined') {
        return this;
      }

      var classes = className.split(' ');

      for (var i = 0; i < classes.length; i++) {
        for (var j = 0; j < this.length; j++) {
          if (typeof this[j].classList !== 'undefined' && classes[i] !== '') {
            this[j].classList.remove(classes[i]);
          }
        }
      }

      return this;
    },
    hasClass: function hasClass(className) {
      return this[0] ? this[0].classList.contains(className) : false;
    },
    toggleClass: function toggleClass(className) {
      var classes = className.split(' ');

      for (var i = 0; i < classes.length; i++) {
        for (var j = 0; j < this.length; j++) {
          if (typeof this[j].classList !== 'undefined') {
            this[j].classList.toggle(classes[i]);
          }
        }
      }

      return this;
    },
    closest: function closest(selector, context) {
      var node = this[0],
          collection = false;

      if (isObject(selector)) {
        collection = $(selector);
      }

      while (node && !(collection ? collection.indexOf(node) >= 0 : matches(node, selector))) {
        node = node !== context && node.nodeType !== node.DOCUMENT_NODE && node.parentNode;
      }

      return $(node);
    },
    attr: function attr(attrs, value) {
      var attr;

      if (arguments.length === 1 && typeof attrs === 'string') {
        // Get attr
        if (this.length) {
          attr = this[0].getAttribute(attrs);
          return attr || attr === '' ? attr : undefined;
        }
      } else {
        // Set attrs
        for (var i = 0; i < this.length; i++) {
          if (arguments.length === 2) {
            // String
            this[i].setAttribute(attrs, value);
          } else {
            // Object
            for (var attrName in attrs) {
              this[i][attrName] = attrs[attrName];
              this[i].setAttribute(attrName, attrs[attrName]);
            }
          }
        }

        return this;
      }
    },
    removeAttr: function removeAttr(attr) {
      for (var i = 0; i < this.length; i++) {
        this[i].removeAttribute(attr);
      }

      return this;
    },
    prop: function prop(props, value) {
      props = propMap[props] || props;

      if (arguments.length === 1 && typeof props === 'string') {
        // Get prop
        return this[0] ? this[0][props] : undefined;
      } else {
        // Set props
        for (var i = 0; i < this.length; i++) {
          this[i][props] = value;
        }

        return this;
      }
    },
    val: function val(value) {
      if (typeof value === 'undefined') {
        if (this.length && this[0].multiple) {
          return $.map(this.find('option:checked'), function (v) {
            return v.value;
          });
        }

        return this[0] ? this[0].value : undefined;
      }

      if (this.length && this[0].multiple) {
        $.each(this[0].options, function () {
          this.selected = value.indexOf(this.value) != -1;
        });
      } else {
        for (var i = 0; i < this.length; i++) {
          this[i].value = value;
        }
      }

      return this;
    },
    //Events
    on: function on(eventName, targetSelector, listener, capture) {
      var boundListener,
          elm,
          event,
          events = eventName.split(' '),
          i,
          j;

      function handleLiveEvent(e) {
        var target = e.target;

        while (target) {
          if ($(target).is(targetSelector)) {
            listener.call(target, e);
          }

          target = target !== this ? target.parentNode : null;
        }
      }

      function handleNamespaces(el, name, listener, capture) {
        var namespace = name.split('.');

        if (!el.DomNameSpaces) {
          el.DomNameSpaces = [];
        }

        el.DomNameSpaces.push({
          namespace: namespace[1],
          event: namespace[0],
          listener: listener,
          capture: capture
        });
        el.addEventListener(namespace[0], listener, capture);
      }

      for (i = 0; i < this.length; i++) {
        elm = this[i];

        if (isFunction(targetSelector) || targetSelector === false) {
          // Usual events
          if (isFunction(targetSelector)) {
            capture = listener || false;
            listener = targetSelector;
          }

          for (j = 0; j < events.length; j++) {
            event = events[j]; // check for namespaces

            if (event.indexOf('.') != -1) {
              handleNamespaces(elm, event, listener, capture);
            } else {
              elm.addEventListener(event, listener, capture);
            }
          }
        } else {
          // Live events
          boundListener = handleLiveEvent.bind(elm);

          for (j = 0; j < events.length; j++) {
            event = events[j];

            if (!elm.DomLiveListeners) {
              elm.DomLiveListeners = [];
            }

            elm.DomLiveListeners.push({
              listener: listener,
              liveListener: boundListener
            });

            if (event.indexOf('.') != -1) {
              handleNamespaces(elm, event, boundListener, capture);
            } else {
              elm.addEventListener(event, boundListener, capture);
            }
          }
        }
      }

      return this;
    },
    off: function off(eventName, targetSelector, listener, capture) {
      var elm,
          event,
          events,
          i,
          j,
          k,
          liveListeners,
          that = this;

      function removeEvents(event) {
        var el,
            i,
            j,
            item,
            nameSpaces,
            parts = event.split('.'),
            name = parts[0],
            ns = parts[1];

        for (i = 0; i < that.length; ++i) {
          el = that[i];
          nameSpaces = el.DomNameSpaces;

          if (nameSpaces) {
            for (j = 0; j < nameSpaces.length; ++j) {
              item = nameSpaces[j];

              if (item.namespace == ns && (item.event == name || !name)) {
                el.removeEventListener(item.event, item.listener, item.capture);
                item.removed = true;
              }
            } // remove the events from the DomNameSpaces array


            for (j = nameSpaces.length - 1; j >= 0; --j) {
              if (nameSpaces[j].removed) {
                nameSpaces.splice(j, 1);
              }
            }
          }
        }
      }

      events = eventName.split(' ');

      for (i = 0; i < events.length; i++) {
        event = events[i];

        for (j = 0; j < this.length; j++) {
          elm = this[j];
          liveListeners = elm.DomLiveListeners;

          if (isFunction(targetSelector) || targetSelector === false) {
            // Usual events
            if (isFunction(targetSelector)) {
              capture = listener || false;
              listener = targetSelector;
            }

            if (event.indexOf('.') === 0) {
              // remove namespace events
              removeEvents(event.substr(1));
            } else {
              elm.removeEventListener(event, listener, capture);
            }
          } else {
            // Live event
            if (liveListeners) {
              for (k = 0; k < liveListeners.length; k++) {
                if (liveListeners[k].listener === listener) {
                  elm.removeEventListener(event, liveListeners[k].liveListener, capture);
                }
              }
            }

            if (elm.DomNameSpaces && elm.DomNameSpaces.length && event) {
              removeEvents(event);
            }
          }
        }
      }

      return this;
    },
    trigger: function trigger$1(eventName, eventData) {
      var events = eventName.split(' ');

      for (var i = 0; i < events.length; i++) {
        for (var j = 0; j < this.length; j++) {
          trigger(this[j], events[i], eventData);
        }
      }

      return this;
    },
    // Sizing/Styles
    width: function width(dim) {
      if (dim !== undefined) {
        return this.css('width', dim);
      }

      if (this[0] === window) {
        return window.innerWidth;
      } else if (this[0] === document) {
        return document.documentElement.scrollWidth;
      } else {
        return this.length > 0 ? parseFloat(this.css('width')) : null;
      }
    },
    height: function height(dim) {
      if (dim !== undefined) {
        return this.css('height', dim);
      }

      if (this[0] === window) {
        return window.innerHeight;
      } else if (this[0] === document) {
        var body = document.body,
            html = document.documentElement;
        return Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
      } else {
        return this.length > 0 ? parseFloat(this.css('height')) : null;
      }
    },
    innerWidth: function innerWidth() {
      var elm = this;

      if (this.length > 0) {
        if (this[0].innerWidth) {
          return this[0].innerWidth;
        } else {
          var size = this[0].offsetWidth,
              sides = ['left', 'right'];
          sides.forEach(function (side) {
            size -= parseInt(elm.css(camelize('border-' + side + '-width')) || 0, 10);
          });
          return size;
        }
      }
    },
    innerHeight: function innerHeight() {
      var elm = this;

      if (this.length > 0) {
        if (this[0].innerHeight) {
          return this[0].innerHeight;
        } else {
          var size = this[0].offsetHeight,
              sides = ['top', 'bottom'];
          sides.forEach(function (side) {
            size -= parseInt(elm.css(camelize('border-' + side + '-width')) || 0, 10);
          });
          return size;
        }
      }
    },
    offset: function offset() {
      if (this.length > 0) {
        var el = this[0],
            box = el.getBoundingClientRect(),
            doc = document.documentElement;
        return {
          top: box.top + window.pageYOffset - doc.clientTop,
          left: box.left + window.pageXOffset - doc.clientLeft
        };
      }
    },
    hide: function hide() {
      for (var i = 0; i < this.length; i++) {
        this[i].style.display = 'none';
      }

      return this;
    },
    show: function show() {
      for (var i = 0; i < this.length; i++) {
        if (this[i].style.display == "none") {
          this[i].style.display = '';
        }

        if (getComputedStyle(this[i], '').getPropertyValue("display") == "none") {
          this[i].style.display = 'block';
        }
      }

      return this;
    },
    clone: function clone() {
      return this.map(function () {
        return this.cloneNode(true);
      });
    },
    styles: function styles() {
      return this[0] ? window.getComputedStyle(this[0], null) : undefined;
    },
    css: function css(property, value) {
      var i,
          key,
          element = this[0],
          css = '';

      if (arguments.length < 2) {
        if (!element) {
          return;
        }

        if (typeof property === 'string') {
          return element.style[property] || getComputedStyle(element, '').getPropertyValue(property);
        }
      }

      if (typeof property === 'string') {
        if (!value && value !== 0) {
          this.each(function () {
            this.style.removeProperty(dasherize(property));
          });
        } else {
          css = dasherize(property) + ":" + maybeAddPx(property, value);
        }
      } else {
        for (key in property) {
          if (!property[key] && property[key] !== 0) {
            for (i = 0; i < this.length; i++) {
              this[i].style.removeProperty(dasherize(key));
            }
          } else {
            css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';';
          }
        }
      }

      return this.each(function () {
        this.style.cssText += ';' + css;
      });
    },
    each: function each(callback) {
      for (var i = 0; i < this.length; i++) {
        if (callback.apply(this[i], [i, this[i]]) === false) {
          break;
        }
      }

      return this;
    },
    filter: function filter(callback) {
      var matchedItems = [];

      for (var i = 0; i < this.length; i++) {
        if (isFunction(callback)) {
          if (callback.call(this[i], i, this[i])) {
            matchedItems.push(this[i]);
          }
        } else if (matches(this[i], callback)) {
          matchedItems.push(this[i]);
        }
      }

      return new Dom(matchedItems);
    },
    html: function html(_html) {
      if (typeof _html === 'undefined') {
        return this[0] ? this[0].innerHTML : undefined;
      } else {
        this.empty();

        for (var i = 0; i < this.length; i++) {
          this[i].innerHTML = _html;
        }

        return this;
      }
    },
    text: function text(_text) {
      if (typeof _text === 'undefined') {
        return this[0] ? this[0].textContent.trim() : null;
      } else {
        for (var i = 0; i < this.length; i++) {
          this[i].textContent = _text;
        }

        return this;
      }
    },
    is: function is(selector) {
      return this.length > 0 && matches(this[0], selector);
    },
    not: function not(selector) {
      var nodes = [];

      if (isFunction(selector) && selector.call !== undefined) {
        this.each(function (idx) {
          if (!selector.call(this, idx)) {
            nodes.push(this);
          }
        });
      } else {
        var excludes = typeof selector == 'string' ? this.filter(selector) : likeArray(selector) && isFunction(selector.item) ? _slice.call(selector) : $(selector);

        if (isObject(excludes)) {
          excludes = $.map(excludes, function (el) {
            return el;
          });
        }

        this.each(function (i, el) {
          if (excludes.indexOf(el) < 0) {
            nodes.push(el);
          }
        });
      }

      return $(nodes);
    },
    indexOf: function indexOf(el) {
      for (var i = 0; i < this.length; i++) {
        if (this[i] === el) {
          return i;
        }
      }
    },
    index: function index(element) {
      return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0]);
    },
    get: function get(idx) {
      return idx === undefined ? _slice.call(this) : this[idx >= 0 ? idx : idx + this.length];
    },
    eq: function eq(index) {
      if (typeof index === 'undefined') {
        return this;
      }

      var length = this.length,
          returnIndex;

      if (index > length - 1) {
        return new Dom([]);
      }

      if (index < 0) {
        returnIndex = length + index;
        return returnIndex < 0 ? new Dom([]) : new Dom([this[returnIndex]]);
      }

      return new Dom([this[index]]);
    },
    append: function append(newChild) {
      var i, j;

      for (i = 0; i < this.length; i++) {
        if (typeof newChild === 'string') {
          var tempDiv = document.createElement('div');
          tempDiv.innerHTML = newChild;

          while (tempDiv.firstChild) {
            this[i].appendChild(tempDiv.firstChild);
          }
        } else if (newChild instanceof Dom) {
          for (j = 0; j < newChild.length; j++) {
            this[i].appendChild(newChild[j]);
          }
        } else {
          this[i].appendChild(newChild);
        }
      }

      return this;
    },
    appendTo: function appendTo(parent) {
      $(parent).append(this);
      return this;
    },
    prepend: function prepend(newChild) {
      var i, j;

      for (i = 0; i < this.length; i++) {
        if (typeof newChild === 'string') {
          var tempDiv = document.createElement('div');
          tempDiv.innerHTML = newChild;

          for (j = tempDiv.childNodes.length - 1; j >= 0; j--) {
            this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
          } // this[i].insertAdjacentHTML('afterbegin', newChild);

        } else if (newChild instanceof Dom) {
          for (j = 0; j < newChild.length; j++) {
            this[i].insertBefore(newChild[j], this[i].childNodes[0]);
          }
        } else {
          this[i].insertBefore(newChild, this[i].childNodes[0]);
        }
      }

      return this;
    },
    prependTo: function prependTo(parent) {
      $(parent).prepend(this);
      return this;
    },
    insertBefore: function insertBefore(selector) {
      var before = $(selector);

      for (var i = 0; i < this.length; i++) {
        if (before.length === 1) {
          before[0].parentNode.insertBefore(this[i], before[0]);
        } else if (before.length > 1) {
          for (var j = 0; j < before.length; j++) {
            before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
          }
        }
      }

      return this;
    },
    insertAfter: function insertAfter(selector) {
      var after = $(selector);

      for (var i = 0; i < this.length; i++) {
        if (after.length === 1) {
          after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
        } else if (after.length > 1) {
          for (var j = 0; j < after.length; j++) {
            after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
          }
        }
      }

      return this;
    },
    next: function next(selector) {
      if (this.length > 0) {
        if (selector) {
          if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
            return new Dom([this[0].nextElementSibling]);
          } else {
            return new Dom([]);
          }
        } else {
          if (this[0].nextElementSibling) {
            return new Dom([this[0].nextElementSibling]);
          } else {
            return new Dom([]);
          }
        }
      } else {
        return new Dom([]);
      }
    },
    nextAll: function nextAll(selector) {
      var nextEls = [],
          el = this[0];

      if (!el) {
        return new Dom([]);
      }

      while (el.nextElementSibling) {
        var next = el.nextElementSibling;

        if (selector) {
          if ($(next).is(selector)) {
            nextEls.push(next);
          }
        } else {
          nextEls.push(next);
        }

        el = next;
      }

      return new Dom(nextEls);
    },
    prev: function prev(selector) {
      if (this.length > 0) {
        if (selector) {
          if (this[0].previousElementSibling && $(this[0].previousElementSibling).is(selector)) {
            return new Dom([this[0].previousElementSibling]);
          } else {
            return new Dom([]);
          }
        } else {
          if (this[0].previousElementSibling) {
            return new Dom([this[0].previousElementSibling]);
          } else {
            return new Dom([]);
          }
        }
      } else {
        return new Dom([]);
      }
    },
    prevAll: function prevAll(selector) {
      var prevEls = [];
      var el = this[0];

      if (!el) {
        return new Dom([]);
      }

      while (el.previousElementSibling) {
        var prev = el.previousElementSibling;

        if (selector) {
          if ($(prev).is(selector)) {
            prevEls.push(prev);
          }
        } else {
          prevEls.push(prev);
        }

        el = prev;
      }

      return new Dom(prevEls);
    },
    parent: function parent(selector) {
      var parents = [];

      for (var i = 0; i < this.length; i++) {
        if (this[i].parentNode !== null) {
          if (selector) {
            if ($(this[i].parentNode).is(selector)) {
              parents.push(this[i].parentNode);
            }
          } else {
            parents.push(this[i].parentNode);
          }
        }
      }

      return $($.unique(parents));
    },
    parents: function parents(selector) {
      var parents = [];

      for (var i = 0; i < this.length; i++) {
        var parent = this[i].parentNode;

        while (parent) {
          if (selector) {
            if ($(parent).is(selector)) {
              parents.push(parent);
            }
          } else {
            parents.push(parent);
          }

          parent = parent.parentNode;
        }
      }

      return $($.unique(parents));
    },
    find: function find(selector) {
      var foundElements = [];

      for (var i = 0; i < this.length; i++) {
        var found = this[i].querySelectorAll(selector);

        for (var j = 0; j < found.length; j++) {
          foundElements.push(found[j]);
        }
      }

      return new Dom(foundElements);
    },
    children: function children(selector) {
      var children = [];

      for (var i = 0; i < this.length; i++) {
        var childNodes = this[i].childNodes;

        for (var j = 0; j < childNodes.length; j++) {
          if (!selector) {
            if (childNodes[j].nodeType === 1) {
              children.push(childNodes[j]);
            }
          } else {
            if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) {
              children.push(childNodes[j]);
            }
          }
        }
      }

      return new Dom($.unique(children));
    },
    remove: function remove() {
      for (var i = 0; i < this.length; i++) {
        if (this[i].parentNode) {
          this[i].parentNode.removeChild(this[i]);
        }
      }

      return this;
    },
    add: function add() {
      var dom = this;
      var i, j;

      for (i = 0; i < arguments.length; i++) {
        var toAdd = $(arguments[i]);

        for (j = 0; j < toAdd.length; j++) {
          dom[dom.length] = toAdd[j];
          dom.length++;
        }
      }

      return dom;
    },
    before: function before(elm) {
      $(elm).insertBefore(this);
      return this;
    },
    after: function after(elm) {
      $(elm).insertAfter(this);
      return this;
    },
    scrollTop: function scrollTop(value) {
      if (!this.length) {
        return;
      }

      var hasScrollTop = 'scrollTop' in this[0];

      if (value === undefined) {
        return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset;
      }

      return this.each(hasScrollTop ? function () {
        this.scrollTop = value;
      } : function () {
        this.scrollTo(this.scrollX, value);
      });
    },
    scrollLeft: function scrollLeft(value) {
      if (!this.length) {
        return;
      }

      var hasScrollLeft = 'scrollLeft' in this[0];

      if (value === undefined) {
        return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset;
      }

      return this.each(hasScrollLeft ? function () {
        this.scrollLeft = value;
      } : function () {
        this.scrollTo(value, this.scrollY);
      });
    },
    contents: function contents() {
      return this.map(function (i, v) {
        return _slice.call(v.childNodes);
      });
    },
    nextUntil: function nextUntil(selector) {
      var n = this,
          array = [];

      while (n.length && !n.filter(selector).length) {
        array.push(n[0]);
        n = n.next();
      }

      return $(array);
    },
    prevUntil: function prevUntil(selector) {
      var n = this,
          array = [];

      while (n.length && !$(n).filter(selector).length) {
        array.push(n[0]);
        n = n.prev();
      }

      return $(array);
    },
    detach: function detach() {
      return this.remove();
    }
  }; // Link to prototype

  $.fn = Dom.prototype;
  return $;
}(); // Export to local scope


var $ = Dom; // Export to mobiscroll

mobiscroll.$ = Dom; // DOM Library Utilites

$.inArray = function (elem, array, i) {
  return emptyArray.indexOf.call(array, elem, i);
};

$.extend = function (target) {
  var deep,
      args = _slice.call(arguments, 1);

  if (typeof target == 'boolean') {
    deep = target;
    target = args.shift();
  }

  target = target || {};
  args.forEach(function (arg) {
    extend(target, arg, deep);
  });
  return target;
};

$.isFunction = isFunction;

$.isArray = function (arr) {
  return Object.prototype.toString.apply(arr) === '[object Array]';
};

$.isPlainObject = function (obj) {
  return isObject(obj) && obj !== null && obj !== obj.window && Object.getPrototypeOf(obj) == Object.prototype;
};

$.each = function (obj, callback) {
  var i, prop;

  if (!isObject(obj) || !callback) {
    return;
  }

  if ($.isArray(obj) || obj instanceof Dom) {
    // Array
    for (i = 0; i < obj.length; i++) {
      if (callback.call(obj[i], i, obj[i]) === false) {
        break;
      }
    }
  } else {
    // Object
    for (prop in obj) {
      // eslint-disable-next-line no-prototype-builtins
      if (obj.hasOwnProperty(prop) && prop !== 'length') {
        if (callback.call(obj[prop], prop, obj[prop]) === false) {
          break;
        }
      }
    }
  }

  return this;
};

$.unique = function (arr) {
  var unique = [];

  for (var i = 0; i < arr.length; i++) {
    if (unique.indexOf(arr[i]) === -1) {
      unique.push(arr[i]);
    }
  }

  return unique;
};

$.map = function (elements, callback) {
  var value,
      values = [],
      i,
      key;

  if (likeArray(elements)) {
    for (i = 0; i < elements.length; i++) {
      value = callback(elements[i], i);

      if (value !== null) {
        values.push(value);
      }
    }
  } else {
    for (key in elements) {
      value = callback(elements[key], key);

      if (value !== null) {
        values.push(value);
      }
    }
  }

  return values.length > 0 ? $.fn.concat.apply([], values) : values;
};

function noop() {}

function isString(s) {
  return typeof s === 'string';
}

function constrain(val, min, max) {
  return Math.max(min, Math.min(val, max));
}

function vibrate(time) {
  if ('vibrate' in navigator) {
    navigator.vibrate(time || 50);
  }
}

function getPercent(v, min, max) {
  return (v - min) * 100 / (max - min);
}

function getBoolAttr(attr, def, $elm) {
  var v = $elm.attr(attr);
  return v === undefined || v === '' ? def : v === 'true';
}

var tapped = 0;
var allowQuick;

function preventClick() {
  // Prevent ghost click
  tapped++;
  setTimeout(function () {
    tapped--;
  }, 500);
}

function triggerClick(ev, control) {
  // Prevent duplicate triggers on the same element
  // e.g. a form checkbox inside a listview item
  if (control.mbscClick) {
    return;
  }

  var touch = (ev.originalEvent || ev).changedTouches[0],
      evt = document.createEvent('MouseEvents');
  evt.initMouseEvent('click', true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
  evt.isMbscTap = true; // Prevent ionic to bust our click
  // This works for Ionic 1 - 3, not sure about 4

  evt.isIonicTap = true; // This will allow a click fired together with this click
  // We need this, because clicking on a label will trigger a click
  // on the associated input as well, which should not be busted

  allowQuick = true;
  control.mbscChange = true;
  control.mbscClick = true;
  control.dispatchEvent(evt);
  allowQuick = false; // Prevent ghost click

  preventClick();
  setTimeout(function () {
    delete control.mbscClick;
  });
}

function getCoord(e, c, page) {
  var ev = e.originalEvent || e,
      prop = (page ? 'page' : 'client') + c; // Multi touch support

  if (ev.targetTouches && ev.targetTouches[0]) {
    return ev.targetTouches[0][prop];
  }

  if (ev.changedTouches && ev.changedTouches[0]) {
    return ev.changedTouches[0][prop];
  }

  return e[prop];
}

function getControlType($elm) {
  var attrs = ['switch', 'range', 'rating', 'segmented', 'stepper'];
  var elm = $elm[0];
  var role = $elm.attr('data-role');
  var type = $elm.attr('type') || elm.nodeName.toLowerCase();

  if (/(switch|range|rating|segmented|stepper|select)/.test(role)) {
    type = role;
  } else {
    for (var i = 0; i < attrs.length; i++) {
      if ($elm.is('[mbsc-' + attrs[i] + ']')) {
        type = attrs[i];
      }
    }
  }

  return type;
}

function activateControl(control, type, ev) {
  control.focus();

  if (/(button|submit|checkbox|switch|radio)/.test(type)) {
    ev.preventDefault();
  }

  if (!/select/.test(type)) {
    triggerClick(ev, control);
  }
}

function tap(that, el, handler, prevent, tolerance, time) {
  var startX,
      startY,
      target,
      moved,
      startTime,
      $ = mobiscroll.$,
      $elm = $(el);
  tolerance = tolerance || 9;

  function onStart(ev) {
    if (!target) {
      // Can't always call preventDefault here, it kills page scroll
      // if (prevent) {
      //     ev.preventDefault();
      // }
      target = this;
      startX = getCoord(ev, 'X');
      startY = getCoord(ev, 'Y');
      moved = false;
      startTime = new Date();
    }
  }

  function onMove(ev) {
    // If movement is more than 20px, don't fire the click event handler
    if (target && !moved && (Math.abs(getCoord(ev, 'X') - startX) > tolerance || Math.abs(getCoord(ev, 'Y') - startY) > tolerance)) {
      moved = true;
    }
  }

  function onEnd(ev) {
    if (target) {
      if (time && new Date() - startTime < 100 || !moved) {
        // ev.preventDefault();
        // handler.call(target, ev, that);
        triggerClick(ev, ev.target);
      } else {
        preventClick();
      }

      target = false;
    }
  }

  function onClick(ev) {
    if (prevent) {
      ev.preventDefault();
    } // If handler was not called on touchend, call it on click;


    handler.call(this, ev, that);
  }

  function onCancel() {
    target = false;
  }

  $elm.each(function (i, elm) {
    if (that.settings.tap) {
      listen(elm, 'touchstart', onStart, {
        passive: true
      });
      listen(elm, 'touchcancel', onCancel);
      listen(elm, 'touchmove', onMove, {
        passive: true
      });
      listen(elm, 'touchend', onEnd);
    }

    listen(elm, 'click', onClick);

    elm.__mbscOff = function () {
      unlisten(elm, 'touchstart', onStart, {
        passive: true
      });
      unlisten(elm, 'touchcancel', onCancel);
      unlisten(elm, 'touchmove', onMove, {
        passive: true
      });
      unlisten(elm, 'touchend', onEnd);
      unlisten(elm, 'click', onClick);
      delete elm.__mbscOff;
    };
  });
}

function tapOff($elm) {
  if ($elm && $elm[0] && $elm[0].__mbscOff) {
    $elm[0].__mbscOff();
  }
} // Prevent standard behaviour on body click


function bustClick(ev) {
  // Textarea needs the mousedown event
  if (tapped && !allowQuick && !ev.isMbscTap && !(ev.target.nodeName == 'TEXTAREA' && ev.type == 'mousedown')) {
    ev.stopPropagation();
    ev.preventDefault();
    return false;
  }
}

if (isBrowser) {
  ['mouseover', 'mousedown', 'mouseup', 'click'].forEach(function (ev) {
    document.addEventListener(ev, bustClick, true);
  });

  if (os == 'android' && majorVersion < 5) {
    document.addEventListener('change', function (ev) {
      if (tapped && ev.target.type == 'checkbox' && !ev.target.mbscChange) {
        ev.stopPropagation();
        ev.preventDefault();
      }

      delete ev.target.mbscChange;
    }, true);
  }
}

/*!
 * Mobiscroll v4.10.9
 * http://mobiscroll.com
 *
 *
 * Copyright 2010-2018, Acid Media
 *
 */

function getWidth(el) {
  return el[0].innerWidth || el.innerWidth();
}

function getThemeName(s) {
  var themeName = s.theme,
      themeVariant = s.themeVariant;

  if (themeName == 'auto' || !themeName) {
    themeName = ms.autoTheme;
  }

  if (themeName == 'default') {
    themeName = 'mobiscroll';
  }

  if ((themeVariant === 'dark' || isDark && themeVariant === 'auto') && ms.themes.form[themeName + '-dark']) {
    themeName = themeName + '-dark';
  } else if (themeVariant === 'light' && /.+-dark$/.test(themeName)) {
    themeName = themeName.replace(/-dark$/, '');
  }

  return themeName;
}

function autoInit(selector, Component, hasRefresh) {
  if (isBrowser) {
    $$1(function () {
      $$1(selector).each(function () {
        new Component(this, {});
      });
      $$1(document).on('mbsc-enhance', function (ev, settings) {
        if ($$1(ev.target).is(selector)) {
          new Component(ev.target, settings || {});
        } else {
          $$1(selector, ev.target).each(function () {
            new Component(this, settings || {});
          });
        }
      });

      if (hasRefresh) {
        $$1(document).on('mbsc-refresh', function (ev) {
          var inst;

          if ($$1(ev.target).is(selector)) {
            inst = instances[ev.target.id];

            if (inst) {
              inst.refresh();
            }
          } else {
            $$1(selector, ev.target).each(function () {
              inst = instances[this.id];

              if (inst) {
                inst.refresh();
              }
            });
          }
        });
      }
    });
  }
}

var ms,
    $$1 = mobiscroll.$,
    id = +new Date(),
    instances = {},
    classes = {},
    empty = {},
    breakpoints = {
  xsmall: 0,
  small: 576,
  medium: 768,
  large: 992,
  xlarge: 1200
},
    extend$1 = $$1.extend;
extend$1(util, {
  getCoord: getCoord,
  preventClick: preventClick,
  vibrate: vibrate
});
ms = extend$1(mobiscroll, {
  $: $$1,
  version: '4.10.9',
  autoTheme: 'mobiscroll',
  themes: {
    form: {},
    page: {},
    frame: {},
    scroller: {},
    listview: {},
    navigation: {},
    progress: {},
    card: {}
  },
  platform: {
    name: os,
    majorVersion: majorVersion,
    minorVersion: minorVersion
  },
  i18n: {},
  instances: instances,
  classes: classes,
  util: util,
  settings: {},
  setDefaults: function setDefaults(o) {
    extend$1(this.settings, o);
  },
  customTheme: function customTheme(name, baseTheme) {
    var i,
        themes = mobiscroll.themes,
        comps = ['frame', 'scroller', 'listview', 'navigation', 'form', 'page', 'progress', 'card'];

    for (i = 0; i < comps.length; i++) {
      themes[comps[i]][name] = extend$1({}, themes[comps[i]][baseTheme], {
        baseTheme: baseTheme
      });
    }
  }
});

var Base = function Base(el, settings) {
  var ctx,
      lang,
      preset,
      resp,
      s,
      theme,
      themeName,
      trigger,
      defaults,
      that = this;
  that.settings = {};
  that.element = el;
  that._init = noop;
  that._destroy = noop;
  that._processSettings = noop;

  that._checkResp = function (width) {
    if (that && that._responsive) {
      var newResp = getResponsiveSettings(width);

      if (resp !== newResp) {
        resp = newResp;
        that.init({});
        return true;
      }
    }
  };

  that._getRespCont = function () {
    return $$1(s.context == 'body' ? window : s.context);
  };

  that.init = function (newSettings, newValue) {
    var key, value; // In case of settings update save the old value

    if (newSettings && that.getVal) {
      value = that.getVal();
    } // Reset settings object


    for (key in that.settings) {
      delete that.settings[key];
    }

    s = that.settings; // Update original user settings

    extend$1(settings, newSettings); // Load user defaults

    if (that._hasDef) {
      defaults = ms.settings;
    } // Create settings object


    extend$1(s, that._defaults, defaults, settings);
    ctx = that._getRespCont();

    if (that._responsive) {
      if (!resp) {
        resp = getResponsiveSettings();
      }

      extend$1(s, resp);
    } // Get theme defaults


    if (that._hasTheme) {
      themeName = getThemeName(s);
      settings.theme = themeName;
      theme = ms.themes[that._class] ? ms.themes[that._class][themeName] : {};
    } // Get language defaults


    if (that._hasLang) {
      lang = ms.i18n[s.lang];
    } // Update settings object


    extend$1(s, theme, lang, defaults, settings, resp);

    that._processSettings(resp || {}); // Load preset settings


    if (that._presets) {
      preset = that._presets[s.preset];

      if (preset) {
        preset = preset.call(el, that, settings, resp);
        extend$1(s, preset, settings, resp);
      }
    }

    that._init(newSettings); // In case of settings update reset the value.
    // This is needed to adapt the value for the updated settings
    // E.g. min/max, date format, etc.


    if (newSettings && that.setVal) {
      that.setVal(newValue === undefined ? value : newValue, true);
    }

    trigger('onInit');
  };

  that.destroy = function () {
    if (that) {
      that._destroy();

      trigger('onDestroy'); // Delete scroller instance

      delete instances[el.id];
      that = null;
    }
  };
  /**
   * Attach tap event to the given element.
   */


  that.tap = function (el, handler, prevent, tolerance, time) {
    tap(that, el, handler, prevent, tolerance, time);
  };
  /**
   * Triggers an event
   */


  that.trigger = function (name, ev) {
    var ret,
        i,
        v,
        s = [defaults, theme, preset, settings];

    for (i = 0; i < 4; i++) {
      v = s[i];

      if (v && v[name]) {
        ret = v[name].call(el, ev || {}, that);
      }
    }

    return ret;
  };
  /**
   * Sets one ore more options.
   */


  that.option = function (opt, value, newValue) {
    var obj = {},
        // preserve settings that are possible to change runtime
    dynamic = ['data', 'invalid', 'valid', 'readonly'];

    if (/calendar|eventcalendar|range/.test(s.preset)) {
      dynamic.push('marked', 'labels', 'colors');
    }

    if (typeof opt === 'object') {
      obj = opt;
    } else {
      obj[opt] = value;
    }

    dynamic.forEach(function (v) {
      settings[v] = s[v];
    });
    that.init(obj, newValue);
  };
  /**
   * Returns the mobiscroll instance.
   */


  that.getInst = function () {
    return that;
  };

  settings = settings || {};
  trigger = that.trigger;

  function getResponsiveSettings(w) {
    var result = empty,
        width;

    if (s.responsive) {
      width = w || getWidth(ctx);
      $$1.each(s.responsive, function (key, value) {
        if (width >= (value.breakpoint || breakpoints[key])) {
          result = value;
        }
      });
    }

    return result;
  }

  function construct() {
    $$1(el).addClass('mbsc-comp'); // Autogenerate id

    if (!el.id) {
      el.id = 'mobiscroll' + ++id;
    } else if (instances[el.id]) {
      instances[el.id].destroy();
    } // Save instance


    instances[el.id] = that;
    that.__ready = true;
  }

  if (!that.__ready) {
    construct();
  }
};

var Observable = function () {
  function Observable() {
    this.keyCount = 0;
    this.subscribers = new Map();
  }

  Observable.prototype.subscribe = function (handler) {
    var key = this.keyCount++;
    this.subscribers.set(key, handler);
    return key;
  };

  Observable.prototype.unsubscribe = function (handler) {
    if (typeof handler === 'number') {
      this.subscribers.delete(handler);
    } else {
      var foundKey_1 = null;
      this.subscribers.forEach(function (fn, key) {
        if (fn === handler) {
          foundKey_1 = key;
        }
      });
      this.subscribers.delete(foundKey_1);
    }
  };

  Observable.prototype.next = function (value) {
    this.subscribers.forEach(function (handler) {
      handler(value);
    });
  };

  return Observable;
}();

var MbscOptionsService = (function () {
    function MbscOptionsService() {
    }
    Object.defineProperty(MbscOptionsService.prototype, "options", {
        get: function () {
            return this._options;
        },
        set: function (o) {
            this._options = o;
        },
        enumerable: true,
        configurable: true
    });
    MbscOptionsService.decorators = [
        { type: Injectable },
    ];
    MbscOptionsService.ctorParameters = function () { return []; };
    return MbscOptionsService;
}());
var MbscInputService = (function () {
    function MbscInputService() {
        this._controlSet = false;
        this._componentRef = undefined;
    }
    Object.defineProperty(MbscInputService.prototype, "isControlSet", {
        get: function () {
            return this._controlSet;
        },
        set: function (v) {
            this._controlSet = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscInputService.prototype, "input", {
        get: function () {
            return this._componentRef;
        },
        set: function (v) {
            this._componentRef = v;
        },
        enumerable: true,
        configurable: true
    });
    MbscInputService.decorators = [
        { type: Injectable },
    ];
    MbscInputService.ctorParameters = function () { return []; };
    return MbscInputService;
}());
var MbscBase = (function () {
    function MbscBase(initialElem, zone) {
        this.initialElem = initialElem;
        this.zone = zone;
        this.options = {};
        this.onInit = new EventEmitter();
        this.onDestroy = new EventEmitter();
        this.inlineOptionsObj = {};
        this.pendingValue = undefined;
        this.themeClassesSet = false;
        this.instance = null;
        this.element = null;
        this.inlineOptionsObj.zone = zone;
    }
    MbscBase.prototype.getInlineEvents = function () {
        var _this = this;
        var _loop_1 = function (prop) {
            if (this_1[prop] instanceof (EventEmitter) && (!this_1.options || !(this_1.options[prop]))) {
                this_1.inlineOptionsObj[prop] = function (event, inst) {
                    event.inst = inst;
                    _this[prop].emit(event);
                };
            }
        };
        var this_1 = this;
        for (var prop in this) {
            _loop_1(prop);
        }
    };
    MbscBase.prototype.setThemeClasses = function () {
        $$1(this.initialElem.nativeElement).addClass(this.getThemeClasses());
        this.themeClassesSet = true;
    };
    MbscBase.prototype.clearThemeClasses = function () {
        $$1(this.initialElem.nativeElement).removeClass(this.getThemeClasses());
    };
    MbscBase.prototype.getThemeClasses = function () {
        var s = this.instance.settings;
        return 'mbsc-control-ng mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : '');
    };
    MbscBase.prototype.setElement = function () {
        this.element = this.initialElem.nativeElement;
        var contentInput = $$1('input', this.initialElem.nativeElement);
        if (contentInput.length) {
            this.element = contentInput[0];
        }
    };
    MbscBase.prototype.ngAfterViewInit = function () {
        this.setElement();
        this.startInit();
    };
    MbscBase.prototype.startInit = function () {
        var _this = this;
        this.getInlineEvents();
        var ionInput = this.getIonInput();
        if (ionInput && (ionInput.getInputElement || ionInput.then) && this.element.nodeName !== "INPUT") {
            if (ionInput.getInputElement) {
                ionInput.getInputElement().then(function (inp) {
                    _this.setElement();
                    _this.initControl();
                });
            }
            else {
                ionInput.then(function (ionInpComponent) {
                    ionInpComponent
                        .getInputElement()
                        .then(function (inp) {
                        _this.setElement();
                        _this.initControl();
                    });
                });
            }
        }
        else if (!this.instance) {
            this.initControl();
        }
    };
    MbscBase.prototype.getIonInput = function () {
        var v = this._view;
        var native = this.initialElem.nativeElement;
        var ionInputNode = native.nodeName === "ION-INPUT";
        var inp1 = ionInputNode && v && v._data && v._data.componentView && v._data.componentView.component;
        var inp2 = ionInputNode && native.componentOnReady && native.componentOnReady();
        return inp1 || inp2;
    };
    MbscBase.prototype.initControl = function () { };
    MbscBase.prototype.ngOnDestroy = function () {
        if (this.instance) {
            this.instance.destroy();
        }
    };
    MbscBase.prototype.updateOptions = function (newOptions, optionChanged, invalidChanged, dataChanged) {
        var _this = this;
        if (optionChanged || invalidChanged) {
            setTimeout(function () {
                if (newOptions.theme && _this.themeClassesSet) {
                    _this.clearThemeClasses();
                }
                _this.instance.option(newOptions, undefined, _this.pendingValue);
                if (newOptions.theme && _this.themeClassesSet) {
                    _this.setThemeClasses();
                }
            });
        }
        else if (dataChanged) {
            this.refreshData(this.data);
        }
        else if (this.instance.redraw) {
            this.instance.redraw();
        }
    };
    MbscBase.prototype.ngOnChanges = function (changes) {
        var optionChange = false, cloneChange = false, invalidChange = false, dataChange = false, newOptions = {};
        for (var prop in changes) {
            if (!changes[prop].firstChange && prop !== 'options' && prop !== 'value') {
                if (this.cloneDictionary && this.cloneDictionary[prop]) {
                    this.makeClone(prop, changes[prop].currentValue);
                    if (this.instance) {
                        this.instance.settings[prop] = changes[prop].currentValue;
                    }
                    if (prop == 'invalid') {
                        invalidChange = true;
                    }
                    if (prop == 'data') {
                        dataChange = true;
                    }
                    cloneChange = true;
                }
                else {
                    newOptions[prop] = changes[prop].currentValue;
                    optionChange = true;
                }
            }
            else if (!changes[prop].firstChange && prop !== 'value') {
                newOptions = extend$1(changes[prop].currentValue, newOptions);
                optionChange = true;
            }
            else if (changes[prop].firstChange) {
                if (prop !== 'options' && prop !== 'value') {
                    this.inlineOptionsObj[prop] = changes[prop].currentValue;
                }
            }
        }
        if (cloneChange) {
            extend$1(newOptions, this.cloneDictionary);
        }
        if (optionChange || cloneChange) {
            this.updateOptions(newOptions, optionChange, invalidChange, dataChange);
        }
    };
    MbscBase.decorators = [
        { type: Directive, args: [{ selector: '[mbsc-b]' },] },
    ];
    MbscBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
    ]; };
    MbscBase.propDecorators = {
        'options': [{ type: Input$1, args: ['mbsc-options',] },],
        'cssClass': [{ type: Input$1 },],
        'theme': [{ type: Input$1 },],
        'themeVariant': [{ type: Input$1 },],
        'lang': [{ type: Input$1 },],
        'rtl': [{ type: Input$1 },],
        'responsive': [{ type: Input$1 },],
        'onInit': [{ type: Output },],
        'onDestroy': [{ type: Output },],
    };
    return MbscBase;
}());
var MbscValueBase = (function (_super) {
    __extends(MbscValueBase, _super);
    function MbscValueBase(initialElem, zone) {
        var _this = _super.call(this, initialElem, zone) || this;
        _this.initialValue = undefined;
        return _this;
    }
    MbscValueBase.prototype.setNewValue = function (v) { };
    MbscValueBase.prototype.setNewValueProxy = function (v) {
        if (!this.instance) {
            this.initialValue = v;
        }
        this.setNewValue(v);
    };
    MbscValueBase.decorators = [
        { type: Directive, args: [{ selector: '[mbsc-v-b]' },] },
    ];
    MbscValueBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
    ]; };
    return MbscValueBase;
}(MbscBase));
var MbscCloneBase = (function (_super) {
    __extends(MbscCloneBase, _super);
    function MbscCloneBase(initElem, zone) {
        var _this = _super.call(this, initElem, zone) || this;
        _this.cloneDictionary = {};
        return _this;
    }
    MbscCloneBase.prototype.makeClone = function (setting, value) {
        if (value) {
            this.cloneDictionary[setting] = [];
            for (var i = 0; i < value.length; i++) {
                this.cloneDictionary[setting].push(value[i]);
            }
        }
        else {
            this.cloneDictionary[setting] = value;
        }
    };
    MbscCloneBase.prototype.ngDoCheck = function () {
        var changed = false, data = false, invalid = false;
        for (var key in this.cloneDictionary) {
            if (this[key] !== undefined && !deepEqualsArray(this[key], this.cloneDictionary[key])) {
                this.makeClone(key, this[key]);
                this.instance.settings[key] = this[key];
                changed = true;
                if (key == 'invalid') {
                    invalid = true;
                }
                if (key == 'data') {
                    data = true;
                }
            }
        }
        if (changed && this.instance) {
            this.updateOptions(this.cloneDictionary, false, invalid, data);
        }
    };
    MbscCloneBase.prototype.ngOnInit = function () {
        for (var key in this.cloneDictionary) {
            this.makeClone(key, this[key]);
        }
    };
    MbscCloneBase.decorators = [
        { type: Directive, args: [{ selector: '[mbsc-c-b]' },] },
    ];
    MbscCloneBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
    ]; };
    return MbscCloneBase;
}(MbscValueBase));
var MbscControlBase = (function (_super) {
    __extends(MbscControlBase, _super);
    function MbscControlBase(initialElement, zone, control, _inputService, _view) {
        var _this = _super.call(this, initialElement, zone) || this;
        _this.control = control;
        _this._inputService = _inputService;
        _this._view = _view;
        _this._needsTimeout = true;
        _this.onChange = function () { };
        _this.onTouch = function () { };
        _this.onChangeEmitter = new EventEmitter();
        _this.oldAccessor = null;
        _this.overwriteAccessor();
        if (_inputService) {
            _inputService.isControlSet = true;
        }
        return _this;
    }
    Object.defineProperty(MbscControlBase.prototype, "optionExtensions", {
        get: function () {
            var _this = this;
            var externalOnClose = this.options && this.options.onClose;
            var externalOnFill = this.options && this.options.onFill;
            var onCloseEmitter = this.onClose;
            return {
                onFill: function (event, inst) {
                    if (_this.oldAccessor) {
                        _this.oldAccessor.writeValue(event.valueText);
                    }
                    else {
                        var ionInput = _this.getIonInput();
                        if (ionInput) {
                            ionInput.value = event.valueText;
                        }
                    }
                    if (externalOnFill) {
                        externalOnFill(event, inst);
                    }
                },
                onClose: function (event, inst) {
                    _this.onTouch();
                    if (externalOnClose) {
                        externalOnClose(event, inst);
                    }
                    if (onCloseEmitter) {
                        event.inst = inst;
                        onCloseEmitter.emit(event);
                    }
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscControlBase.prototype, "enableManualEdit", {
        get: function () {
            var nsf = this.showOnFocus === false || this.options.showOnFocus === false, nst = this.showOnTap === false || this.options.showOnTap === false;
            return nsf && nst;
        },
        enumerable: true,
        configurable: true
    });
    MbscControlBase.prototype.handleChange = function (element) {
        var that = this;
        $$1(element || this.element).on('change', function () {
            that.zone.run(function () {
                var elmValue = that.element.value;
                var instValue = that.instance._value;
                if (elmValue !== instValue && (instValue !== null || elmValue !== '') && that.enableManualEdit) {
                    that.instance.setVal(elmValue, true, true);
                }
                else {
                    var value = that.instance.getVal();
                    if (that.control) {
                        if (!valueEquals(value, that.control.model)) {
                            that.onChange(value);
                            that.control.control.patchValue(value);
                        }
                    }
                    else {
                        that.onChangeEmitter.emit(value);
                    }
                }
            });
        });
        function valueEquals(v1, v2) {
            if (v1 === v2) {
                return true;
            }
            if (v1 instanceof Date && v2 instanceof Date) {
                return (+v1) === (+v2);
            }
            return false;
        }
    };
    MbscControlBase.prototype.overwriteAccessor = function () {
        if (this.control) {
            if (this.control.valueAccessor !== this) {
                this.oldAccessor = this.control.valueAccessor;
            }
            this.control.valueAccessor = this;
        }
    };
    MbscControlBase.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.handleChange();
        this.overwriteAccessor();
        if (this.control && this.control._setUpControl) {
            this.control._setUpControl();
        }
    };
    MbscControlBase.prototype.registerOnChange = function (fn) {
        this.onChange = fn;
    };
    MbscControlBase.prototype.registerOnTouched = function (fn) {
        this.onTouch = fn;
    };
    MbscControlBase.prototype.setDisabledState = function (isDisabled) {
        this.disabled = isDisabled;
        if (this.oldAccessor && this.oldAccessor.setDisabledState) {
            this.oldAccessor.setDisabledState(isDisabled);
        }
        if (this.instance && this.instance.disable && this.instance.enable) {
            if (isDisabled) {
                this.instance.disable();
            }
            else {
                this.instance.enable();
            }
        }
    };
    MbscControlBase.prototype.writeValue = function (v) {
        var _this = this;
        if (this._needsTimeout) {
            this.pendingValue = v;
            setTimeout(function () {
                _this.pendingValue = undefined;
                _this.setNewValueProxy(v);
            });
        }
        else {
            this.setNewValueProxy(v);
        }
    };
    MbscControlBase.decorators = [
        { type: Directive, args: [{ selector: '[mbsc-cc-b]' },] },
    ];
    MbscControlBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, },
        { type: MbscInputService, },
        { type: ViewContainerRef, },
    ]; };
    MbscControlBase.propDecorators = {
        'labelStyle': [{ type: Input$1, args: ['label-style',] },],
        'inputStyle': [{ type: Input$1, args: ['input-style',] },],
        'showOnFocus': [{ type: Input$1 },],
        'showOnTap': [{ type: Input$1 },],
        'disabled': [{ type: Input$1 },],
    };
    return MbscControlBase;
}(MbscCloneBase));
var MbscFrameBase = (function (_super) {
    __extends(MbscFrameBase, _super);
    function MbscFrameBase(initialElem, zone, control, _inputService, view) {
        var _this = _super.call(this, initialElem, zone, control, _inputService, view) || this;
        _this.onBeforeClose = new EventEmitter();
        _this.onBeforeShow = new EventEmitter();
        _this.onCancel = new EventEmitter();
        _this.onClose = new EventEmitter();
        _this.onFill = new EventEmitter();
        _this.onMarkupReady = new EventEmitter();
        _this.onPosition = new EventEmitter();
        _this.onShow = new EventEmitter();
        return _this;
    }
    Object.defineProperty(MbscFrameBase.prototype, "inline", {
        get: function () {
            return (this.display || (this.options && this.options.display)) === 'inline';
        },
        enumerable: true,
        configurable: true
    });
    MbscFrameBase.prototype.ngOnInit = function () {
        this.cloneDictionary.invalid = [];
        this.cloneDictionary.valid = [];
        _super.prototype.ngOnInit.call(this);
    };
    MbscFrameBase.decorators = [
        { type: Directive, args: [{ selector: '[mbsc-fr-b]' },] },
    ];
    MbscFrameBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, },
        { type: MbscInputService, },
        { type: ViewContainerRef, },
    ]; };
    MbscFrameBase.propDecorators = {
        'options': [{ type: Input$1 },],
        'dropdown': [{ type: Input$1 },],
        'anchor': [{ type: Input$1 },],
        'animate': [{ type: Input$1 },],
        'buttons': [{ type: Input$1 },],
        'closeOnOverlayTap': [{ type: Input$1 },],
        'context': [{ type: Input$1 },],
        'display': [{ type: Input$1 },],
        'showInput': [{ type: Input$1 },],
        'focusOnClose': [{ type: Input$1 },],
        'focusTrap': [{ type: Input$1 },],
        'headerText': [{ type: Input$1 },],
        'scrollLock': [{ type: Input$1 },],
        'touchUi': [{ type: Input$1 },],
        'onBeforeClose': [{ type: Output },],
        'onBeforeShow': [{ type: Output },],
        'onCancel': [{ type: Output },],
        'onClose': [{ type: Output },],
        'onFill': [{ type: Output },],
        'onMarkupReady': [{ type: Output },],
        'onPosition': [{ type: Output },],
        'onShow': [{ type: Output },],
    };
    return MbscFrameBase;
}(MbscControlBase));
var MbscScrollerBase = (function (_super) {
    __extends(MbscScrollerBase, _super);
    function MbscScrollerBase(initialElement, zone, control, _inputService, view) {
        var _this = _super.call(this, initialElement, zone, control, _inputService, view) || this;
        _this.onWheelChange = new EventEmitter();
        _this.onSet = new EventEmitter();
        _this.onItemTap = new EventEmitter();
        _this.onClear = new EventEmitter();
        return _this;
    }
    MbscScrollerBase.decorators = [
        { type: Directive, args: [{ selector: '[mbsc-s-b]' },] },
    ];
    MbscScrollerBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, },
        { type: MbscInputService, },
        { type: ViewContainerRef, },
    ]; };
    MbscScrollerBase.propDecorators = {
        'circular': [{ type: Input$1 },],
        'height': [{ type: Input$1 },],
        'layout': [{ type: Input$1 },],
        'maxWidth': [{ type: Input$1 },],
        'minWidth': [{ type: Input$1 },],
        'multiline': [{ type: Input$1 },],
        'readonly': [{ type: Input$1 },],
        'rows': [{ type: Input$1 },],
        'showLabel': [{ type: Input$1 },],
        'showScrollArrows': [{ type: Input$1 },],
        'wheels': [{ type: Input$1 },],
        'width': [{ type: Input$1 },],
        'validate': [{ type: Input$1 },],
        'cancelText': [{ type: Input$1 },],
        'clearText': [{ type: Input$1 },],
        'selectedText': [{ type: Input$1 },],
        'setText': [{ type: Input$1 },],
        'formatValue': [{ type: Input$1 },],
        'parseValue': [{ type: Input$1 },],
        'onWheelChange': [{ type: Output, args: ['onChange',] },],
        'onSet': [{ type: Output },],
        'onItemTap': [{ type: Output },],
        'onClear': [{ type: Output },],
    };
    return MbscScrollerBase;
}(MbscFrameBase));
var MbscBaseModule = (function () {
    function MbscBaseModule() {
    }
    MbscBaseModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule],
                    declarations: [MbscBase, MbscValueBase, MbscCloneBase, MbscControlBase],
                },] },
    ];
    MbscBaseModule.ctorParameters = function () { return []; };
    return MbscBaseModule;
}());
function deepEqualsArray(a1, a2) {
    if (a1 === a2) {
        return true;
    }
    else if (!a1 || !a2 || a1.length !== a2.length) {
        return false;
    }
    else {
        for (var i = 0; i < a1.length; i++) {
            if (a1[i] !== a2[i]) {
                return false;
            }
        }
        return true;
    }
}
function emptyOrTrue(val) {
    return (typeof (val) === 'string' && (val === 'true' || val === '')) || !!val;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var wrapClass = 'mbsc-input-wrap';
var events = ['touchend', 'touchcancel', 'mousedown', 'mousemove', 'mouseup', 'mouseleave'];
var defaults = {
  tap: hasGhostClick
};
var $active;

function addIcon($control, ic) {
  var icons = {},
      control = $control[0],
      $parent = $control.parent(),
      errorMsg = $parent.find('.mbsc-err-msg'),
      align = $control.attr('data-icon-align') || 'left',
      icon = $control.attr('data-icon');

  if ($parent.hasClass(wrapClass)) {
    $parent = $parent.parent();
  } else {
    // Wrap input
    $$1('<span class="' + wrapClass + '"></span>').insertAfter($control).append($control);
  }

  if (errorMsg) {
    $parent.find('.' + wrapClass).append(errorMsg);
  }

  if (icon) {
    if (icon.indexOf('{') !== -1) {
      icons = JSON.parse(icon);
    } else {
      icons[align] = icon;
    }
  }

  if (control.type == 'file') {
    // Set icon
    icons.right = $control.attr('data-icon-upload') || 'upload';
  }

  if (icon || ic) {
    extend$1(icons, ic);
    $parent.addClass((icons.right ? 'mbsc-ic-right ' : '') + (icons.left ? ' mbsc-ic-left' : '')).find('.' + wrapClass).append('<span class="mbsc-input-fill"></span>').append(icons.left ? '<span class="mbsc-input-ic mbsc-left-ic mbsc-ic mbsc-ic-' + icons.left + '"></span>' : '').append(icons.right ? '<span class="mbsc-input-ic mbsc-right-ic mbsc-ic mbsc-ic-' + icons.right + '"></span>' : '');
  }
}

function addIconToggle(that, $parent, $control) {
  var icons = {},
      control = $control[0],
      toggle = $control.attr('data-password-toggle'),
      iconShow = $control.attr('data-icon-show') || 'eye',
      iconHide = $control.attr('data-icon-hide') || 'eye-blocked';

  if (toggle) {
    icons.right = control.type == 'password' ? iconShow : iconHide;
  }

  addIcon($control, icons);

  if (toggle) {
    tap(that, $parent.find('.mbsc-right-ic').addClass('mbsc-input-toggle'), function () {
      if (control.type == "text") {
        control.type = "password";
        $$1(this).addClass('mbsc-ic-' + iconShow).removeClass('mbsc-ic-' + iconHide);
      } else {
        control.type = "text";
        $$1(this).removeClass('mbsc-ic-' + iconShow).addClass('mbsc-ic-' + iconHide);
      }
    });
  }
}

function wrapLabel($parent, type, inputStyle, labelStyle, elm) {
  // Wrap non-empty text nodes in span with mbsc-label class
  if (type == 'segmented') {
    $parent.closest('.mbsc-segmented').addClass(inputStyle == 'box' ? 'mbsc-input-box' : '').addClass(inputStyle == 'outline' ? 'mbsc-input-outline' : '');
  } else if (type != 'button' && type != 'submit') {
    $parent.addClass('mbsc-control-w').addClass(inputStyle == 'box' ? 'mbsc-input-box' : '').addClass(inputStyle == 'outline' ? 'mbsc-input-outline' : '').addClass(labelStyle == 'inline' ? 'mbsc-label-inline' : '').addClass(labelStyle == 'stacked' ? 'mbsc-label-stacked' : '').addClass(labelStyle == 'floating' ? 'mbsc-label-floating' : '').addClass(labelStyle == 'floating' && elm.value ? 'mbsc-label-floating-active' : '').find('label').addClass('mbsc-label').each(function (i, v) {
      $$1(v).attr('title', $$1(v).text());
    });
    $parent.contents().filter(function () {
      return this.nodeType == 3 && this.nodeValue && /\S/.test(this.nodeValue);
    }).each(function () {
      $$1('<span class="mbsc-label" title="' + this.textContent.trim() + '"></span>').insertAfter(this).append(this);
    });
  }
}

function getRipple(theme) {
  var ripple = mobiscroll.themes.form[theme];
  return ripple && ripple.addRipple ? ripple : null;
}

function getAttr($elm, attr, def) {
  var v = $elm.attr(attr);
  return v === undefined || v === '' ? def : v;
}

function getCssClass(s) {
  var theme = getThemeName(s);
  var baseTheme = mobiscroll.themes.form[theme].baseTheme;
  return 'mbsc-' + theme + (baseTheme ? ' mbsc-' + baseTheme : '') + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr');
}

var FormControl =
/*#__PURE__*/
function () {
  function FormControl(elm, settings) {
    var _this = this;

    var s = extend$1({}, defaults, mobiscroll.settings, settings);
    var $elm = $$1(elm);
    var $p = $elm.parent();
    var $parent = $p.hasClass('mbsc-input-wrap') ? $p.parent() : $p; // Check for inline mobiscroll components

    var $frame = $elm.next().hasClass('mbsc-fr') ? $elm.next() : null;
    var type = getControlType($elm);
    var inputStyle = getAttr($elm, 'data-input-style', s.inputStyle);
    var labelStyle = getAttr($elm, 'data-label-style', s.labelStyle);

    if (elm.mbscInst) {
      elm.mbscInst.destroy();
    }

    if ($frame) {
      $frame.insertAfter($parent);
    }

    s.theme = getThemeName(s);

    if (s.rtl === undefined && s.lang && mobiscroll.i18n[s.lang]) {
      s.rtl = mobiscroll.i18n[s.lang].rtl;
    }

    wrapLabel($parent, type, inputStyle, labelStyle, elm);
    $elm.addClass('mbsc-control'); // Attach events

    this._handle = this._handle.bind(this); // Prevent 300ms click latency

    events.forEach(function (ev) {
      $elm.on(ev, _this._handle);
    }); // Touch events are added separately, needs to be passive listener

    listen(elm, 'touchstart', this._handle, {
      passive: true
    });
    listen(elm, 'touchmove', this._handle, {
      passive: true
    });
    this.settings = s;
    this._type = type;
    this._elm = elm;
    this._$elm = $elm;
    this._$parent = $parent;
    this._$frame = $frame;
    this._ripple = getRipple(s.theme);
    this._isFloating = labelStyle == 'floating' || $parent.hasClass('mbsc-label-floating');
    this.cssClass = getCssClass(s);
    this.getClassElm().addClass(this.cssClass);
    elm.mbscInst = this;
  }

  var _proto = FormControl.prototype;

  _proto.getClassElm = function getClassElm() {
    return this._$parent;
  };

  _proto.destroy = function destroy() {
    var _this2 = this;

    var $elm = this._$elm;
    var elm = this._elm;
    $elm.removeClass('mbsc-control');
    this.getClassElm().removeClass(this.cssClass);
    events.forEach(function (ev) {
      $elm.off(ev, _this2._handle);
    });
    unlisten(elm, 'touchstart', this._handle, {
      passive: true
    });
    unlisten(elm, 'touchmove', this._handle, {
      passive: true
    });
    delete elm.mbscInst;
  };

  _proto.option = function option(s) {
    extend$1(this.settings, s);
    var classElm = this.getClassElm();

    if (this.cssClass) {
      classElm.removeClass(this.cssClass);
    }

    this.cssClass = getCssClass(this.settings);
    classElm.addClass(this.cssClass);
    this._ripple = getRipple(this.settings.theme);
  };

  _proto._handle = function _handle(ev) {
    switch (ev.type) {
      case 'touchstart':
      case 'mousedown':
        this._onStart(ev);

        break;

      case 'touchmove':
      case 'mousemove':
        this._onMove(ev);

        break;

      case 'touchend':
      case 'touchcancel':
      case 'mouseup':
      case 'mouseleave':
        this._onEnd(ev);

        break;
    }
  };

  _proto._addRipple = function _addRipple(ev) {
    if (this._ripple && this._$rippleElm) {
      this._ripple.addRipple(this._$rippleElm, ev);
    }
  };

  _proto._removeRipple = function _removeRipple() {
    if (this._ripple && this._$rippleElm) {
      this._ripple.removeRipple();
    }
  };

  _proto._onStart = function _onStart(ev) {
    var elm = this._elm;

    if (testTouch(ev, elm)) {
      this._startX = getCoord(ev, 'X');
      this._startY = getCoord(ev, 'Y');

      if ($active) {
        $active.removeClass('mbsc-active');
      }

      if (!elm.disabled) {
        this._isActive = true;
        $active = this._$elm;
        $active.addClass('mbsc-active');

        this._addRipple(ev);
      }
    }

    if (ev.type == 'touchstart') {
      this._$elm.closest('.mbsc-no-touch').removeClass('mbsc-no-touch');
    }
  };

  _proto._onMove = function _onMove(ev) {
    // If movement is more than 9px, don't fire the click event handler
    if (this._isActive && Math.abs(getCoord(ev, 'X') - this._startX) > 9 || Math.abs(getCoord(ev, 'Y') - this._startY) > 9) {
      this._$elm.removeClass('mbsc-active');

      this._removeRipple();

      this._isActive = false;
    }
  };

  _proto._onEnd = function _onEnd(ev) {
    var _this3 = this;

    var control = this._elm;
    var type = this._type;

    if (this._isActive && this.settings.tap && ev.type == 'touchend' && !control.readOnly) {
      activateControl(control, type, ev);
    }

    if (this._isActive) {
      setTimeout(function () {
        _this3._$elm.removeClass('mbsc-active');

        _this3._removeRipple();
      }, 100);
    }

    this._isActive = false;
    $active = null;
  };

  return FormControl;
}();
mobiscroll.themes.form.mobiscroll = {};

var events$1 = ['focus', 'change', 'blur', 'animationstart'];
var Input =
/*#__PURE__*/
function (_FormControl) {
  _inheritsLoose(Input, _FormControl);

  function Input(elm, settings) {
    var _this;

    _this = _FormControl.call(this, elm, settings) || this;
    var $elm = _this._$elm;
    var $parent = _this._$parent;
    var $dummy = $parent.find('.mbsc-select-input, .mbsc-color-input');
    addIconToggle(_assertThisInitialized(_this), $parent, $elm);
    _this._checkLabel = _this._checkLabel.bind(_assertThisInitialized(_this));
    _this._mouseDown = _this._mouseDown.bind(_assertThisInitialized(_this));
    _this._setText = _this._setText.bind(_assertThisInitialized(_this));

    if (elm.type == 'file') {
      // Copy attributes and create dummy input
      var $existing = $parent.find('.mbsc-file-input');
      _this._$input = $existing.length ? $existing : $$1('<input type="text" class="' + ($elm.attr('class') || '') + ' mbsc-file-input" placeholder="' + ($elm.attr('placeholder') || '') + '"/>').insertAfter($elm); // Copy value on file upload

      $elm.on('change', _this._setText);
    }

    $parent.addClass('mbsc-input').on('mousedown', _this._mouseDown); // Attach events

    events$1.forEach(function (ev) {
      $elm.on(ev, _this._checkLabel);
    }); // Move the dummy input after the element for correct styling

    if ($dummy.length) {
      $elm.after($dummy);

      if ($dummy.hasClass('mbsc-select-input')) {
        _this._delm = $dummy[0];

        _this.refresh();
      }
    }

    return _this;
  }

  var _proto = Input.prototype;

  _proto._setText = function _setText(ev) {
    var files = ev.target.files;
    var names = [];

    for (var i = 0; i < files.length; ++i) {
      names.push(files[i].name);
    }

    this._$input.val(names);
  };

  _proto._checkLabel = function _checkLabel(ev) {
    if (this._isFloating) {
      // In case of select we need to check the dummy element
      var elm = this._delm || this._elm; // In case of autofill in webkit browsers the animationstart event will fire 
      // due to the empty animation added in the css,
      // because there's no other event in case of the initial autofill

      if (elm.value || document.activeElement === elm || ev && (ev.type == 'focus' || ev.type == 'animationstart' && this._$elm.is('*:-webkit-autofill'))) {
        this._$parent.addClass('mbsc-label-floating-active');
      } else {
        this._$parent.removeClass('mbsc-label-floating-active');
      }
    }
  };

  _proto._mouseDown = function _mouseDown(ev) {
    // Will prevent floating label animation when loosing focus only for a brief moment
    if (document.activeElement === this._elm && ev.target !== this._elm) {
      ev.preventDefault();
    }
  };

  _proto.refresh = function refresh() {
    this._checkLabel();
  };

  _proto.destroy = function destroy() {
    var _this2 = this;

    _FormControl.prototype.destroy.call(this);

    this._$parent.off('mousedown', this._mouseDown).removeClass('mbsc-ic-left mbsc-ic-right').find('.mbsc-input-ic').remove();

    this._$parent.find('.mbsc-input-fill').remove();

    events$1.forEach(function (ev) {
      _this2._$elm.off(ev, _this2._checkLabel);
    });

    this._$elm.off('change', this._setText);
  };

  return Input;
}(FormControl); // Init mbsc-input elements on page load

autoInit('[mbsc-input]', Input);

var MbscFormBase = (function (_super) {
    __extends(MbscFormBase, _super);
    function MbscFormBase(hostElem, _formService, zone) {
        var _this = _super.call(this, hostElem, zone) || this;
        _this._formService = _formService;
        _this.disabled = false;
        return _this;
    }
    MbscFormBase.prototype.ngOnInit = function () {
        this._inheritedOptions = this._formService ? this._formService.options : {};
    };
    MbscFormBase.decorators = [
        { type: Directive, args: [{ selector: '[mbsc-f-b]' },] },
    ];
    MbscFormBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, },
        { type: NgZone, },
    ]; };
    MbscFormBase.propDecorators = {
        'color': [{ type: Input$1 },],
        'options': [{ type: Input$1 },],
        'disabled': [{ type: Input$1 },],
        'name': [{ type: Input$1 },],
        '_initElem': [{ type: ViewChild, args: ['initElement', { static: false },] },],
    };
    return MbscFormBase;
}(MbscBase));
var MbscFormValueBase = (function (_super) {
    __extends(MbscFormValueBase, _super);
    function MbscFormValueBase(hostElem, _formService, _inputService, _control, zone) {
        var _this = _super.call(this, hostElem, _formService, zone) || this;
        _this._control = _control;
        _this.onChange = function () { };
        _this.onTouch = function () { };
        _this.errorMessage = '';
        _this.valueChangeEmitter = new EventEmitter();
        if (_control && (!_inputService || !_inputService.isControlSet)) {
            if (_control.valueAccessor && _control.valueAccessor.oldAccessor !== undefined) {
                _control.valueAccessor.oldAccessor = _this;
            }
            else {
                _control.valueAccessor = _this;
            }
        }
        return _this;
    }
    Object.defineProperty(MbscFormValueBase.prototype, "readonly", {
        set: function (val) {
            this._readonly = emptyOrTrue(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscFormValueBase.prototype, "innerValue", {
        get: function () {
            return this._value;
        },
        set: function (v) {
            this._value = v;
            this.onChange(v);
            this.valueChangeEmitter.emit(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscFormValueBase.prototype, "value", {
        set: function (v) {
            this._value = v;
            this.refresh();
        },
        enumerable: true,
        configurable: true
    });
    MbscFormValueBase.prototype.registerOnChange = function (fn) {
        this.onChange = fn;
    };
    MbscFormValueBase.prototype.registerOnTouched = function (fn) {
        this.onTouch = fn;
    };
    MbscFormValueBase.prototype.setDisabledState = function (isDisabled) {
        this.disabled = isDisabled;
    };
    MbscFormValueBase.prototype.writeValue = function (v) {
        this._value = v;
        this.refresh();
    };
    MbscFormValueBase.prototype.refresh = function () {
        var _this = this;
        if (this.instance && this.instance.refresh) {
            setTimeout(function () {
                _this.instance.refresh();
            });
        }
        else {
            this._needRefresh = true;
        }
    };
    MbscFormValueBase.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        if (this._needRefresh) {
            this.refresh();
        }
    };
    MbscFormValueBase.decorators = [
        { type: Directive, args: [{ selector: '[mbsc-fv-b]' },] },
    ];
    MbscFormValueBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: NgControl, },
        { type: NgZone, },
    ]; };
    MbscFormValueBase.propDecorators = {
        'readonly': [{ type: Input$1 },],
        'value': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
        'valueChangeEmitter': [{ type: Output, args: ['valueChange',] },],
    };
    return MbscFormValueBase;
}(MbscFormBase));
var MbscInputBase = (function (_super) {
    __extends(MbscInputBase, _super);
    function MbscInputBase(initialElem, _formService, _inputService, _control, zone) {
        var _this = _super.call(this, initialElem, _formService, _inputService, _control, zone) || this;
        _this.type = 'text';
        _this.placeholder = '';
        return _this;
    }
    MbscInputBase.decorators = [
        { type: Directive, args: [{ selector: '[mbsc-i-b]' },] },
    ];
    MbscInputBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: NgControl, },
        { type: NgZone, },
    ]; };
    MbscInputBase.propDecorators = {
        'autocomplete': [{ type: Input$1 },],
        'autocapitalize': [{ type: Input$1 },],
        'autocorrect': [{ type: Input$1 },],
        'spellcheck': [{ type: Input$1 },],
        'autofocus': [{ type: Input$1 },],
        'minlength': [{ type: Input$1 },],
        'maxlength': [{ type: Input$1 },],
        'required': [{ type: Input$1 },],
        'icon': [{ type: Input$1 },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'type': [{ type: Input$1 },],
        'passwordToggle': [{ type: Input$1, args: ['password-toggle',] },],
        'iconShow': [{ type: Input$1, args: ['icon-show',] },],
        'iconHide': [{ type: Input$1, args: ['icon-hide',] },],
        'iconUpload': [{ type: Input$1, args: ['icon-upload',] },],
        'inputStyle': [{ type: Input$1, args: ['input-style',] },],
        'labelStyle': [{ type: Input$1, args: ['label-style',] },],
        'placeholder': [{ type: Input$1 },],
    };
    return MbscInputBase;
}(MbscFormValueBase));
var MbscInput = (function (_super) {
    __extends(MbscInput, _super);
    function MbscInput(initialElem, _formService, _inputService, _control, zone) {
        var _this = _super.call(this, initialElem, _formService, _inputService, _control, zone) || this;
        _this._inputService = _inputService;
        _this.controlNg = true;
        _this.dropdown = false;
        _inputService.input = _this;
        return _this;
    }
    MbscInput.prototype.initControl = function () {
        var _this = this;
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new Input(this._initElem.nativeElement, options);
        setTimeout(function () {
            _this.instance.refresh();
        });
    };
    MbscInput.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-input',
                    host: {
                        '[class.mbsc-control-ng]': 'controlNg',
                        '[class.mbsc-err]': 'error'
                    },
                    template: "\n        <label\n            [class.mbsc-err]=\"error\" [class.mbsc-select]=\"dropdown\"\n            [class.mbsc-input-box]=\"inputStyle == 'box'\"\n            [class.mbsc-input-outline]=\"inputStyle == 'outline'\"\n            [class.mbsc-label-stacked]=\"labelStyle == 'stacked'\"\n            [class.mbsc-label-inline]=\"labelStyle == 'inline'\"\n            [class.mbsc-label-floating]=\"labelStyle == 'floating'\"\n        >\n            <ng-content></ng-content>\n            <span class=\"mbsc-input-wrap\">\n                <input #initElement [type]=\"type\" [placeholder]=\"placeholder\" [(ngModel)]=\"innerValue\" (blur)=\"onTouch($event)\"\n                    [attr.name]=\"name\"\n                    [attr.data-icon]=\"icon ? icon : null\"\n                    [attr.data-icon-align]=\"iconAlign ? iconAlign : null\"\n                    [attr.data-password-toggle]=\"passwordToggle ? 'true': null\"\n                    [attr.data-icon-show]=\"iconShow ? iconShow : null\"\n                    [attr.data-icon-hide]=\"iconHide ? iconHide : null\"\n                    [attr.data-icon-upload]=\"iconUpload ? iconUpload : null\"\n                    [attr.min]=\"min\"\n                    [attr.max]=\"max\"\n                    [attr.minlength]=\"minlength\"\n                    [attr.maxlength]=\"maxlength\"\n                    [attr.autocomplete]=\"autocomplete\"\n                    [attr.autocapitalize]=\"autocapitalize\"\n                    [attr.autocorrect]=\"autocorrect\"\n                    [attr.spellcheck]=\"spellcheck\"\n                    [attr.autofocus]=\"autofocus\"\n                    [attr.step]=\"step\"\n                    [attr.pattern]=\"pattern\"\n                    [attr.required]=\"required\"\n                    [attr.accept]=\"accept\"\n                    [attr.multiple]=\"multiple\"\n                    [disabled]=\"disabled\"\n                    [readonly]=\"_readonly\" />\n                <span *ngIf=\"dropdown\" class=\"mbsc-select-ic mbsc-ic mbsc-ic-arrow-down5\"></span>\n                <span *ngIf=\"error && errorMessage\" class=\"mbsc-err-msg\">{{errorMessage}}</span>\n            </span>\n        </label>\n    ",
                    providers: [MbscInputService]
                },] },
    ];
    MbscInput.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscInputService, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: NgZone, },
    ]; };
    MbscInput.propDecorators = {
        'min': [{ type: Input$1 },],
        'max': [{ type: Input$1 },],
        'step': [{ type: Input$1 },],
        'pattern': [{ type: Input$1 },],
        'accept': [{ type: Input$1 },],
        'multiple': [{ type: Input$1 },],
        'controlNg': [{ type: Input$1 },],
        'dropdown': [{ type: Input$1 },],
    };
    return MbscInput;
}(MbscInputBase));
var MbscInputModule = (function () {
    function MbscInputModule() {
    }
    MbscInputModule.decorators = [
        { type: NgModule, args: [{
                    imports: [FormsModule, CommonModule, MbscBaseModule],
                    declarations: [MbscInput, MbscInputBase, MbscFormBase, MbscFormValueBase],
                    exports: [MbscInput]
                },] },
    ];
    MbscInputModule.ctorParameters = function () { return []; };
    return MbscInputModule;
}());

var Button =
/*#__PURE__*/
function (_FormControl) {
  _inheritsLoose(Button, _FormControl);

  function Button(elm, settings) {
    var _this;

    _this = _FormControl.call(this, elm, settings) || this;
    var $elm = _this._$elm;
    var hasIcon = $elm.attr('data-icon');
    $elm.addClass('mbsc-btn mbsc-no-touch').find('.mbsc-btn-ic').remove();

    if (hasIcon) {
      $elm.prepend('<span class="mbsc-btn-ic mbsc-ic mbsc-ic-' + hasIcon + '"></span>');

      if ($elm.text() === "") {
        $elm.addClass('mbsc-btn-icon-only');
      }
    }

    _this._$rippleElm = $elm;
    return _this;
  }

  var _proto = Button.prototype;

  _proto.getClassElm = function getClassElm() {
    return this._$elm;
  };

  return Button;
}(FormControl); // Init mbsc-button elements on page load

autoInit('[mbsc-button]', Button);

var CheckBox =
/*#__PURE__*/
function (_FormControl) {
  _inheritsLoose(CheckBox, _FormControl);

  function CheckBox(elm, settings) {
    var _this;

    _this = _FormControl.call(this, elm, settings) || this;

    _this._$parent.prepend(_this._$elm).addClass('mbsc-checkbox mbsc-control-w').find('.mbsc-checkbox-box').remove();

    _this._$elm.after('<span class="mbsc-checkbox-box"></span>');

    return _this;
  }

  return CheckBox;
}(FormControl); // Init mbsc-checkbox elements on page load

autoInit('[mbsc-checkbox]', CheckBox);

var Radio =
/*#__PURE__*/
function (_FormControl) {
  _inheritsLoose(Radio, _FormControl);

  function Radio(elm, settings) {
    var _this;

    _this = _FormControl.call(this, elm, settings) || this;

    _this._$parent.addClass('mbsc-radio mbsc-control-w').find('.mbsc-radio-box').remove();

    _this._$elm.after('<span class="mbsc-radio-box"><span></span></span>');

    return _this;
  }

  return Radio;
}(FormControl); // Init mbsc-radio elements on page load

autoInit('[mbsc-radio]', Radio);

var Select =
/*#__PURE__*/
function (_Input) {
  _inheritsLoose(Select, _Input);

  function Select(elm, settings) {
    var _this;

    _this = _Input.call(this, elm, settings) || this;
    var $elm = _this._$elm;
    var $parent = _this._$parent;
    var $existing = $parent.find('.mbsc-select-input');
    var $input = $existing.length ? $existing : $$1('<input tabindex="-1" class="mbsc-select-input mbsc-control" readonly>');
    _this._$input = $input;
    _this._delm = $input[0];
    _this._setText = _this._setText.bind(_assertThisInitialized(_this));
    $parent.addClass('mbsc-select' + (_this._$frame ? ' mbsc-select-inline' : ''));
    $elm.after($input);
    $input.after('<span class="mbsc-select-ic mbsc-ic mbsc-ic-arrow-down5"></span>'); // Update dummy input text on change

    $elm.on('change', _this._setText);

    _this._setText();

    return _this;
  }

  var _proto = Select.prototype;

  _proto.destroy = function destroy() {
    _Input.prototype.destroy.call(this);

    this._$parent.find('.mbsc-select-ic').remove();

    this._$elm.off('change', this._setText);
  };

  _proto._setText = function _setText() {
    var elm = this._elm;
    var $elm = $$1(elm); // Check if select and mobiscroll select was not initialized

    if ($elm.is('select') && !$elm.hasClass('mbsc-comp')) {
      this._$input.val(elm.selectedIndex != -1 ? elm.options[elm.selectedIndex].text : '');
    } // Check floating label


    this.refresh();
  };

  return Select;
}(Input); // Init mbsc-select elements on page load

autoInit('[mbsc-dropdown]', Select);

var events$2 = ['change', 'keydown', 'input', 'scroll'];
var sizeDebounce;

function sizeTextAreas() {
  clearTimeout(sizeDebounce);
  sizeDebounce = setTimeout(function () {
    $$1('textarea.mbsc-control').each(function () {
      sizeTextArea(this);
    });
  }, 100);
}

function sizeTextArea(control) {
  var height,
      lineNr,
      line,
      rowNr = $$1(control).attr('rows') || 6;

  if (control.offsetHeight) {
    control.style.height = '';
    line = control.scrollHeight - control.offsetHeight;
    height = control.offsetHeight + (line > 0 ? line : 0);
    lineNr = Math.round(height / 24);

    if (lineNr > rowNr) {
      //control.scrollTop = height;
      height = 24 * rowNr + (height - lineNr * 24);
      $$1(control).addClass('mbsc-textarea-scroll');
    } else {
      $$1(control).removeClass('mbsc-textarea-scroll');
    }

    if (height) {
      control.style.height = height + 'px';
    }
  }
}

function scrollTextArea(elm) {
  var $elm = $$1(elm);

  if (!$elm.hasClass('mbsc-textarea-scroll')) {
    var line = elm.scrollHeight - elm.offsetHeight,
        height = elm.offsetHeight + line,
        lineNr = Math.round(height / 24),
        rowNr = $elm.attr('rows') || 6;

    if (lineNr <= rowNr) {
      elm.scrollTop = 0;
      elm.style.height = height + 'px';
    }
  }
}

if (isBrowser) {
  // Set height of textareas on viewport size changes
  $$1(window).on('resize orientationchange', sizeTextAreas);
}

var TextArea =
/*#__PURE__*/
function (_Input) {
  _inheritsLoose(TextArea, _Input);

  function TextArea(elm, settings) {
    var _this;

    _this = _Input.call(this, elm, settings) || this;

    _this._$parent.addClass('mbsc-textarea');

    events$2.forEach(function (ev) {
      _this._$elm.on(ev, _this._handle);
    });
    sizeTextArea(elm);
    return _this;
  }

  var _proto = TextArea.prototype;

  _proto.destroy = function destroy() {
    var _this2 = this;

    _Input.prototype.destroy.call(this);

    events$2.forEach(function (ev) {
      _this2._$elm.off(ev, _this2._handle);
    });
  };

  _proto.refresh = function refresh() {
    _Input.prototype.refresh.call(this);

    clearTimeout(this._debounce);
    sizeTextArea(this._elm);
  };

  _proto._handle = function _handle(ev) {
    _Input.prototype._handle.call(this, ev);

    switch (ev.type) {
      case 'change':
        sizeTextArea(this._elm);
        break;

      case 'keydown':
      case 'input':
        this._onInput(ev);

        break;

      case 'scroll':
        scrollTextArea(this._elm);
    }
  };

  _proto._onInput = function _onInput() {
    var _this3 = this;

    clearTimeout(this._debounce);
    this._debounce = setTimeout(function () {
      sizeTextArea(_this3._elm);
    }, 100);
  };

  return TextArea;
}(Input);

autoInit('[mbsc-textarea]', TextArea);

var SegmentedItem =
/*#__PURE__*/
function (_FormControl) {
  _inheritsLoose(SegmentedItem, _FormControl);

  function SegmentedItem(elm, settings) {
    var _this;

    _this = _FormControl.call(this, elm, settings) || this;
    var $segmentCont;
    var $segment;
    var $elm = _this._$elm;
    var $parent = _this._$parent;

    if (!$parent.hasClass('mbsc-segmented-item-ready')) {
      $segmentCont = $$1('<div class="mbsc-segmented mbsc-segmented-group mbsc-no-touch"></div>');
      $parent.after($segmentCont);
      $parent.parent().find('input[name="' + $elm.attr('name') + '"]').each(function () {
        var $input = $$1(this);
        $segment = $input.parent().addClass('mbsc-segmented-item mbsc-segmented-item-ready');
        $$1('<span class="mbsc-segmented-content">' + ($input.attr('data-icon') ? '<span class="mbsc-ic mbsc-ic-' + $input.attr('data-icon') + '"></span>' : '') + '</span>').append($segment.contents()).appendTo($segment);
        $segment.prepend($input);
        $segmentCont.append($segment);
      });
    }

    _this._$rippleElm = $elm.next();
    return _this;
  }

  var _proto = SegmentedItem.prototype;

  _proto.getClassElm = function getClassElm() {
    return this._$elm.closest('.mbsc-segmented');
  };

  return SegmentedItem;
}(FormControl); // Init mbsc-segmented elements on page load

autoInit('[mbsc-segmented]', SegmentedItem);

function createStepper($elm, action, delay, isReadOnly, stopProp, ripple) {
  var $btn,
      changed,
      index,
      running,
      source,
      startX,
      startY,
      step,
      timer,
      check = isReadOnly || noop;

  function onBtnStart(ev) {
    var proceed;
    $btn = $$1(ev.currentTarget);
    step = +$btn.attr('data-step');
    index = +$btn.attr('data-index');
    changed = true;

    if (stopProp) {
      ev.stopPropagation();
    }

    if (ev.type == 'touchstart') {
      $btn.closest('.mbsc-no-touch').removeClass('mbsc-no-touch');
    }

    if (ev.type == 'mousedown') {
      // Prevent focus
      ev.preventDefault();
    }

    if (ev.type != 'keydown') {
      //e.preventDefault();
      startX = getCoord(ev, 'X');
      startY = getCoord(ev, 'Y');
      proceed = testTouch(ev, this);
    } else {
      proceed = ev.keyCode === 32;
    }

    if (!running && proceed && !$btn.hasClass('mbsc-disabled')) {
      if (start(index, step, ev)) {
        $btn.addClass('mbsc-active');

        if (ripple) {
          ripple.addRipple($btn.find('.mbsc-segmented-content'), ev);
        }
      }

      if (ev.type == 'mousedown') {
        $$1(document).on('mousemove', onBtnMove).on('mouseup', onBtnEnd);
      }
    }
  }

  function onBtnMove(ev) {
    if (Math.abs(startX - getCoord(ev, 'X')) > 7 || Math.abs(startY - getCoord(ev, 'Y')) > 7) {
      changed = true;
      stop();
    }
  }

  function onBtnEnd(ev) {
    if (ev.type == 'touchend') {
      // Prevents iOS scroll on double tap
      ev.preventDefault();
    }

    stop();

    if (ev.type == 'mouseup') {
      $$1(document).off('mousemove', onBtnMove).off('mouseup', onBtnEnd);
    }
  }

  function stop() {
    running = false;
    clearInterval(timer);

    if ($btn) {
      $btn.removeClass('mbsc-active');

      if (ripple) {
        setTimeout(function () {
          ripple.removeRipple();
        }, 100);
      }
    }
  }

  function start(i, st, ev) {
    if (!running && !check(i)) {
      index = i;
      step = st;
      source = ev;
      running = true;
      changed = false;
      setTimeout(tick, 100);
    }

    return running;
  }

  function tick() {
    if ($btn && $btn.hasClass('mbsc-disabled')) {
      stop();
      return;
    }

    if (running || !changed) {
      changed = true;
      action(index, step, source, tick);
    }

    if (running && delay) {
      clearInterval(timer);
      timer = setInterval(function () {
        action(index, step, source);
      }, delay);
    }
  }

  function destroy() {
    $elm.each(function (i, el) {
      unlisten(el, 'touchstart', onBtnStart, {
        passive: true
      });
      unlisten(el, 'mousedown', onBtnStart);
      unlisten(el, 'keydown', onBtnStart);
      unlisten(el, 'touchmove', onBtnMove, {
        passive: true
      });
      unlisten(el, 'touchend', onBtnEnd);
      unlisten(el, 'touchcancel', onBtnEnd);
      unlisten(el, 'keyup', onBtnEnd);
    });
  }

  $elm.each(function (i, el) {
    listen(el, 'touchstart', onBtnStart, {
      passive: true
    });
    listen(el, 'mousedown', onBtnStart);
    listen(el, 'keydown', onBtnStart);
    listen(el, 'touchmove', onBtnMove, {
      passive: true
    });
    listen(el, 'touchend', onBtnEnd);
    listen(el, 'touchcancel', onBtnEnd);
    listen(el, 'keyup', onBtnEnd);
  });
  return {
    start: start,
    stop: stop,
    destroy: destroy
  };
}

var Stepper = function Stepper(control, settings) {
  var $btnPlus,
      $btnMinus,
      $controls,
      cssClass = '',
      displayValue,
      max,
      min,
      inputStyle,
      ripple,
      scale,
      step,
      stepper,
      s,
      theme,
      val,
      that = this,
      $control = $$1(control),
      ready,
      $parent,
      old = val;

  function onChange() {
    var v;

    if (!control.disabled) {
      v = parseFloat($$1(this).val());
      setValue(isNaN(v) ? val : v);
    }
  }

  function checkDisabled() {
    return control.disabled;
  }

  function stepValue(index, dir) {
    setValue(val + dir * step);
  }

  function setValue(v, fill, change) {
    old = val;

    if (fill === undefined) {
      fill = true;
    }

    if (change === undefined) {
      change = fill;
    }

    val = round(v);
    $controls.removeClass('mbsc-disabled');

    if (fill) {
      $control.val(val);
    }

    if (val == min) {
      $btnMinus.addClass('mbsc-disabled');
    }

    if (val == max) {
      $btnPlus.addClass('mbsc-disabled');
    }

    if (val !== old && change) {
      $control.trigger('change');
    }
  }

  function getAttr(attr, def, str) {
    var v = $control.attr(attr);
    return v === undefined || v === '' ? def : str ? v : +v;
  }

  function round(v) {
    return +Math.min(max, Math.max(Math.round(v / step) * step, min)).toFixed(scale);
  } // Call the parent constructor


  Base.call(this, control, settings, true);
  /* TRIALFUNC */

  that.getVal = function () {
    var v = parseFloat($control.val());
    v = isNaN(v) ? val : v;
    return round(v);
  };

  that.setVal = function (v, fill, change) {
    v = parseFloat(v);
    setValue(isNaN(v) ? val : v, fill, change);
  };

  that._init = function () {
    ready = $control.parent().hasClass('mbsc-stepper');
    $parent = ready ? $control.closest('.mbsc-stepper-cont') : $control.parent();
    s = that.settings;
    min = settings.min === undefined ? getAttr('min', s.min) : settings.min;
    max = settings.max === undefined ? getAttr('max', s.max) : settings.max;
    step = settings.step === undefined ? getAttr('step', s.step) : settings.step;
    scale = Math.abs(step) < 1 ? (step + '').split('.')[1].length : 0;
    inputStyle = settings.inputStyle === undefined ? getAttr('data-input-style', s.inputStyle, true) : settings.inputStyle;
    displayValue = $control.attr('data-val') || s.val;
    val = round(+control.value || 0);
    theme = mobiscroll.themes.form[s.theme];
    ripple = theme && theme.addRipple ? theme : null;

    if (!ready) {
      $parent.addClass('mbsc-stepper-cont mbsc-no-touch mbsc-control-w').addClass(inputStyle == 'box' ? 'mbsc-input-box' : '').addClass(inputStyle == 'outline' ? 'mbsc-input-outline' : '').append('<span class="mbsc-segmented mbsc-stepper' + '"></span>').find('.mbsc-stepper').append('<span class="mbsc-segmented-item mbsc-stepper-control mbsc-stepper-minus ' + (val == min ? 'mbsc-disabled' : '') + '" data-step="-1" tabindex="0"><span class="mbsc-segmented-content"><span class="mbsc-ic mbsc-ic-minus"></span></span></span>').append('<span class="mbsc-segmented-item mbsc-stepper-control mbsc-stepper-plus ' + (val == max ? 'mbsc-disabled' : '') + '"  data-step="1" tabindex="0"><span class="mbsc-segmented-content"> <span class="mbsc-ic mbsc-ic-plus"></span></span></span>').prepend($control);
    }

    if (cssClass) {
      $parent.removeClass(cssClass).find('.mbsc-segmented').removeClass(cssClass);
    }

    cssClass = 'mbsc-' + s.theme + (theme.baseTheme ? ' mbsc-' + theme.baseTheme : '') + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr');
    $parent.addClass(cssClass).find('.mbsc-segmented').addClass(cssClass);
    $btnMinus = $$1('.mbsc-stepper-minus', $parent);
    $btnPlus = $$1('.mbsc-stepper-plus', $parent);
    $controls = $$1('.mbsc-stepper-control', $parent);

    if (!ready) {
      if (displayValue == 'left') {
        $parent.addClass('mbsc-stepper-val-left');
        $control.after('<span class="mbsc-segmented-item"><span class="mbsc-segmented-content"></span></span>');
      } else if (displayValue == 'right') {
        $parent.addClass('mbsc-stepper-val-right');
        $btnPlus.after('<span class="mbsc-segmented-item"><span class="mbsc-segmented-content"></span></span>');
      } else {
        $btnMinus.after('<span class="mbsc-segmented-item"><span class="mbsc-segmented-content mbsc-stepper-val"></span></span>');
      }
    }

    if (!stepper) {
      $control.on('change', onChange);
      stepper = createStepper($controls, stepValue, 150, checkDisabled, false, ripple);
    }

    $control.val(val).attr('data-role', 'stepper').attr('min', min).attr('max', max).attr('step', step).addClass('mbsc-control');
    control.mbscInst = that;
  };

  that._destroy = function () {
    $control.removeClass('mbsc-control').off('change', onChange);
    stepper.destroy();
    delete control.mbscInst;
  };

  that.init();
};
Stepper.prototype = {
  _class: 'stepper',
  _hasDef: true,
  _hasTheme: true,
  _hasLang: true,
  _defaults: {
    min: 0,
    max: 100,
    step: 1
  }
};
classes.Stepper = Stepper; // Init mbsc-stepper elements on page load

autoInit('[mbsc-stepper]', Stepper);

var ProgressBase = function ProgressBase(elm, settings, inherit) {
  var $elm,
      $parent,
      cssClass,
      s,
      that = this; // Call the parent constructor

  Base.call(this, elm, settings, true);
  that.__init = noop;
  that.__destroy = noop;

  that._init = function () {
    var wasInit;
    s = that.settings;
    $elm = $$1(elm); // Check if the element was already initialized

    wasInit = !!$parent;
    $parent = $elm.parent();
    $parent = $parent.hasClass('mbsc-input-wrap') ? $parent.parent() : $parent;
    that._$parent = $parent;

    if (cssClass) {
      $parent.removeClass(cssClass);
    }

    cssClass = that._css + ' mbsc-progress-w mbsc-control-w ' + getCssClass(s);
    $parent.addClass(cssClass);
    $elm.addClass('mbsc-control');

    that.__init();

    if (!wasInit) {
      that._attachChange();
    } // Show initial value


    that.refresh();
    elm.mbscInst = that;
  };

  that._destroy = function () {
    that.__destroy();

    $parent.removeClass(cssClass);
    $elm.removeClass('mbsc-control');
    delete elm.mbscInst;
  };

  if (!inherit) {
    that.init();
  }
};

var SliderBase = function SliderBase(elm, settings, inherit) {
  var $elm,
      $handle,
      $handleCont,
      $handles,
      $listeners,
      $parent,
      $track,
      action,
      base,
      changed,
      diffX,
      diffY,
      diff,
      endX,
      endY,
      handleIndex,
      isHover,
      isPressed,
      isRtl,
      live,
      max,
      min,
      moved,
      multiple,
      oldValue,
      step,
      s,
      scale,
      startX,
      startY,
      stepDecimal,
      timer,
      totalWidth,
      value,
      that = this,
      lastUpdate = new Date();

  function onStart(ev) {
    if (ev.type === 'mousedown') {
      ev.preventDefault();
    }

    if (testTouch(ev, this) && (!action || isHover) && !elm.disabled && !elm.readOnly
    /* TRIALCOND */
    ) {
        if (s.stopProp) {
          ev.stopPropagation();
        }

        action = true;
        moved = false;
        changed = false;
        startX = getCoord(ev, 'X');
        startY = getCoord(ev, 'Y');
        endX = startX;
        $track.removeClass('mbsc-progress-anim');
        $handle = multiple ? $$1('.mbsc-slider-handle', this) : $handles;

        if ($handleCont) {
          $handleCont.removeClass('mbsc-handle-curr');
        }

        $handleCont = $handle.parent().addClass('mbsc-active mbsc-handle-curr');
        $elm.addClass('mbsc-active');
        handleIndex = +$handle.attr('data-index');
        totalWidth = $track[0].offsetWidth;
        diff = $track[0].getBoundingClientRect().left;

        if (ev.type === 'mousedown') {
          isPressed = true;
          $$1(document).on('mousemove', onMove).on('mouseup', onEnd);
        }

        if (ev.type === 'mouseenter') {
          isHover = true;
          $$1(document).on('mousemove', onMove);
        }
      }
  }

  function onMove(ev) {
    if (action) {
      endX = getCoord(ev, 'X');
      endY = getCoord(ev, 'Y');
      diffX = endX - startX;
      diffY = endY - startY;

      if (Math.abs(diffX) > 5) {
        moved = true;
      }

      if (moved || isPressed || isHover) {
        if (Math.abs(lastUpdate - new Date()) > 50) {
          lastUpdate = new Date();
          updateSlider(endX, s.round, live && (!isHover || isPressed));
        }
      }

      if (moved) {
        ev.preventDefault();
      } else if (Math.abs(diffY) > 7 && ev.type == 'touchmove') {
        cleanUp();
      }
    }
  }

  function onEnd(ev) {
    if (action) {
      ev.preventDefault();

      if (!multiple) {
        $track.addClass('mbsc-progress-anim');
      }

      if (isHover && !isPressed) {
        updateValue(value[handleIndex], handleIndex, false, false, true);
      } else {
        updateSlider(endX, true, true);
      }

      if (!moved && !changed) {
        if (ev.type == 'touchend') {
          // Prevent ghost click
          preventClick();
        }

        that._onTap(value[handleIndex]);
      }

      if (ev.type == 'mouseup') {
        isPressed = false;
      }

      if (ev.type == 'mouseleave') {
        isHover = false;
      }

      if (!isHover) {
        cleanUp();
      }
    }
  }

  function onCancel() {
    if (action) {
      cleanUp();
    }
  }

  function onChange() {
    var v = that._readValue($$1(this)),
        i = +$$1(this).attr('data-index');

    if (v !== value[i]) {
      value[i] = v;
      oldValue[i] = v;
      updateValue(v, i);
    }
  }

  function onClick(ev) {
    // Prevent propagating click to label
    ev.stopPropagation();
  }

  function onLabelClick(ev) {
    // Prevent change on label click for swithes
    ev.preventDefault();
  }

  function onKeyDown(ev) {
    var dir;

    if (!elm.disabled) {
      switch (ev.keyCode) {
        case 38:
        case 39:
          dir = 1;
          break;

        case 40:
        case 37:
          dir = -1;
          break;
      }

      if (dir) {
        ev.preventDefault();

        if (!timer) {
          handleIndex = +$$1(this).attr('data-index');
          updateValue(value[handleIndex] + step * dir, handleIndex, true);
          timer = setInterval(function () {
            updateValue(value[handleIndex] + step * dir, handleIndex, true);
          }, 200);
        }
      }
    }
  }

  function onKeyUp(ev) {
    ev.preventDefault();
    clearInterval(timer);
    timer = null;
  }

  function cleanUp() {
    action = false;
    $handleCont.removeClass('mbsc-active');
    $elm.removeClass('mbsc-active'); // Detach document events

    $$1(document).off('mousemove', onMove).off('mouseup', onEnd);
  }

  function updateSlider(pos, round, fill) {
    var percent = round ? Math.min(Math[that._rounding || 'round'](Math.max((pos - diff) * 100 / totalWidth, 0) / scale / step) * step * 100 / (max - min + base), 100) : Math.max(0, Math.min((pos - diff) * 100 / totalWidth, 100));

    if (isRtl) {
      percent = 100 - percent;
    }

    updateValue(Math.round((min - base + percent / scale) * stepDecimal) / stepDecimal, handleIndex, fill, percent);
  }

  function updateValue(v, index, fill, percent, refresh, change) {
    var $handle = $handles.eq(index),
        $handleCont = $handle.parent();
    v = Math.min(max, Math.max(v, min));

    if (change === undefined) {
      change = fill;
    }

    if (that._update) {
      v = that._update(v, value, index, percent, multiple, refresh, $handleCont);
    } else {
      $handleCont.css({
        left: isRtl ? 'auto' : (percent || getPercent(v, min, max)) + '%',
        right: isRtl ? (percent || getPercent(v, min, max)) + '%' : 'auto'
      });
    }

    if (v > min) {
      $handleCont.removeClass('mbsc-slider-start');
    } else if (value[index] > min || refresh) {
      $handleCont.addClass('mbsc-slider-start');
    } // Store new value


    if (fill) {
      value[index] = v;
    } // Check if value changed


    if (fill && oldValue[index] != v) {
      changed = true;
      oldValue[index] = v; // Set new value to the input

      that._fillValue(v, index, change);
    }

    $handle.attr('aria-valuenow', v);
  } // Call the parent constructor


  ProgressBase.call(this, elm, settings, true);
  that._onTap = noop;
  that.___init = noop;
  that.___destroy = noop;

  that._attachChange = function () {
    $elm.on(s.changeEvent, onChange);
  };

  that.__init = function () {
    var wasInit;

    if ($handles) {
      wasInit = true;
      $handles.parent().remove();
    }

    that.___init();

    $parent = that._$parent;
    $track = that._$track;
    $elm = $parent.find('input');
    s = that.settings;
    min = that._min;
    max = that._max;
    base = that._base || 0;
    step = that._step;
    live = that._live;
    stepDecimal = step % 1 !== 0 ? 100 / (+(step % 1).toFixed(2) * 100) : 1;
    scale = 100 / (max - min + base) || 100;
    multiple = $elm.length > 1;
    isRtl = s.rtl;
    value = [];
    oldValue = []; // Read values

    $elm.each(function (i) {
      value[i] = that._readValue($$1(this));
      $$1(this).attr('data-index', i);
    });
    $handles = $parent.find('.mbsc-slider-handle');
    $listeners = $parent.find(multiple ? '.mbsc-slider-handle-cont' : '.mbsc-progress-cont'); // Attach events

    $handles.on('keydown', onKeyDown).on('keyup', onKeyUp).on('blur', onKeyUp);
    $listeners.each(function (i, listener) {
      listen(listener, 'touchstart', onStart, {
        passive: true
      });
      listen(listener, 'mousedown', onStart);
      listen(listener, 'touchend', onEnd);
      listen(listener, 'touchcancel', onEnd);
      listen(listener, 'pointercancel', onCancel);

      if (s.hover) {
        listen(listener, 'mouseenter', onStart);
        listen(listener, 'mouseleave', onEnd);
      }
    });

    if (!wasInit) {
      $elm.on('click', onClick);
      $parent.on('click', onLabelClick); // Attach to document to avoid non-passive listener warnings

      listen(document, 'touchmove', onMove, {
        passive: false
      });
    }
  };

  that.__destroy = function () {
    $parent.off('click', onLabelClick);
    $elm.off(s.changeEvent, onChange).off('click', onClick);
    $handles.off('keydown', onKeyDown).off('keyup', onKeyUp).off('blur', onKeyUp);
    $listeners.each(function (i, listener) {
      unlisten(listener, 'touchstart', onStart, {
        passive: true
      });
      unlisten(listener, 'mousedown', onStart);
      unlisten(listener, 'touchend', onEnd);
      unlisten(listener, 'touchcancel', onEnd);
      unlisten(listener, 'pointercancel', onCancel);
      unlisten(listener, 'mouseenter', onStart);
      unlisten(listener, 'mouseleave', onEnd);
      unlisten(document, 'touchmove', onMove, {
        passive: false
      });
    });

    that.___destroy();
  };

  that.refresh = function () {
    $elm.each(function (i) {
      updateValue(that._readValue($$1(this)), i, true, false, true, false);
    });
  };

  that.getVal = function () {
    return multiple ? value.slice(0) : value[0];
  };

  that.setVal = that._setVal = function (val, fill, change) {
    if (!$$1.isArray(val)) {
      val = [val];
    }

    $$1.each(val, function (i, v) {
      value[i] = v;
    });
    $$1.each(val, function (i, v) {
      updateValue(v, i, true, false, true, change);
    });
  };

  if (!inherit) {
    that.init();
  }
};

var Switch = function Switch(elm, settings) {
  var $elm,
      $parent,
      s,
      formControl,
      that = this;
  settings = settings || {};
  extend$1(settings, {
    changeEvent: 'click',
    round: false
  }); // Call the parent constructor

  SliderBase.call(this, elm, settings, true);

  that._readValue = function () {
    return elm.checked ? 1 : 0;
  };

  that._fillValue = function (v, index, change) {
    $elm.prop('checked', !!v);

    if (change) {
      $elm.trigger('change');
    }
  };

  that._onTap = function (v) {
    that._setVal(v ? 0 : 1);
  };

  that.___init = function () {
    s = that.settings;
    $elm = $$1(elm);
    $parent = $elm.parent();
    $parent.find('.mbsc-switch-track').remove();
    $parent.prepend($elm);
    $elm.attr('data-role', 'switch').after('<span class="mbsc-progress-cont mbsc-switch-track">' + '<span class="mbsc-progress-track mbsc-progress-anim">' + '<span class="mbsc-slider-handle-cont">' + '<span class="mbsc-slider-handle mbsc-switch-handle" data-index="0">' + '<span class="mbsc-switch-txt-off">' + s.offText + '</span>' + '<span class="mbsc-switch-txt-on">' + s.onText + '</span>' + '</span></span></span></span>');

    if (formControl) {
      formControl.destroy();
    }

    formControl = new FormControl(elm, s);
    that._$track = $parent.find('.mbsc-progress-track');
    that._min = 0;
    that._max = 1;
    that._step = 1;
  };

  that.___destroy = function () {
    formControl.destroy();
  };

  that.getVal = function () {
    return elm.checked;
  };

  that.setVal = function (val, fill, change) {
    that._setVal(val ? 1 : 0, fill, change);
  };

  that.init();
};
Switch.prototype = {
  _class: 'switch',
  _css: 'mbsc-switch',
  _hasTheme: true,
  _hasLang: true,
  _hasDef: true,
  _defaults: {
    stopProp: true,
    offText: 'Off',
    onText: 'On'
  }
};
classes.Switch = Switch; // Init mbsc-switch elements on page load

autoInit('[mbsc-switch]', Switch);

// eslint-disable-next-line no-unused-vars
var Progress = function Progress(elm, settings, inherit) {
  var $display,
      $elm,
      $parent,
      $progress,
      $target,
      $track,
      min,
      max,
      inputStyle,
      labelStyle,
      s,
      template,
      value,
      valueText,
      that = this;

  function onChange() {
    var v = getAttr('value', min);

    if (v !== value) {
      updateValue(v);
    }
  }

  function getAttr(attr, def, str) {
    var v = $elm.attr(attr);
    return v === undefined || v === '' ? def : str ? v : +v;
  }

  function updateValue(v, refresh, fill, change) {
    v =
    /* TRIALCONDREV */
    Math.min(max, Math.max(v, min));
    $progress.css('width', (v - min) * 100 / (max - min) + '%');

    if (fill === undefined) {
      fill = true;
    }

    if (change === undefined) {
      change = fill;
    }

    if (v !== value || refresh) {
      // Display value
      that._display(v);
    }

    if (v !== value) {
      // Set new value
      value = v; // Put new value in the progress element

      if (fill) {
        $elm.attr('value', value);
      } // Trigger change on the element


      if (change) {
        $elm.trigger('change');
      }
    }
  } // Call the parent constructor


  ProgressBase.call(this, elm, settings, true);

  that._display = function (v) {
    valueText = template && s.returnAffix ? template.replace(/\{value\}/, v).replace(/\{max\}/, max) : v;

    if ($target) {
      $target.html(valueText);
    }

    if ($display) {
      $display.html(valueText);
    }
  };

  that._attachChange = function () {
    $elm.on('change', onChange);
  };

  that.__init = function () {
    var displayValue, i, stepLabels, wasInit;
    s = that.settings;
    $elm = $$1(elm); // Check if the element was already initialized

    wasInit = !!$parent;
    $parent = that._$parent; // Read settings from data attributes or settings object

    min = that._min = settings.min === undefined ? getAttr('min', s.min) : settings.min;
    max = that._max = settings.max === undefined ? getAttr('max', s.max) : settings.max;
    inputStyle = settings.inputStyle === undefined ? getAttr('data-input-style', s.inputStyle, true) : settings.inputStyle;
    labelStyle = settings.labelStyle === undefined ? getAttr('data-label-style', s.labelStyle, true) : settings.labelStyle;
    value = getAttr('value', min);
    displayValue = $elm.attr('data-val') || s.val;
    stepLabels = $elm.attr('data-step-labels');
    stepLabels = stepLabels ? JSON.parse(stepLabels) : s.stepLabels;
    template = $elm.attr('data-template') || (max == 100 && !s.template ? '{value}%' : s.template);

    if (!wasInit) {
      wrapLabel($parent, null, inputStyle, labelStyle, elm);
      addIcon($elm); // Generate track and progress

      $parent.find('.mbsc-input-wrap').append('<span class="mbsc-progress-cont"><span class="mbsc-progress-track mbsc-progress-anim"><span class="mbsc-progress-bar"></span></span></span>');
      $progress = that._$progress = $parent.find('.mbsc-progress-bar');
      $track = that._$track = $parent.find('.mbsc-progress-track');
    } else {
      if (displayValue) {
        $display.remove();
        $parent.removeClass('mbsc-progress-value-' + (displayValue == 'right' ? 'right' : 'left'));
      }

      if (stepLabels) {
        $$1('.mbsc-progress-step-label', $track).remove();
      }
    } // Set attributes


    $elm.attr('min', min).attr('max', max); // Generate value container on left or right side

    if (displayValue) {
      $display = $$1('<span class="mbsc-progress-value"></span>');
      $parent.addClass('mbsc-progress-value-' + (displayValue == 'right' ? 'right' : 'left')).find('.mbsc-input-wrap').append($display);
    } // Generate step labels


    if (stepLabels) {
      for (i = 0; i < stepLabels.length; ++i) {
        $track.append('<span class="mbsc-progress-step-label" style="' + (s.rtl ? 'right' : 'left') + ': ' + (stepLabels[i] - min) * 100 / (max - min) + '%" >' + stepLabels[i] + '</span>');
      }
    }

    $target = $$1($elm.attr('data-target') || s.target);
  };

  that.__destroy = function () {
    $parent.removeClass('mbsc-ic-left mbsc-ic-right').find('.mbsc-progress-cont').remove();
    $parent.find('.mbsc-input-ic').remove();
    $elm.off('change', onChange);
  };

  that.refresh = function () {
    updateValue(getAttr('value', min), true, false);
  };

  that.getVal = function () {
    return value;
  };

  that.setVal = function (v, fill, change) {
    updateValue(v, true, fill, change);
  };

  if (!inherit) {
    that.init();
  }
};
Progress.prototype = {
  _class: 'progress',
  _css: 'mbsc-progress',
  _hasTheme: true,
  _hasLang: true,
  _hasDef: true,
  _defaults: {
    min: 0,
    max: 100,
    returnAffix: true
  }
};
classes.Progress = Progress; // Init mbsc-progress elements on page load

autoInit('[mbsc-progress]', Progress);

var Slider = function Slider(elm, settings, inherit) {
  var $elm,
      $parent,
      $progress,
      $tooltips,
      $track,
      hasProgress,
      hasTooltip,
      isRange,
      isRtl,
      max,
      min,
      step,
      s,
      that = this; // Call the parent constructor

  Progress.call(this, elm, settings, true);
  var progressInit = that.__init,
      progressDestroy = that.__destroy;
  SliderBase.call(this, elm, settings, true);
  var sliderInit = that.__init,
      sliderDestroy = that.__destroy; // ---

  that.__init = function () {
    progressInit();
    sliderInit();
  };

  that.__destroy = function () {
    progressDestroy();
    sliderDestroy();
  };

  that._update = function (v, value, index, percent, multiple, refresh, $handleCont) {
    if (isRange) {
      if (index === 0) {
        v = Math.min(v, value[1]);
        $progress.css({
          width: getPercent(value[1], min, max) - getPercent(v, min, max) + '%',
          left: isRtl ? 'auto' : getPercent(v, min, max) + '%',
          right: isRtl ? getPercent(v, min, max) + '%' : 'auto'
        });
      } else {
        v = Math.max(v, value[0]);
        $progress.css({
          width: getPercent(v, min, max) - getPercent(value[0], min, max) + '%'
        });
      }
    } else if (multiple || !hasProgress) {
      $handleCont.css({
        left: isRtl ? 'auto' : (percent || getPercent(v, min, max)) + '%',
        right: isRtl ? (percent || getPercent(v, min, max)) + '%' : 'auto'
      });
    } else {
      $progress.css('width', (percent || getPercent(v, min, max)) + '%');
    }

    if (hasTooltip) {
      $tooltips.eq(index).html(v);
    } // Display value in the specified container(s)


    if (!multiple && (value[index] != v || refresh)) {
      that._display(v);
    } // Return validated value


    return v;
  };

  that._readValue = function ($elm) {
    return +$elm.val();
  };

  that._fillValue = function (v, index, change) {
    $elm.eq(index).val(v);

    if (change) {
      $elm.eq(index).trigger('change');
    }
  };

  that._markupReady = function () {
    var i, stepNr;

    if (hasTooltip) {
      $parent.addClass('mbsc-slider-has-tooltip');
    } // Generate step marks


    if (step != 1) {
      stepNr = (max - min) / step;

      for (i = 0; i <= stepNr; ++i) {
        $track.append('<span class="mbsc-slider-step" style="' + (isRtl ? 'right' : 'left') + ':' + 100 / stepNr * i + '%"></span>');
      }
    } // Generate slider handles


    $elm.each(function (i, elm) {
      var value = +elm.value;

      if (elm.type == 'range') {
        // Set min / max / step properties for all inputs
        $$1(elm).attr('min', min).attr('max', max).attr('step', step);
      }

      (hasProgress ? $progress : $track).append('<span class="mbsc-slider-handle-cont' + (isRange && !i ? ' mbsc-slider-handle-left' : '') + (isRange && !i && value > (max - min) / 2 ? ' mbsc-handle-curr' : '') + '">' + '<span tabindex="0" class="mbsc-slider-handle" aria-valuemin="' + min + '" aria-valuemax="' + max + '" data-index="' + i + '"></span>' + (hasTooltip ? '<span class="mbsc-slider-tooltip"></span>' : '') + '</span>');
    });
    $tooltips = $parent.find('.mbsc-slider-tooltip');
  };

  that.___init = function () {
    if ($parent) {
      $parent.removeClass('mbsc-slider-has-tooltip');

      if (step != 1) {
        $$1('.mbsc-slider-step', $track).remove();
      }
    }

    $parent = that._$parent;
    $track = that._$track;
    $progress = that._$progress;
    $elm = $parent.find('input');
    s = that.settings;
    min = that._min;
    max = that._max;
    that._step = step = settings.step === undefined ? +$elm.attr('step') || s.step : settings.step;
    that._live = getBoolAttr('data-live', s.live, $elm);
    hasTooltip = getBoolAttr('data-tooltip', s.tooltip, $elm);
    hasProgress = getBoolAttr('data-highlight', s.highlight, $elm) && $elm.length < 3;
    isRange = hasProgress && $elm.length == 2;
    isRtl = s.rtl;

    that._markupReady();
  };

  if (!inherit) {
    that.init();
  }
};
Slider.prototype = {
  _class: 'progress',
  _css: 'mbsc-progress mbsc-slider',
  _hasTheme: true,
  _hasLang: true,
  _hasDef: true,
  _defaults: {
    changeEvent: 'change',
    stopProp: true,
    min: 0,
    max: 100,
    step: 1,
    live: true,
    highlight: true,
    round: true,
    returnAffix: true
  }
};
classes.Slider = Slider; // Init mbsc-slider elements on page load

autoInit('[mbsc-slider]', Slider);

var Rating = function Rating(elm, settings, inherit) {
  var $progress,
      $track,
      max,
      min,
      empty,
      filled,
      s,
      that = this,
      $elm = $$1(elm); // Call the parent constructor

  Slider.call(this, elm, settings, true);

  that._update = function (v, value, index, percent, multiple, refresh) {
    $progress.css('width', getPercent(v, 0, max) + '%'); // Display value in the specified container(s)

    if (!multiple && (value[index] != v || refresh)) {
      that._display(v);
    } // Return validated value


    return v;
  };

  that._markupReady = function () {
    var i,
        emptyString = '',
        filledString = '';
    $track = that._$track;
    $progress = that._$progress;
    s = that.settings;
    min = that._min;
    max = that._max;
    that._base = min;
    that._rounding = s.rtl ? 'floor' : 'ceil';
    empty = $elm.attr('data-empty') || s.empty;
    filled = $elm.attr('data-filled') || s.filled;

    for (i = 0; i < max; ++i) {
      emptyString += '<span class="mbsc-ic mbsc-ic-' + empty + '"></span>';
      filledString += '<span class="mbsc-ic mbsc-ic-' + filled + '"></span>';
    }

    $track.html(emptyString);
    $track.append($progress);
    $progress.html(filledString);
    $track.append('<span class="mbsc-rating-handle-cont' + '">' + '<span tabindex="0" class="mbsc-slider-handle" aria-valuemin="' + min + '" aria-valuemax="' + max + '" data-index="0"></span>' + '</span>');
  };

  if (!inherit) {
    that.init();
  }
};
Rating.prototype = {
  _class: 'progress',
  _css: 'mbsc-progress mbsc-rating',
  _hasTheme: true,
  _hasLang: true,
  _hasDef: true,
  _defaults: {
    changeEvent: 'change',
    stopProp: true,
    min: 1,
    max: 5,
    step: 1,
    live: true,
    round: true,
    hover: true,
    highlight: true,
    returnAffix: true,
    empty: 'star',
    filled: 'star3'
  }
};
classes.Rating = Rating; // Init mbsc-rating elements on page load

autoInit('[mbsc-rating]', Rating);

var nr = 1;
var CollapsibleBase =
/*#__PURE__*/
function () {
  function CollapsibleBase(elm, settings) {
    var _this = this;

    var content;
    var $header;
    var $content;
    var $elm = $$1(elm);
    this.settings = settings;
    this._isOpen = settings.isOpen || false;
    $elm.addClass('mbsc-collapsible ' + (this._isOpen ? 'mbsc-collapsible-open' : ''));

    if ($elm.hasClass('mbsc-card')) {
      // card enhance
      $header = $elm.find('.mbsc-card-header').eq(0).addClass('mbsc-collapsible-header');
      $content = $elm.find('.mbsc-card-content').eq(0).addClass('mbsc-collapsible-content');
    } else if ($elm.hasClass('mbsc-form-group') || $elm.hasClass('mbsc-form-group-inset')) {
      // form group enhance
      $header = $elm.find('.mbsc-form-group-title').eq(0).addClass('mbsc-collapsible-header');
      $content = $elm.find('.mbsc-form-group-content').eq(0).addClass('mbsc-collapsible-content');
    } else {
      // if it is used independently
      $header = $elm.find('.mbsc-collapsible-header').eq(0);
      $content = $elm.find('.mbsc-collapsible-content').eq(0);
    }

    content = $content[0];

    if (content && !content.id) {
      content.id = 'mbsc-collapsible-' + nr++;
    }

    if ($header.length && content) {
      var $collapsibleIcon = $$1('<span class="mbsc-collapsible-icon mbsc-ic mbsc-ic-arrow-down5"></span>');
      tap(this, $header, function () {
        _this.collapse();
      });
      $header.attr('role', 'button').attr('aria-expanded', this._isOpen).attr('aria-controls', content.id).attr('tabindex', '0').on('mousedown', this.onMouseDown).on('keydown', this.onKeyDown).append($collapsibleIcon);
    }

    elm.mbscInst = this;
    this._$header = $header;
    this._$content = $content;
    this._$elm = $elm;
    this._$accordionParent = $elm.parent('[mbsc-accordion], mbsc-accordion, .mbsc-accordion');
    this.show = this.show.bind(this);
    this.hide = this.hide.bind(this);
    this.toggle = this.toggle.bind(this);
    this.onKeyDown = this.onKeyDown.bind(this);
    this.onMouseDown = this.onMouseDown.bind(this);
  }

  var _proto = CollapsibleBase.prototype;

  _proto.collapse = function collapse(show) {
    var $elm = this._$elm;
    var $content = this._$content;

    var removeHeight = function removeHeight() {
      $content.off('transitionend', removeHeight).css('height', '');
    };

    if (show === undefined) {
      show = !this._isOpen;
    }

    if (show && this._isOpen || !show && !this._isOpen || !$content.length) {
      return;
    }

    if (show) {
      if (hasTransition) {
        $content.on('transitionend', removeHeight).css('height', $content[0].scrollHeight);
      }

      $elm.addClass('mbsc-collapsible-open');
    } else {
      if (hasTransition) {
        $content.css('height', getComputedStyle($content[0]).height);
      }

      setTimeout(function () {
        $content.css('height', 0);
        $elm.removeClass('mbsc-collapsible-open');
      }, 50);
    }

    if (show && this._$accordionParent) {
      this._$accordionParent.find('.mbsc-collapsible-open').each(function () {
        if (this !== $elm[0]) {
          this.mbscInst.hide();
        }
      });
    }

    this._isOpen = show;

    this._$header.attr('aria-expanded', this._isOpen);
  };

  _proto.show = function show() {
    this.collapse(true);
  };

  _proto.hide = function hide() {
    this.collapse(false);
  };

  _proto.toggle = function toggle() {
    this.collapse();
  };

  _proto.destroy = function destroy() {
    this._$elm.removeClass('mbsc-collapsible mbsc-collapsible-open');

    this._$content.removeClass('mbsc-collapsible-content');

    this._$header.removeClass('mbsc-collapsible-header').off('mousedown', this.onMouseDown).off('keydown', this.onKeyDown).find('.mbsc-collapsible-icon').remove();

    tapOff(this._$header);
  };

  _proto.onKeyDown = function onKeyDown(ev) {
    if (ev.which === 32 || ev.keyCode == 13) {
      //space or enter 
      ev.preventDefault();
      this.collapse();
    }
  };

  _proto.onMouseDown = function onMouseDown(ev) {
    // prevent focus on mouse down
    ev.preventDefault();
  };

  return CollapsibleBase;
}();
classes.CollapsibleBase = CollapsibleBase;

var id$1 = 0;

function initControls($ctx, controls, s, shallow) {
  $$1('input,select,textarea,progress,button', $ctx).each(function () {
    var control = this,
        $control = $$1(control),
        //$parent = $control.parent(),
    type = getControlType($control); // Skip elements with data-enhance="false"

    if ($control.attr('data-enhance') != 'false'
    /* TRIALCOND */
    ) {
        if ($control.hasClass('mbsc-control')) {
          if (control.mbscInst) {
            control.mbscInst.option({
              theme: s.theme,
              lang: s.lang,
              rtl: s.rtl,
              onText: s.onText,
              offText: s.offText,
              stopProp: s.stopProp
            });
          }
        } else {
          if (!control.id) {
            control.id = 'mbsc-form-control-' + ++id$1;
          }

          switch (type) {
            case 'button':
            case 'submit':
              controls[control.id] = new Button(control, {
                theme: s.theme,
                rtl: s.rtl,
                tap: s.tap
              });
              break;

            case 'switch':
              controls[control.id] = new Switch(control, {
                theme: s.theme,
                lang: s.lang,
                rtl: s.rtl,
                tap: s.tap,
                onText: s.onText,
                offText: s.offText,
                stopProp: s.stopProp
              });
              break;

            case 'checkbox':
              controls[control.id] = new CheckBox(control, {
                tap: s.tap,
                theme: s.theme,
                rtl: s.rtl
              });
              break;

            case 'range':
              if (!$$1(control).parent().hasClass('mbsc-slider')) {
                controls[control.id] = new Slider(control, {
                  theme: s.theme,
                  lang: s.lang,
                  rtl: s.rtl,
                  stopProp: s.stopProp,
                  labelStyle: s.labelStyle
                });
              }

              break;

            case 'rating':
              controls[control.id] = new Rating(control, {
                theme: s.theme,
                lang: s.lang,
                rtl: s.rtl,
                stopProp: s.stopProp
              });
              break;

            case 'progress':
              controls[control.id] = new Progress(control, {
                theme: s.theme,
                lang: s.lang,
                rtl: s.rtl,
                labelStyle: s.labelStyle
              });
              break;

            case 'radio':
              controls[control.id] = new Radio(control, {
                tap: s.tap,
                theme: s.theme,
                rtl: s.rtl
              });
              break;

            case 'select':
            case 'select-one':
            case 'select-multiple':
              controls[control.id] = new Select(control, {
                tap: s.tap,
                inputStyle: s.inputStyle,
                labelStyle: s.labelStyle,
                theme: s.theme,
                rtl: s.rtl
              });
              break;

            case 'textarea':
              controls[control.id] = new TextArea(control, {
                tap: s.tap,
                inputStyle: s.inputStyle,
                labelStyle: s.labelStyle,
                theme: s.theme,
                rtl: s.rtl
              });
              break;

            case 'segmented':
              controls[control.id] = new SegmentedItem(control, {
                theme: s.theme,
                rtl: s.rtl,
                tap: s.tap,
                inputStyle: s.inputStyle
              });
              break;

            case 'stepper':
              controls[control.id] = new Stepper(control, {
                theme: s.theme,
                rtl: s.rtl
              });
              break;

            case 'hidden':
              return;

            default:
              controls[control.id] = new Input(control, {
                tap: s.tap,
                inputStyle: s.inputStyle,
                labelStyle: s.labelStyle,
                theme: s.theme,
                rtl: s.rtl
              });
              break;
          }
        }
      }
  });
  $$1('[data-collapsible]:not(.mbsc-collapsible)', $ctx).each(function () {
    var control = this,
        $control = $$1(control),
        isOpen = $control.attr('data-open');

    if (!control.id) {
      control.id = 'mbsc-form-control-' + ++id$1;
    }

    controls[control.id] = new CollapsibleBase(control, {
      isOpen: isOpen !== undefined && isOpen != 'false'
    });
    instances[control.id] = controls[control.id];
  }); // Set initial height for textareas

  if (!shallow) {
    sizeTextAreas();
  }
}

var innerStyle = 'position:absolute;left:0;top:0;';
var style = innerStyle + 'right:0;bottom:0;overflow:hidden;z-index:-1;';
var markup = '<div style="' + style + '"><div style="' + innerStyle + '"></div></div>' + '<div style="' + style + '"><div style="' + innerStyle + 'width:200%;height:200%;"></div></div>';
var observer;
var count = 0;
function resizeObserver(el, callback, zone) {
  function reset() {
    expandChild.style.width = '100000px';
    expandChild.style.height = '100000px';
    expand.scrollLeft = 100000;
    expand.scrollTop = 100000;
    shrink.scrollLeft = 100000;
    shrink.scrollTop = 100000;
  }

  function checkHidden() {
    var now = new Date();
    hiddenRafId = 0;

    if (!stopCheck) {
      if (now - lastCheck > 200 && !expand.scrollTop && !expand.scrollLeft) {
        lastCheck = now;
        reset();
      }

      if (!hiddenRafId) {
        hiddenRafId = raf(checkHidden);
      }
    }
  }

  function onScroll() {
    if (!rafId) {
      rafId = raf(onResize);
    }
  }

  function onResize() {
    rafId = 0;
    reset();
    callback();
  }

  var expand;
  var expandChild;
  var helper;
  var hiddenRafId;
  var rafId;
  var shrink;
  var stopCheck;
  var lastCheck = 0; //let isHidden = true;

  if (window.ResizeObserver) {
    if (!observer) {
      observer = new ResizeObserver(function (entries) {
        for (var _iterator = entries, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref = _i.value;
          }

          var entry = _ref;

          entry.target.__mbscResize();
        }
      });
    }

    count++;
    el.__mbscResize = callback;
    observer.observe(el);
  } else {
    helper = document.createElement('div');
    helper.innerHTML = markup;
    helper.dir = 'ltr'; // Need this to work in rtl as well;

    shrink = helper.childNodes[1];
    expand = helper.childNodes[0];
    expandChild = expand.childNodes[0];
    el.appendChild(helper);
    expand.addEventListener('scroll', onScroll);
    shrink.addEventListener('scroll', onScroll);

    if (zone) {
      zone.runOutsideAngular(function () {
        raf(checkHidden);
      });
    } else {
      raf(checkHidden);
    }
  }

  return {
    detach: function detach() {
      if (observer) {
        count--;
        observer.unobserve(el);

        if (!count) {
          observer = null;
        }
      } else {
        el.removeChild(helper);
        stopCheck = true;
      }
    }
  };
}

var $activeElm,
    preventShow,
    themes = mobiscroll.themes,
    needsFixed = /(iphone|ipod)/i.test(userAgent) && majorVersion >= 7,
    isAndroid = os == 'android',
    isIOS = os == 'ios',
    isIOS8 = isIOS && majorVersion == 8,
    halfBorder = isIOS && majorVersion > 7,
    prevdef = function prevdef(ev) {
  ev.preventDefault();
};

var EDITABLE = 'input,select,textarea,button';
var ALLOW_ENTER = 'textarea,button,input[type="button"],input[type="submit"]';
var FOCUSABLE = EDITABLE + ',[tabindex="0"]';
var Frame = function Frame(el, settings, inherit) {
  var //$ariaDiv,
  $ctx,
      $header,
      $lock,
      $markup,
      $overlay,
      $persp,
      $popup,
      $wnd,
      $wrapper,
      buttons,
      btn,
      ctx,
      doAnim,
      hasContext,
      isModal,
      isInserted,
      isPointer,
      markup,
      modalWidth,
      modalHeight,
      needsDimensions,
      needsLock,
      observer,
      overlay,
      popup,
      posDebounce,
      prevInst,
      s,
      scrollLock,
      touched,
      trigger,
      wndWidth,
      wndHeight,
      that = this,
      $elm = $$1(el),
      elmList = [],
      lastFocus = new Date();

  function onBtnStart(ev) {
    // Need this to prevent opening of sidemenus or similar
    if (s.stopProp) {
      ev.stopPropagation();
    }

    var b = closest(this, ev.target, '.mbsc-fr-btn-e');

    if (!b) {
      return;
    } // Can't call preventDefault here, it kills page scroll


    if (btn) {
      btn.removeClass('mbsc-active');
    }

    btn = $$1(b); // Active button

    if (!btn.hasClass('mbsc-disabled') && !btn.hasClass('mbsc-fr-btn-nhl')) {
      btn.addClass('mbsc-active');
    }

    if (ev.type === 'mousedown') {
      $$1(document).on('mouseup', onBtnEnd);
    }
  }

  function onBtnEnd(ev) {
    if (btn) {
      btn.removeClass('mbsc-active');
      btn = null;
    }

    if (ev.type === 'mouseup') {
      $$1(document).off('mouseup', onBtnEnd);
    }
  }

  function onScroll(ev) {
    if (scrollLock && markup.contains(ev.target)) {
      ev.preventDefault();
    }
  }

  function onWndKeyDown(ev) {
    if (mobiscroll.activeInstance == that) {
      if (ev.keyCode == 13 && (!$$1(ev.target).is(ALLOW_ENTER) || ev.shiftKey)) {
        that.select();
      } else if (ev.keyCode == 27) {
        that.cancel();
      }
    }
  }

  function onShow(prevFocus) {
    if (!prevFocus && !isAndroid && that._activeElm) {
      //overlay.focus();
      lastFocus = new Date();

      that._activeElm.focus();
    } //that.ariaMessage(s.ariaMessage);

  }

  function onHide(prevAnim) {
    var $activeEl = $activeElm,
        focus = s.focusOnClose;

    that._markupRemove();

    $markup.remove();

    if (isModal) {
      ctx.mbscModals--;

      if (s.scrollLock) {
        ctx.mbscLock--;
      }

      if (!ctx.mbscLock) {
        $lock.removeClass('mbsc-fr-lock');
      }

      if (needsLock) {
        ctx.mbscIOSLock--;

        if (!ctx.mbscIOSLock) {
          $lock.removeClass('mbsc-fr-lock-ios');
          $ctx.css({
            top: '',
            left: ''
          });
          $wnd.scrollLeft(ctx.mbscScrollLeft);
          $wnd.scrollTop(ctx.mbscScrollTop);
        }
      } // The follwing should be done only if no other
      // instance was opened during the hide animation


      if (!ctx.mbscModals) {
        $lock.removeClass('mbsc-fr-lock-ctx');
      }

      if (!ctx.mbscModals || prevInst) {
        // Put focus back to the last active element
        if (!prevAnim) {
          if (!$activeEl) {
            $activeEl = $elm;
          }

          setTimeout(function () {
            if (focus === undefined || focus === true) {
              preventShow = true;
              $activeEl[0].focus();
            } else if (focus) {
              $$1(focus)[0].focus();
            }
          }, 200);
        }
      }
    }

    prevInst = undefined;
    isInserted = false;
    trigger('onHide');
  }

  function onPosition() {
    clearTimeout(posDebounce);
    posDebounce = setTimeout(function () {
      if (that.position(true)) {
        // Trigger reflow, needed on iOS safari, when orientation is changed
        popup.style.visibility = 'hidden';
        popup.offsetHeight;
        popup.style.visibility = '';
      }
    }, 200);
  }

  function onFocus(ev) {
    if (mobiscroll.activeInstance == that && ev.target.nodeType && !overlay.contains(ev.target) && new Date() - lastFocus > 100) {
      lastFocus = new Date();

      that._activeElm.focus();
    }
  }

  function insertMarkup(prevAnim, prevFocus) {
    function onAnimEnd() {
      $markup.off(animEnd, onAnimEnd).removeClass('mbsc-anim-in mbsc-anim-trans mbsc-anim-trans-' + doAnim).find('.mbsc-fr-popup').removeClass('mbsc-anim-' + doAnim);
      onShow(prevFocus);
    }

    function onOverlayStart(ev) {
      if (!target && ev.target == overlay) {
        target = true;
        moved = false;
        startX = getCoord(ev, 'X');
        startY = getCoord(ev, 'Y');
      }
    }

    function onOverlayMove(ev) {
      if (target && !moved && (Math.abs(getCoord(ev, 'X') - startX) > 9 || Math.abs(getCoord(ev, 'Y') - startY) > 9)) {
        moved = true;
      }
    } // Might be not visible if immediately hidden


    if (!that._isVisible) {
      return;
    } // Show


    if (isModal) {
      $markup.appendTo($ctx);
    } else if ($elm.is('div') && !that._hasContent) {
      // Insert inside the element on which was initialized
      $elm.empty().append($markup);
    } else {
      // Insert after the element
      if ($elm.hasClass('mbsc-control')) {
        var $wrap = $elm.closest('.mbsc-control-w');
        $markup.insertAfter($wrap);

        if ($wrap.hasClass('mbsc-select')) {
          $wrap.addClass('mbsc-select-inline');
        }
      } else {
        $markup.insertAfter($elm);
      }
    }

    isInserted = true;

    that._markupInserted($markup);

    trigger('onMarkupInserted', {
      target: markup
    });

    if (isModal && s.closeOnOverlayTap) {
      var moved, target, startX, startY;
      listen(overlay, 'touchstart', onOverlayStart, {
        passive: true
      });
      listen(overlay, 'touchmove', onOverlayMove, {
        passive: true
      });
      $overlay.on('mousedown', onOverlayStart).on('mousemove', onOverlayMove).on('touchcancel', function () {
        target = false;
      }).on('touchend click', function (ev) {
        if (target && !moved) {
          that.cancel();

          if (ev.type == 'touchend') {
            preventClick();
          }
        }

        target = false;
      });
    }

    $markup.on('mousedown', '.mbsc-btn-e,.mbsc-fr-btn-e', prevdef).on('keydown', '.mbsc-fr-btn-e', function (ev) {
      if (ev.keyCode == 32) {
        // Space
        ev.preventDefault();
        ev.stopPropagation();
        this.click();
      }
    }).on('keydown', function (ev) {
      // Trap focus inside modal
      if (ev.keyCode == 32 && !$$1(ev.target).is(EDITABLE)) {
        // Prevent page scroll on space press
        ev.preventDefault();
      } else if (ev.keyCode == 9 && isModal && s.focusTrap) {
        // Tab
        var $focusable = $markup.find(FOCUSABLE).filter(function () {
          return this.offsetWidth > 0 || this.offsetHeight > 0;
        }),
            index = $focusable.index($$1(':focus', $markup)),
            i = $focusable.length - 1,
            target = 0;

        if (ev.shiftKey) {
          i = 0;
          target = -1;
        }

        if (index === i) {
          $focusable.eq(target)[0].focus();
          ev.preventDefault();
        }
      }
    }).on('touchend', '.mbsc-fr-btn-e', onBtnEnd);
    listen(markup, 'touchstart', onBtnStart, {
      passive: true
    });
    listen(markup, 'mousedown', onBtnStart); // Need event capture for this

    listen(markup, 'touchstart', function () {
      if (!touched) {
        touched = true;
        $ctx.find('.mbsc-no-touch').removeClass('mbsc-no-touch');
      }
    }, {
      passive: true,
      capture: true
    }); // Init buttons

    $$1.each(buttons, function (i, b) {
      that.tap($$1('.mbsc-fr-btn' + i, $markup), function (ev) {
        b = isString(b) ? that.buttons[b] : b;
        (isString(b.handler) ? that.handlers[b.handler] : b.handler).call(this, ev, that);
      }, true);
    });

    that._attachEvents($markup); // Set position


    if (that.position() === false) {
      return;
    }

    if (isModal || that._checkSize) {
      observer = resizeObserver(markup, onPosition, s.zone);
    }

    if (isModal) {
      $markup.removeClass('mbsc-fr-pos');

      if (doAnim && !prevAnim) {
        $markup.addClass('mbsc-anim-in mbsc-anim-trans mbsc-anim-trans-' + doAnim).on(animEnd, onAnimEnd).find('.mbsc-fr-popup').addClass('mbsc-anim-' + doAnim);
      } else {
        onShow(prevFocus);
      }
    }

    trigger('onShow', {
      target: markup,
      valueText: that._tempValue
    });
  }

  function show(beforeShow, $elm) {
    if (that._isVisible) {
      return;
    }

    if (beforeShow) {
      beforeShow();
    }

    if (that.show() !== false) {
      $activeElm = $elm;
    }
  }

  function set() {
    that._fillValue();

    trigger('onSet', {
      valueText: that._value
    });
  }

  function cancel() {
    trigger('onCancel', {
      valueText: that._value
    });
  }

  function clear() {
    that.setVal(null, true);
  } // Call the parent constructor


  Base.call(this, el, settings, true);
  /**
   * Positions the scroller on the screen.
   */

  that.position = function (check) {
    var anchor,
        anchorWidth,
        anchorHeight,
        anchorPos,
        anchorTop,
        anchorLeft,
        arrow,
        arrowWidth,
        arrowHeight,
        docHeight,
        docWidth,
        isWrapped,
        newHeight,
        newWidth,
        oldHeight,
        oldWidth,
        width,
        top,
        left,
        css = {},
        scrollLeft = 0,
        scrollTop = 0,
        minWidth = 0,
        totalWidth = 0;

    if (!isInserted) {
      return false;
    }

    oldWidth = wndWidth;
    oldHeight = wndHeight;
    newHeight = Math.min(markup.offsetHeight, hasContext ? Infinity : window.innerHeight);
    newWidth = Math.min(markup.offsetWidth, hasContext ? Infinity : window.innerWidth);

    if (!newWidth || !newHeight || wndWidth === newWidth && wndHeight === newHeight && check) {
      return;
    }

    if (that._checkResp(newWidth)) {
      return false;
    }

    wndWidth = newWidth;
    wndHeight = newHeight;

    if (that._isFullScreen || /top|bottom/.test(s.display)) {
      // Set width, if document is larger than viewport, needs to be set before onPosition (for calendar)
      $popup.width(newWidth);
    } else if (isModal) {
      // Reset width
      $wrapper.width('');
    }

    that._position($markup); // Call position for nested mobiscroll components
    // $('.mbsc-comp', $markup).each(function () {
    //     var inst = instances[this.id];
    //     if (inst && inst !== that && inst.position) {
    //         inst.position();
    //     }
    // });


    if (!that._isFullScreen && /center|bubble/.test(s.display)) {
      $$1('.mbsc-w-p', $markup).each(function () {
        // Need fractional values here, so offsetWidth is not ok
        width = this.getBoundingClientRect().width;
        totalWidth += width;
        minWidth = width > minWidth ? width : minWidth;
      });
      isWrapped = totalWidth > newWidth - 16 || s.tabs === true;
      $wrapper.css({
        'width': that._isLiquid ? Math.min(s.maxPopupWidth, newWidth - 16) : Math.ceil(isWrapped ? minWidth : totalWidth),
        'white-space': isWrapped ? '' : 'nowrap'
      });
    }

    if (trigger('onPosition', {
      target: markup,
      popup: popup,
      hasTabs: isWrapped,
      oldWidth: oldWidth,
      oldHeight: oldHeight,
      windowWidth: newWidth,
      windowHeight: newHeight
    }) === false || !isModal) {
      return;
    }

    if (needsDimensions) {
      scrollLeft = $wnd.scrollLeft();
      scrollTop = $wnd.scrollTop();

      if (wndWidth) {
        $persp.css({
          width: '',
          height: ''
        });
      }
    }

    modalWidth = popup.offsetWidth;
    modalHeight = popup.offsetHeight;
    scrollLock = modalHeight <= newHeight && modalWidth <= newWidth;

    if (s.display == 'center') {
      left = Math.max(0, scrollLeft + (newWidth - modalWidth) / 2);
      top = Math.max(0, scrollTop + (newHeight - modalHeight) / 2);
    } else if (s.display == 'bubble') {
      anchor = s.anchor === undefined ? $elm : $$1(s.anchor);
      arrow = $$1('.mbsc-fr-arr-i', $markup)[0];
      anchorPos = anchor.offset();
      anchorTop = anchorPos.top + (hasContext ? scrollTop - $ctx.offset().top : 0);
      anchorLeft = anchorPos.left + (hasContext ? scrollLeft - $ctx.offset().left : 0);
      anchorWidth = anchor[0].offsetWidth;
      anchorHeight = anchor[0].offsetHeight;
      arrowWidth = arrow.offsetWidth;
      arrowHeight = arrow.offsetHeight; // Horizontal positioning

      left = constrain(anchorLeft - (modalWidth - anchorWidth) / 2, scrollLeft + 3, scrollLeft + newWidth - modalWidth - 3); // Vertical positioning
      // Below the input

      top = anchorTop + anchorHeight + arrowHeight / 2;

      if (top + modalHeight + 8 > scrollTop + newHeight && anchorTop - modalHeight - arrowHeight / 2 > scrollTop) {
        $popup.removeClass('mbsc-fr-bubble-bottom').addClass('mbsc-fr-bubble-top'); // Above the input

        top = anchorTop - modalHeight - arrowHeight / 2;
      } else {
        $popup.removeClass('mbsc-fr-bubble-top').addClass('mbsc-fr-bubble-bottom');
      } // Set arrow position


      $$1('.mbsc-fr-arr', $markup).css({
        left: constrain(anchorLeft + anchorWidth / 2 - (left + (modalWidth - arrowWidth) / 2), 0, arrowWidth)
      }); // Lock scroll only if popup is entirely in the viewport

      scrollLock = top > scrollTop && left > scrollLeft && top + modalHeight <= scrollTop + newHeight && left + modalWidth <= scrollLeft + newWidth;
    } else {
      left = scrollLeft;
      top = s.display == 'top' ? scrollTop : Math.max(0, scrollTop + newHeight - modalHeight);
    }

    if (needsDimensions) {
      // If top + modal height > doc height, increase doc height
      docHeight = Math.max(top + modalHeight, hasContext ? ctx.scrollHeight : $$1(document).height());
      docWidth = Math.max(left + modalWidth, hasContext ? ctx.scrollWidth : $$1(document).width());
      $persp.css({
        width: docWidth,
        height: docHeight
      }); // Check if scroll needed

      if (s.scroll && s.display == 'bubble' && (top + modalHeight + 8 > scrollTop + newHeight || anchorTop > scrollTop + newHeight || anchorTop + anchorHeight < scrollTop)) {
        $wnd.scrollTop(Math.min(anchorTop, top + modalHeight - newHeight + 8, docHeight - newHeight));
      }
    }

    css.top = Math.floor(top);
    css.left = Math.floor(left);
    $popup.css(css);
    return true;
  };
  /**
   * Show mobiscroll on focus and click event of the parameter.
   * @param {HTMLElement} elm - Events will be attached to this element.
   * @param {Function} [beforeShow=undefined] - Optional function to execute before showing mobiscroll.
   */


  that.attachShow = function (elm, beforeShow) {
    var $label,
        $elm = $$1(elm).off('.mbsc'),
        readOnly = $elm.prop('readonly');
    tapOff($elm);

    if (s.display !== 'inline') {
      if ((s.showOnFocus || s.showOnTap) && $elm.is('input,select')) {
        $elm.prop('readonly', true).on('mousedown.mbsc', function (ev) {
          // Prevent input to get focus on tap (virtual keyboard pops up on some devices)
          ev.preventDefault();
        }).on('focus.mbsc', function () {
          if (that._isVisible) {
            // Don't allow input focus if mobiscroll is being opened
            this.blur();
          }
        });
        $label = $$1('label[for="' + $elm.attr('id') + '"]');

        if (!$label.length) {
          $label = $elm.closest('label');
        }
      }

      if (!$elm.is('select')) {
        if (s.showOnFocus) {
          $elm.on('focus.mbsc', function () {
            if (!preventShow) {
              show(beforeShow, $elm);
            } else {
              preventShow = false;
            }
          });
        }

        if (s.showOnTap) {
          $elm.on('keydown.mbsc', function (ev) {
            if (ev.keyCode == 32 || ev.keyCode == 13) {
              // Space or Enter
              ev.preventDefault();
              ev.stopPropagation();
              show(beforeShow, $elm);
            }
          });
          that.tap($elm, function (ev) {
            if (ev.isMbscTap) {
              touched = true;
            }

            show(beforeShow, $elm);
          });

          if ($label && $label.length) {
            tapOff($label);
            that.tap($label, function (ev) {
              ev.preventDefault();

              if (ev.target !== $elm[0]) {
                show(beforeShow, $elm);
              }
            });
          }
        }
      }

      elmList.push({
        readOnly: readOnly,
        el: $elm,
        lbl: $label
      });
    }
  };
  /**
   * Set button handler.
   */


  that.select = function () {
    if (isModal) {
      that.hide(false, 'set', false, set);
    } else {
      set();
    }
  };
  /**
   * Cancel and hide the scroller instance.
   */


  that.cancel = function () {
    if (isModal) {
      that.hide(false, 'cancel', false, cancel);
    } else {
      cancel();
    }
  };
  /**
   * Clear button handler.
   */


  that.clear = function () {
    that._clearValue();

    trigger('onClear');

    if (isModal && that._isVisible && !that.live) {
      that.hide(false, 'clear', false, clear);
    } else {
      clear();
    }
  };
  /**
   * Enables the scroller and the associated input.
   */


  that.enable = function () {
    s.disabled = false;
    $$1.each(elmList, function (i, v) {
      if (v.el.is('input,select')) {
        v.el[0].disabled = false;
      }
    });
  };
  /**
   * Disables the scroller and the associated input.
   */


  that.disable = function () {
    s.disabled = true;
    $$1.each(elmList, function (i, v) {
      if (v.el.is('input,select')) {
        v.el[0].disabled = true;
      }
    });
  };
  /**
   * Shows the scroller instance.
   * @param {Boolean} prevAnim - Prevent animation if true
   * @param {Boolean} prevFocus - Prevent focusing if true
   */


  that.show = function (prevAnim, prevFocus) {
    var hasButtons, html, scrollLeft, scrollTop;

    if (s.disabled || that._isVisible) {
      return;
    } // Parse value from input


    that._readValue();

    if (trigger('onBeforeShow') === false) {
      return false;
    }

    $activeElm = null;
    doAnim = s.animate;
    buttons = s.buttons || [];
    needsDimensions = hasContext || s.display == 'bubble';
    needsLock = needsFixed && !needsDimensions && s.scrollLock;
    hasButtons = buttons.length > 0; //touched = false;

    if (doAnim !== false) {
      if (s.display == 'top') {
        doAnim = doAnim || 'slidedown';
      } else if (s.display == 'bottom') {
        doAnim = doAnim || 'slideup';
      } else if (s.display == 'center' || s.display == 'bubble') {
        doAnim = doAnim || 'pop';
      }
    }

    if (isModal) {
      wndWidth = 0;
      wndHeight = 0;

      if (needsLock && !$lock.hasClass('mbsc-fr-lock-ios')) {
        //$lock.scrollTop(0);
        ctx.mbscScrollTop = scrollTop = Math.max(0, $wnd.scrollTop());
        ctx.mbscScrollLeft = scrollLeft = Math.max(0, $wnd.scrollLeft());
        $ctx.css({
          top: -scrollTop + 'px',
          left: -scrollLeft + 'px'
        });
      }

      $lock.addClass((s.scrollLock ? 'mbsc-fr-lock' : '') + (needsLock ? ' mbsc-fr-lock-ios' : '') + (hasContext ? ' mbsc-fr-lock-ctx' : '')); // Hide virtual keyboard

      if ($$1(document.activeElement).is('input,textarea')) {
        document.activeElement.blur();
      } // Save active instance to previous


      prevInst = mobiscroll.activeInstance; // Set active instance

      mobiscroll.activeInstance = that; // Keep track of modals opened per context

      ctx.mbscModals = (ctx.mbscModals || 0) + 1;

      if (needsLock) {
        ctx.mbscIOSLock = (ctx.mbscIOSLock || 0) + 1;
      }

      if (s.scrollLock) {
        ctx.mbscLock = (ctx.mbscLock || 0) + 1;
      }
    } // Create wheels containers


    html = '<div lang="' + s.lang + '" class="mbsc-fr mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : '') + ' mbsc-fr-' + s.display + ' ' + (s.cssClass || '') + ' ' + (s.compClass || '') + (that._isLiquid ? ' mbsc-fr-liq' : '') + (isModal ? ' mbsc-fr-pos' + (s.showOverlay ? '' : ' mbsc-fr-no-overlay') : '') + (isPointer ? ' mbsc-fr-pointer' : '') + (halfBorder ? ' mbsc-fr-hb' : '') + (touched ? '' : ' mbsc-no-touch') + (needsLock ? ' mbsc-platform-ios' : '') + (hasButtons ? buttons.length >= 3 ? ' mbsc-fr-btn-block ' : '' : ' mbsc-fr-nobtn') + '">' + (isModal ? '<div class="mbsc-fr-persp">' + (s.showOverlay ? '<div class="mbsc-fr-overlay"></div>' : '') + // Overlay
    '<div role="dialog" class="mbsc-fr-scroll">' : '') + '<div class="mbsc-fr-popup' + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr') + (s.headerText ? ' mbsc-fr-has-hdr' : '') + '">' + ( // Popup
    s.display === 'bubble' ? '<div class="mbsc-fr-arr-w"><div class="mbsc-fr-arr-i"><div class="mbsc-fr-arr"></div></div></div>' : '') + ( // Bubble arrow
    isModal ? '<div class="mbsc-fr-focus" tabindex="-1"></div>' : '') + '<div class="mbsc-fr-w">' + ( // Popup content
    //'<div aria-live="assertive" class="mbsc-fr-aria mbsc-fr-hdn"></div>' +
    s.headerText ? '<div class="mbsc-fr-hdr">' + (isString(s.headerText) ? s.headerText : '') + '</div>' : '') + // Header
    '<div class="mbsc-fr-c">'; // Wheel group container

    html += that._generateContent();
    html += '</div>';

    if (hasButtons) {
      var b,
          i,
          j,
          l = buttons.length;
      html += '<div class="mbsc-fr-btn-cont">';

      for (i = 0; i < buttons.length; i++) {
        j = s.btnReverse ? l - i - 1 : i;
        b = buttons[j];
        b = isString(b) ? that.buttons[b] : b;

        if (b.handler === 'set') {
          b.parentClass = 'mbsc-fr-btn-s';
        }

        if (b.handler === 'cancel') {
          b.parentClass = 'mbsc-fr-btn-c';
        }

        html += '<div' + (s.btnWidth ? ' style="width:' + 100 / buttons.length + '%"' : '') + ' class="mbsc-fr-btn-w ' + (b.parentClass || '') + '">' + '<div tabindex="0" role="button" class="mbsc-fr-btn' + j + ' mbsc-fr-btn-e ' + (b.cssClass === undefined ? s.btnClass : b.cssClass) + (b.icon ? ' mbsc-ic mbsc-ic-' + b.icon : '') + '">' + (b.text || '') + '</div></div>';
      }

      html += '</div>';
    }

    html += '</div></div></div></div>' + (isModal ? '</div></div>' : '');
    $markup = $$1(html);
    $persp = $$1('.mbsc-fr-persp', $markup);
    $overlay = $$1('.mbsc-fr-scroll', $markup);
    $wrapper = $$1('.mbsc-fr-w', $markup);
    $popup = $$1('.mbsc-fr-popup', $markup);
    $header = $$1('.mbsc-fr-hdr', $markup); //$ariaDiv = $('.mbsc-fr-aria', $markup);

    markup = $markup[0];
    overlay = $overlay[0];
    popup = $popup[0];
    that._activeElm = $$1('.mbsc-fr-focus', $markup)[0];
    that._markup = $markup;
    that._isVisible = true;
    that.markup = markup;

    that._markupReady($markup);

    trigger('onMarkupReady', {
      target: markup
    }); // Attach events

    if (isModal) {
      // Enter / ESC
      $$1(window).on('keydown', onWndKeyDown); // Prevent scroll if not specified otherwise

      if (s.scrollLock) {
        listen(document, 'touchmove', onScroll, {
          passive: false
        });
        listen(document, 'mousewheel', onScroll, {
          passive: false
        });
        listen(document, 'wheel', onScroll, {
          passive: false
        });
      }

      if (s.focusTrap) {
        $wnd.on('focusin', onFocus);
      }
    }

    if (isModal) {
      // Wait for the toolbar and addressbar to appear on iOS
      setTimeout(function () {
        insertMarkup(prevAnim, prevFocus);
      }, needsLock ? 100 : 0);
    } else {
      insertMarkup(prevAnim, prevFocus);
    }
  };
  /**
   * Hides the scroller instance.
   */


  that.hide = function (prevAnim, btn, force, callback) {
    function onAnimEnd() {
      $markup.off(animEnd, onAnimEnd);
      onHide(prevAnim);
    } // If onClose handler returns false, prevent hide


    if (!that._isVisible || !force && !that._isValid && btn == 'set' || !force && trigger('onBeforeClose', {
      valueText: that._tempValue,
      button: btn
    }) === false) {
      return false;
    }

    that._isVisible = false;

    if (observer) {
      observer.detach();
      observer = null;
    }

    if (isModal) {
      if ($$1(document.activeElement).is('input,textarea') && popup.contains(document.activeElement)) {
        document.activeElement.blur();
      }

      if (mobiscroll.activeInstance == that) {
        mobiscroll.activeInstance = prevInst;
      }

      $$1(window).off('keydown', onWndKeyDown);
      $wnd.off('focusin', onFocus);
      unlisten(document, 'touchmove', onScroll, {
        passive: false
      });
      unlisten(document, 'mousewheel', onScroll, {
        passive: false
      });
      unlisten(document, 'wheel', onScroll, {
        passive: false
      });
    } // Hide wheels and overlay


    if ($markup) {
      if (isModal && isInserted && doAnim && !prevAnim) {
        $markup.addClass('mbsc-anim-out mbsc-anim-trans mbsc-anim-trans-' + doAnim).on(animEnd, onAnimEnd).find('.mbsc-fr-popup').addClass('mbsc-anim-' + doAnim);
      } else {
        onHide(prevAnim);
      }

      that._detachEvents($markup);
    }

    if (callback) {
      callback();
    } // For validation


    $elm.trigger('blur');
    trigger('onClose', {
      valueText: that._value
    });
  }; // that.ariaMessage = function (txt) {
  //     $ariaDiv.html('');
  //     setTimeout(function () {
  //         $ariaDiv.html(txt);
  //     }, 100);
  // };

  /**
   * Return true if the scroller is currently visible.
   */


  that.isVisible = function () {
    return that._isVisible;
  }; // Protected functions to override


  that.setVal = noop;
  that.getVal = noop;
  that._generateContent = noop;
  that._attachEvents = noop;
  that._detachEvents = noop;
  that._readValue = noop;
  that._clearValue = noop;
  that._fillValue = noop;
  that._markupReady = noop;
  that._markupInserted = noop;
  that._markupRemove = noop;
  that._position = noop;
  that.__processSettings = noop;
  that.__init = noop;
  that.__destroy = noop; // Generic frame functions

  /**
   * Destroys the mobiscroll instance.
   */

  that._destroy = function () {
    // Force hide without animation
    that.hide(true, false, true);
    $elm.off('.mbsc');
    tapOff($elm); // Remove all events from elements

    $$1.each(elmList, function (i, v) {
      v.el.off('.mbsc').prop('readonly', v.readOnly);
      tapOff(v.el);

      if (v.lbl) {
        v.lbl.off('.mbsc');
        tapOff(v.lbl);
      }
    });

    that.__destroy();
  };

  that._updateHeader = function () {
    var t = s.headerText,
        txt = t ? typeof t === 'function' ? t.call(el, that._tempValue) : t.replace(/\{value\}/i, that._tempValue) : '';
    $header.html(txt || '&nbsp;');
  };

  that._getRespCont = function () {
    hasContext = s.context != 'body';
    $wnd = $$1(hasContext ? s.context : window);
    return s.display == 'inline' ? $elm.is('div') ? $elm : $elm.parent() : $wnd;
  };

  that._processSettings = function (resp) {
    var b, i;

    that.__processSettings(resp);

    isPointer = !s.touchUi;

    if (isPointer) {
      s.display = resp.display || settings.display || 'bubble';
      s.buttons = resp.buttons || settings.buttons || [];
      s.showOverlay = resp.showOverlay || settings.showOverlay || false;
    } // Add default buttons


    s.buttons = s.buttons || (s.display !== 'inline' ? ['cancel', 'set'] : []); // Hide header text in inline mode by default

    s.headerText = s.headerText === undefined ? s.display !== 'inline' ? '{value}' : false : s.headerText;
    buttons = s.buttons || [];
    isModal = s.display !== 'inline';
    $ctx = $$1(s.context);
    $lock = hasContext ? $ctx : $$1('body,html');
    ctx = $ctx[0];
    that.live = true; // If no set button is found, live mode is activated

    for (i = 0; i < buttons.length; i++) {
      b = buttons[i];

      if (b == 'ok' || b == 'set' || b.handler == 'set') {
        that.live = false;
      }
    }

    that.buttons.set = {
      text: s.setText,
      icon: s.setIcon,
      handler: 'set'
    };
    that.buttons.cancel = {
      text: s.cancelText,
      icon: s.cancelIcon,
      handler: 'cancel'
    };
    that.buttons.close = {
      text: s.closeText,
      icon: s.closeIcon,
      handler: 'cancel'
    };
    that.buttons.clear = {
      text: s.clearText,
      icon: s.clearIcon,
      handler: 'clear'
    };
    that._isInput = $elm.is('input');
  };
  /**
   * Scroller initialization.
   */


  that._init = function (newSettings) {
    var wasVisible = that._isVisible,
        wasReady = wasVisible && !$markup.hasClass('mbsc-fr-pos');

    if (wasVisible) {
      that.hide(true, false, true);
    } // Unbind all events (if re-init)


    $elm.off('.mbsc');
    tapOff($elm);

    that.__init(newSettings);

    that._isLiquid = s.layout == 'liquid';

    if (isModal) {
      that._readValue();

      if (!that._hasContent && !s.skipShow) {
        that.attachShow($elm);
      }

      if (wasVisible) {
        that.show(wasReady);
      }
    } else {
      that.show();
    }

    $elm.removeClass('mbsc-cloak').filter('input, select, textarea').on('change.mbsc', function () {
      if (!that._preventChange) {
        that.setVal($elm.val(), true, false);
      }

      that._preventChange = false;
    });
  };

  that.buttons = {};
  that.handlers = {
    set: that.select,
    cancel: that.cancel,
    clear: that.clear
  };
  that._value = null;
  that._isValid = true;
  that._isVisible = false; // Constructor

  s = that.settings;
  trigger = that.trigger;

  if (!inherit) {
    that.init();
  }
};
Frame.prototype._defaults = {
  // Localization
  lang: 'en',
  setText: 'Set',
  selectedText: '{count} selected',
  closeText: 'Close',
  cancelText: 'Cancel',
  clearText: 'Clear',
  // Options
  context: 'body',
  maxPopupWidth: 600,
  disabled: false,
  closeOnOverlayTap: true,
  showOnFocus: isAndroid || isIOS,
  // Needed for ion-input
  showOnTap: true,
  display: 'center',
  scroll: true,
  scrollLock: true,
  showOverlay: true,
  tap: true,
  touchUi: true,
  btnClass: 'mbsc-fr-btn',
  btnWidth: true,
  focusTrap: true,
  focusOnClose: !isIOS8 // Temporary for iOS8

};
classes.Frame = Frame;
themes.frame.mobiscroll = {
  headerText: false,
  btnWidth: false
};
themes.scroller.mobiscroll = extend$1({}, themes.frame.mobiscroll, {
  rows: 5,
  showLabel: false,
  selectedLineBorder: 1,
  weekDays: 'min',
  checkIcon: 'ion-ios7-checkmark-empty',
  btnPlusClass: 'mbsc-ic mbsc-ic-arrow-down5',
  btnMinusClass: 'mbsc-ic mbsc-ic-arrow-up5',
  btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left5',
  btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right5'
});

if (isBrowser) {
  // Prevent re-show on window focus
  $$1(window).on('focus', function () {
    if ($activeElm) {
      preventShow = true;
    }
  });
}

var Popup = function Popup(el, settings, inherit) {
  function addContent($m) {
    /* TRIAL */
    if (!$$1('.mbsc-fr-c', $m).hasClass('mbsc-wdg-c')
    /* TRIALCOND */
    ) {
        $$1('.mbsc-fr-c', $m).addClass('mbsc-wdg-c').append($elm.show());

        if (!$$1('.mbsc-w-p', $m).length) {
          $$1('.mbsc-fr-c', $m).addClass('mbsc-w-p');
        }
      }
  }

  var s,
      $prev,
      $elm = $$1(el),
      that = this; // Call the parent constructor

  Frame.call(this, el, settings, true);
  /* TRIALFUNC */

  that._generateContent = function () {
    return '';
  };

  that._markupReady = function ($m) {
    if (s.display != 'inline') {
      addContent($m);
    }
  };

  that._markupInserted = function ($m) {
    if (s.display == 'inline') {
      addContent($m);
    }

    $m.trigger('mbsc-enhance', [{
      theme: s.theme,
      lang: s.lang
    }]);
  };

  that._markupRemove = function () {
    $elm.hide();

    if ($prev && $prev.parent().length) {
      $prev.after($elm);
    }
  };

  that.__processSettings = function () {
    s = that.settings;
    that.buttons.ok = {
      text: s.okText,
      icon: s.okIcon,
      handler: 'set'
    };
    s.buttons = s.buttons || (s.display == 'inline' ? [] : ['ok']);

    if (!$prev && $elm.parent().length) {
      $prev = $$1(document.createComment('popup'));
      $elm.before($prev);
    }

    $elm.hide();
  }; // Constructor


  if (!inherit) {
    that.init();
  }
};
Popup.prototype = {
  _hasDef: true,
  _hasTheme: true,
  _hasContent: true,
  _hasLang: true,
  _responsive: true,
  _class: 'popup',
  _defaults: extend$1({}, Frame.prototype._defaults, {
    compClass: 'mbsc-wdg',
    okText: 'OK',
    headerText: false
  })
};
classes.Popup = Popup;
classes.Widget = Popup;
mobiscroll.themes.popup = mobiscroll.themes.frame;

var hasPromise = isBrowser && !!window.Promise;
var popupQueue = [];
var notificationQueue = [];
var activeNotification;

function showPopup(popup) {
  if (!popupQueue.length) {
    popup.show();
  }

  popupQueue.push(popup);
}

function showNotification(notification) {
  var isAny = notificationQueue.length;
  notificationQueue.push(notification); // Only show notification if no popup is visible
  // otherwise postpone it until popup is closed

  if (!popupQueue.length) {
    // If there's a visible notification, hide it.
    // The notification will be shown after hide animation is complete
    if (isAny) {
      notificationQueue[0].hide();
    } else {
      // Prevent focus on show for notifications
      notification.show(false, true);
    }
  }
}

function getSettings(queue, settings, resolve, more) {
  //const active = mobiscroll.activeInstance;
  return extend$1({
    display: settings.display || 'center',
    cssClass: 'mbsc-alert',
    okText: settings.okText,
    cancelText: settings.cancelText,
    context: settings.context,
    theme: settings.theme,
    closeOnOverlayTap: false,
    onBeforeClose: function onBeforeClose() {
      queue.shift();
    },
    onHide: function onHide(ev, inst) {
      //mobiscroll.activeInstance = active;
      if (resolve) {
        resolve(inst._resolve);
      }

      if (settings.callback) {
        settings.callback(inst._resolve);
      }

      if (inst) {
        inst.destroy();
      } // Show next


      if (popupQueue.length) {
        popupQueue[0].show();
      } else if (notificationQueue.length) {
        // Prevent focus on show for notifications
        notificationQueue[0].show(false, true);
      }
    }
  }, more);
}

function getMessage(settings) {
  return (settings.title ? '<h2>' + settings.title + '</h2>' : '') + '<p>' + (settings.message || '') + '</p>';
}

function showAlert(popup, settings, resolve) {
  var inst = new Popup(popup, getSettings(popupQueue, settings, resolve));
  showPopup(inst);
}

function showConfirm(popup, settings, resolve) {
  var inst = new Popup(popup, getSettings(popupQueue, settings, resolve, {
    buttons: ['cancel', 'ok'],
    onSet: function onSet() {
      inst._resolve = true;
    }
  }));
  inst._resolve = false;
  showPopup(inst);
}

function showPrompt(popup, settings, resolve) {
  var input, label;
  var inst = new Popup(popup, getSettings(popupQueue, settings, resolve, {
    buttons: ['cancel', 'ok'],
    onMarkupReady: function onMarkupReady(event, inst) {
      var s = inst.settings;
      label = inst._markup.find('label');
      label.addClass('mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : ''));
      input = inst._markup.find('input')[0];
      setTimeout(function () {
        input.focus();
        input.setSelectionRange(0, input.value.length);
      }, 300);
    },
    onSet: function onSet() {
      inst._resolve = input.value;
    }
  }));
  inst._resolve = null;
  showPopup(inst);
}

function showSnackbar(popup, settings, resolve, cssClass, animation) {
  var notificationTimer;
  var inst = new Popup(popup, getSettings(notificationQueue, settings, resolve, {
    display: settings.display || 'bottom',
    animate: animation,
    cssClass: (cssClass || 'mbsc-snackbar') + (settings.color ? ' mbsc-' + settings.color : ''),
    scrollLock: false,
    focusTrap: false,
    buttons: [],
    onMarkupReady: function onMarkupReady(event, inst) {
      var s = inst.settings;

      var button = inst._markup.find('button');

      button.addClass('mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : ''));
    },
    onShow: function onShow(ev, inst) {
      activeNotification = inst;

      if (settings.duration !== false) {
        notificationTimer = setTimeout(function () {
          if (inst) {
            inst.hide();
          }
        }, settings.duration || 3000);
      }

      if (settings.button) {
        inst.tap($$1('.mbsc-snackbar-btn', ev.target), function () {
          inst.hide();

          if (settings.button.action) {
            settings.button.action.call(this);
          }
        });
      }
    },
    onClose: function onClose() {
      activeNotification = null;
      clearTimeout(notificationTimer);
    }
  }));
  showNotification(inst);
}

function showToast(popup, settings, resolve) {
  showSnackbar(popup, settings, resolve, 'mbsc-toast', 'fade');
}

function show(func, popup, settings) {
  var p;

  if (hasPromise) {
    p = new Promise(function (resolve) {
      func(popup, settings, resolve);
    });
  } else {
    func(popup, settings);
  }

  return p;
}

mobiscroll.alert = function (settings) {
  var popup = document.createElement('div');
  popup.innerHTML = getMessage(settings);
  return show(showAlert, popup, settings);
};

mobiscroll.confirm = function (settings) {
  var popup = document.createElement('div');
  popup.innerHTML = getMessage(settings);
  return show(showConfirm, popup, settings);
};

mobiscroll.prompt = function (settings) {
  var popup = document.createElement('div');
  popup.innerHTML = getMessage(settings) + '<label class="mbsc-input">' + (settings.label ? '<span class="mbsc-label">' + settings.label + '</span>' : '') + '<input class="mbsc-control" tabindex="0" type="' + (settings.inputType || 'text') + '" placeholder="' + (settings.placeholder || '') + '" value="' + (settings.value || '') + '">' + '</label>';
  return show(showPrompt, popup, settings);
};

mobiscroll.snackbar = function (settings) {
  var popup = document.createElement('div'),
      btn = settings.button;
  popup.innerHTML = '<div class="mbsc-snackbar-cont"><div class="mbsc-snackbar-msg">' + (settings.message || '') + '</div>' + (btn ? '<button class="mbsc-snackbar-btn mbsc-btn mbsc-btn-flat">' + (btn.icon ? '<span class="mbsc-ic ' + (btn.text ? 'mbsc-btn-ic ' : '') + 'mbsc-ic-' + btn.icon + '"></span>' : '') + (btn.text || '') + '</button>' : '') + '</div>';
  return show(showSnackbar, popup, settings);
};

mobiscroll.toast = function (settings) {
  var popup = document.createElement('div');
  popup.innerHTML = '<div class="mbsc-toast-msg">' + (settings.message || '') + '</div>';
  return show(showToast, popup, settings);
};

mobiscroll.notification = {
  dismiss: function dismiss() {
    if (activeNotification) {
      activeNotification.hide();
    }
  }
};

var halfBorder$1 = os == 'ios' && majorVersion > 7;
var Form = function Form(el, settings) {
  var s,
      cssClass = '',
      $ctx = $$1(el),
      controls = {},
      that = this;

  function touched() {
    $ctx.removeClass('mbsc-no-touch');
  } // Call the parent constructor


  Base.call(this, el, settings, true);

  that.refresh = function (shallow) {
    if (s.enhance) {
      initControls($ctx, controls, s, shallow);
    }
  };
  /**
   * Form initialization.
   */


  that._init = function () {
    if (!mobiscroll.themes.form[s.theme]) {
      s.theme = 'mobiscroll';
    }

    if (!$ctx.hasClass('mbsc-form')) {
      $ctx.show();
      listen($ctx[0], 'touchstart', touched, {
        passive: true
      });
    }

    if (cssClass) {
      $ctx.removeClass(cssClass);
    } // --- TRIAL SERVER CODE START ---


    cssClass = 'mbsc-form mbsc-no-touch mbsc-' + s.theme + (halfBorder$1 ? ' mbsc-form-hb' : '') + (s.baseTheme ? ' mbsc-' + s.baseTheme : '') + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr') + (s.inputStyle == 'box' ? ' mbsc-form-box' : '') + (s.inputStyle == 'outline' ? ' mbsc-form-outline' : ''); // --- TRIAL SERVER CODE END ---

    $ctx.addClass(cssClass).removeClass('mbsc-cloak');
    that.refresh();
  };
  /**
   * Destroys the mobiscroll instance.
   */


  that._destroy = function () {
    $ctx.removeClass(cssClass);
    unlisten($ctx[0], 'touchstart', touched, {
      passive: true
    });

    for (var id in controls) {
      controls[id].destroy();
    }
  };
  /**
   * Object with the underlying form control instances
   * keys are the element id's
   */


  that.controls = controls; // Constructor

  s = that.settings;
  that.init();
}; // Extend defaults

Form.prototype = {
  _hasDef: true,
  _hasTheme: true,
  _hasLang: true,
  _class: 'form',
  _defaults: {
    tap: hasGhostClick,
    stopProp: true,
    rtl: false,
    enhance: true
  }
};
classes.Form = Form; // Init mbsc-form elements on page load

autoInit('[mbsc-enhance],[mbsc-form]', Form, true);

var MbscForm = (function (_super) {
    __extends(MbscForm, _super);
    function MbscForm(initialElem, _formService, zone) {
        var _this = _super.call(this, initialElem, zone) || this;
        _this._formService = _formService;
        _this.enhance = false;
        return _this;
    }
    MbscForm.prototype.ngOnInit = function () {
        this.optionsObj = extend$1({}, this.options, this.inlineOptionsObj);
        this._formService.options = this.optionsObj;
    };
    MbscForm.prototype.initControl = function () {
        var opt = this.options;
        if (opt && opt.enhance === undefined) {
            opt.enhance = false;
        }
        var options = extend$1({}, opt, this.inlineOptionsObj);
        this.instance = new Form(this.rootElem.nativeElement, options);
    };
    MbscForm.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-form',
                    template: "<div #rootElement><ng-content></ng-content></div>",
                    providers: [MbscOptionsService],
                    exportAs: 'mobiscroll'
                },] },
    ];
    MbscForm.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, },
        { type: NgZone, },
    ]; };
    MbscForm.propDecorators = {
        'options': [{ type: Input$1, args: ['options',] },],
        'enhance': [{ type: Input$1 },],
        'context': [{ type: Input$1 },],
        'inputStyle': [{ type: Input$1, args: ['input-style',] },],
        'labelStyle': [{ type: Input$1, args: ['label-style',] },],
        'rootElem': [{ type: ViewChild, args: ['rootElement', { static: false },] },],
    };
    return MbscForm;
}(MbscBase));
var MbscTextarea = (function (_super) {
    __extends(MbscTextarea, _super);
    function MbscTextarea(initialElem, _formService, _inputService, _control, zone) {
        var _this = _super.call(this, initialElem, _formService, _inputService, _control, zone) || this;
        _this._inputService = _inputService;
        _inputService.input = _this;
        return _this;
    }
    MbscTextarea.prototype.initControl = function () {
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new TextArea(this._initElem.nativeElement, options);
    };
    MbscTextarea.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-textarea',
                    host: { 'class': 'mbsc-control-ng' },
                    template: "\n            <label \n                [class.mbsc-err]=\"error\"\n                [class.mbsc-input-box]=\"inputStyle == 'box'\"\n                [class.mbsc-input-outline]=\"inputStyle == 'outline'\"\n                [class.mbsc-label-stacked]=\"labelStyle == 'stacked'\"\n                [class.mbsc-label-inline]=\"labelStyle == 'inline'\"\n                [class.mbsc-label-floating]=\"labelStyle == 'floating'\"\n            >\n            <ng-content></ng-content>\n            <span class=\"mbsc-input-wrap\">\n                <textarea #initElement [placeholder]=\"placeholder\" [(ngModel)]=\"innerValue\" (blur)=\"onTouch($event)\"\n                    [attr.name]=\"name\"\n                    [attr.rows]=\"rows\"\n                    [attr.wrap]=\"wrap\"\n                    [attr.minlength]=\"minlength\"\n                    [attr.maxlength]=\"maxlength\"\n                    [attr.autocomplete]=\"autocomplete\" \n                    [attr.autocapitalize]=\"autocapitalize\"\n                    [attr.autocorrect]=\"autocorrect\"\n                    [attr.spellcheck]=\"spellcheck\"\n                    [attr.autofocus]=\"autofocus\"\n                    [attr.required]=\"required\"\n                    [attr.data-icon]=\"icon ? icon : null\"\n                    [attr.data-icon-align]=\"iconAlign ? iconAlign : null\"\n                    [disabled]=\"disabled\"\n                    [readonly]=\"_readonly\"></textarea>\n                <span *ngIf=\"error && errorMessage\" class=\"mbsc-err-msg\">{{errorMessage}}</span>\n            </span>\n        </label>\n    ",
                    providers: [MbscInputService]
                },] },
    ];
    MbscTextarea.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscInputService, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: NgZone, },
    ]; };
    MbscTextarea.propDecorators = {
        'rows': [{ type: Input$1 },],
        'wrap': [{ type: Input$1 },],
    };
    return MbscTextarea;
}(MbscInputBase));
var MbscDropdown = (function (_super) {
    __extends(MbscDropdown, _super);
    function MbscDropdown(hostElem, formService, _inputService, control, zone) {
        var _this = _super.call(this, hostElem, formService, _inputService, control, zone) || this;
        _this._inputService = _inputService;
        _inputService.input = _this;
        return _this;
    }
    Object.defineProperty(MbscDropdown.prototype, "value", {
        set: function (v) {
            var _this = this;
            this._value = v;
            setTimeout(function () {
                _this.instance._setText();
            });
        },
        enumerable: true,
        configurable: true
    });
    MbscDropdown.prototype.initControl = function () {
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new Select(this._initElem.nativeElement, options);
        var that = this;
        setTimeout(function () {
            that.instance._setText();
        });
    };
    MbscDropdown.prototype.writeValue = function (v) {
        this._value = v;
        if (this.instance) {
            var that_1 = this;
            setTimeout(function () {
                that_1.instance._setText();
            });
        }
    };
    MbscDropdown.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-dropdown',
                    host: { 'class': 'mbsc-control-ng' },
                    template: "\n            <label \n                [class.mbsc-err]=\"error\"\n                [class.mbsc-input-box]=\"inputStyle == 'box'\"\n                [class.mbsc-input-outline]=\"inputStyle == 'outline'\"\n                [class.mbsc-label-stacked]=\"labelStyle == 'stacked'\"\n                [class.mbsc-label-inline]=\"labelStyle == 'inline'\"\n                [class.mbsc-label-floating]=\"labelStyle == 'floating'\"\n            >\n            {{label}}\n            <span class=\"mbsc-input-wrap\">\n                <select #initElement\n                    [(ngModel)]=\"innerValue\" \n                    [attr.name]=\"name\"\n                    [attr.data-icon]=\"icon ? icon : null\"\n                    [attr.data-icon-align]=\"iconAlign ? iconAlign : null\"\n                    [disabled]=\"disabled\"\n                    (blur)=\"onTouch($event)\">\n                    <ng-content></ng-content>\n                </select>\n                <span *ngIf=\"error && errorMessage\" class=\"mbsc-err-msg\">{{errorMessage}}</span>\n            </span>\n        </label>\n    ",
                    providers: [MbscInputService]
                },] },
    ];
    MbscDropdown.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscInputService, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: NgZone, },
    ]; };
    MbscDropdown.propDecorators = {
        'label': [{ type: Input$1 },],
        'icon': [{ type: Input$1 },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'value': [{ type: Input$1 },],
        'inputStyle': [{ type: Input$1, args: ['input-style',] },],
        'labelStyle': [{ type: Input$1, args: ['label-style',] },],
    };
    return MbscDropdown;
}(MbscFormValueBase));
var MbscButton = (function (_super) {
    __extends(MbscButton, _super);
    function MbscButton(hostElem, formService, zone) {
        var _this = _super.call(this, hostElem, formService, zone) || this;
        _this._flat = false;
        _this._block = false;
        _this._outline = false;
        _this._classesObj = {};
        _this.type = 'button';
        return _this;
    }
    Object.defineProperty(MbscButton.prototype, "cssClasses", {
        get: function () {
            for (var k in this._classesObj) {
                delete this._classesObj[k];
            }
            this._classesObj['mbsc-btn-flat'] = this._flat;
            this._classesObj['mbsc-btn-block'] = this._block;
            this._classesObj['mbsc-btn-outline'] = this._outline;
            if (this.classes) {
                var cssClasses = this.classes.split(' ');
                if (cssClasses.length) {
                    for (var i = 0; i < cssClasses.length; i++) {
                        if (cssClasses[i]) {
                            this._classesObj[cssClasses[i]] = true;
                        }
                    }
                }
            }
            if (this.color) {
                this._classesObj['mbsc-btn-' + this.color] = true;
            }
            return this._classesObj;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscButton.prototype, "flat", {
        set: function (val) {
            this._flat = emptyOrTrue(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscButton.prototype, "block", {
        set: function (val) {
            this._block = emptyOrTrue(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscButton.prototype, "outline", {
        set: function (val) {
            this._outline = emptyOrTrue(val);
        },
        enumerable: true,
        configurable: true
    });
    MbscButton.prototype.initControl = function () {
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new Button(this._initElem.nativeElement, options);
    };
    MbscButton.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-button',
                    template: "\n        <button #initElement \n            [type]=\"type\"\n            [ngClass]=\"cssClasses\"\n            [attr.name]=\"name\"\n            [attr.data-icon]=\"icon ? icon : null\"\n            [disabled]=\"disabled\">\n            <ng-content></ng-content>\n        </button>\n    ",
                    changeDetection: ChangeDetectionStrategy.OnPush
                },] },
    ];
    MbscButton.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: NgZone, },
    ]; };
    MbscButton.propDecorators = {
        'classes': [{ type: Input$1, args: ['class',] },],
        'type': [{ type: Input$1 },],
        'icon': [{ type: Input$1 },],
        'flat': [{ type: Input$1 },],
        'block': [{ type: Input$1 },],
        'outline': [{ type: Input$1 },],
    };
    return MbscButton;
}(MbscFormBase));
var MbscCheckbox = (function (_super) {
    __extends(MbscCheckbox, _super);
    function MbscCheckbox(hostElem, cdr, formService, _inputService, control, zone) {
        var _this = _super.call(this, hostElem, formService, _inputService, control, zone) || this;
        _this.cdr = cdr;
        _this._colorClass = {};
        return _this;
    }
    Object.defineProperty(MbscCheckbox.prototype, "colorClass", {
        get: function () {
            for (var k in this._colorClass) {
                delete this._colorClass[k];
            }
            if (this.color) {
                this._colorClass['mbsc-checkbox-' + this.color] = true;
            }
            if (this.error) {
                this._colorClass['mbsc-err'] = true;
            }
            return this._colorClass;
        },
        enumerable: true,
        configurable: true
    });
    MbscCheckbox.prototype.initControl = function () {
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new CheckBox(this._initElem.nativeElement, options);
    };
    MbscCheckbox.prototype.writeValue = function (v) {
        this._value = v;
        this.cdr.detectChanges();
    };
    MbscCheckbox.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-checkbox',
                    host: { 'class': 'mbsc-control-ng' },
                    template: "\n        <label [ngClass]=\"colorClass\">\n            <input #initElement \n                type=\"checkbox\"\n                [attr.name]=\"name\"\n                [disabled]=\"disabled\"\n                [attr.data-label-style]=\"labelStyle\"\n                [attr.data-input-style]=\"inputStyle\"\n                [(ngModel)]=\"innerValue\"\n                (blur)=\"onTouch($event)\" />\n            <ng-content></ng-content>\n            <span *ngIf=\"error && errorMessage\" class=\"mbsc-err-msg\">{{errorMessage}}</span>\n        </label>\n    ",
                    changeDetection: ChangeDetectionStrategy.OnPush
                },] },
    ];
    MbscCheckbox.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: ChangeDetectorRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: NgZone, },
    ]; };
    MbscCheckbox.propDecorators = {
        'color': [{ type: Input$1 },],
        'inputStyle': [{ type: Input$1, args: ['input-style',] },],
        'labelStyle': [{ type: Input$1, args: ['label-style',] },],
    };
    return MbscCheckbox;
}(MbscFormValueBase));
var MbscSwitch = (function (_super) {
    __extends(MbscSwitch, _super);
    function MbscSwitch(hostElem, zone, _formService, control) {
        var _this = _super.call(this, hostElem, zone, control, null, null) || this;
        _this._formService = _formService;
        _this.disabled = false;
        _this.onChangeEmitter = new EventEmitter();
        _this._colorClass = {};
        return _this;
    }
    Object.defineProperty(MbscSwitch.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscSwitch.prototype, "colorClass", {
        get: function () {
            for (var k in this._colorClass) {
                delete this._colorClass[k];
            }
            if (this.color) {
                this._colorClass['mbsc-switch-' + this.color] = true;
            }
            if (this.error) {
                this._colorClass['mbsc-err'] = true;
            }
            return this._colorClass;
        },
        enumerable: true,
        configurable: true
    });
    MbscSwitch.prototype.setNewValue = function (v) {
        if (this.instance) {
            if (this.instance.getVal() !== v) {
                this.instance.setVal(v, true, false);
            }
        }
    };
    MbscSwitch.prototype.ngOnInit = function () {
        this._inheritedOptions = this._formService ? this._formService.options : {};
        _super.prototype.ngOnInit.call(this);
    };
    MbscSwitch.prototype.initControl = function () {
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new Switch(this._initElem.nativeElement, options);
        if (this.initialValue !== undefined) {
            this.instance.setVal(this.initialValue, true, false);
        }
    };
    MbscSwitch.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-switch',
                    host: { 'class': 'mbsc-control-ng' },
                    template: "\n        <label [ngClass]=\"colorClass\">\n            <ng-content></ng-content>\n            <span *ngIf=\"error && errorMessage\" class=\"mbsc-err-msg\">{{errorMessage}}</span>\n            <input #initElement \n                type=\"checkbox\"\n                data-role=\"switch\"\n                [attr.name]=\"name\"\n                [attr.data-label-style]=\"labelStyle\"\n                [attr.data-input-style]=\"inputStyle\"\n                [disabled]=\"disabled\"\n                (blur)=\"onTouch($event)\" />\n        </label>\n    ",
                    exportAs: 'mobiscroll',
                    changeDetection: ChangeDetectionStrategy.OnPush
                },] },
    ];
    MbscSwitch.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: NgControl, decorators: [{ type: Optional },] },
    ]; };
    MbscSwitch.propDecorators = {
        'options': [{ type: Input$1, args: ['options',] },],
        'disabled': [{ type: Input$1 },],
        'name': [{ type: Input$1 },],
        'color': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
        'value': [{ type: Input$1, args: ['value',] },],
        'onChangeEmitter': [{ type: Output, args: ['valueChange',] },],
        '_initElem': [{ type: ViewChild, args: ['initElement', { static: false },] },],
    };
    return MbscSwitch;
}(MbscControlBase));
var MbscStepper = (function (_super) {
    __extends(MbscStepper, _super);
    function MbscStepper(hostElement, zone, _formService, control) {
        var _this = _super.call(this, hostElement, zone, control, null, null) || this;
        _this._formService = _formService;
        _this.min = undefined;
        _this.max = undefined;
        _this.step = undefined;
        _this.val = undefined;
        _this.disabled = false;
        _this._colorClass = {};
        _this.onChangeEmitter = new EventEmitter();
        return _this;
    }
    Object.defineProperty(MbscStepper.prototype, "readonly", {
        set: function (val) {
            this._readonly = emptyOrTrue(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscStepper.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscStepper.prototype, "colorClass", {
        get: function () {
            for (var k in this._colorClass) {
                delete this._colorClass[k];
            }
            if (this.color) {
                this._colorClass['mbsc-stepper-' + this.color] = true;
            }
            return this._colorClass;
        },
        enumerable: true,
        configurable: true
    });
    MbscStepper.prototype.setNewValue = function (v) {
        if (this.instance && this.instance.getVal() !== v) {
            this.instance.setVal(v, true, false);
        }
    };
    MbscStepper.prototype.ngOnInit = function () {
        this._inheritedOptions = this._formService ? this._formService.options : {};
        _super.prototype.ngOnInit.call(this);
    };
    MbscStepper.prototype.initControl = function () {
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new Stepper(this._initElem.nativeElement, options);
        if (this.initialValue !== undefined) {
            this.instance.setVal(this.initialValue, true, false);
        }
    };
    MbscStepper.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-stepper',
                    host: { 'class': 'mbsc-control-ng' },
                    template: "\n        <div [ngClass]=\"colorClass\">\n            <ng-content></ng-content>\n            <input #initElement\n                data-role=\"stepper\"\n                [attr.name]=\"name\"\n                [attr.min]=\"min !== undefined ? min : null\"\n                [attr.max]=\"max !== undefined ? max : null\"\n                [attr.step]=\"step !== undefined ? step : null\"\n                [attr.data-val]=\"val ? val : null\"\n                [attr.data-label-style]=\"labelStyle\"\n                [attr.data-input-style]=\"inputStyle\"\n                [disabled]=\"disabled\" \n                [readonly]=\"_readonly\"/>\n        </div>\n    ",
                    exportAs: 'mobiscroll',
                    changeDetection: ChangeDetectionStrategy.OnPush
                },] },
    ];
    MbscStepper.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: NgControl, decorators: [{ type: Optional },] },
    ]; };
    MbscStepper.propDecorators = {
        'readonly': [{ type: Input$1 },],
        'options': [{ type: Input$1, args: ['options',] },],
        'value': [{ type: Input$1 },],
        'name': [{ type: Input$1 },],
        'min': [{ type: Input$1 },],
        'max': [{ type: Input$1 },],
        'step': [{ type: Input$1 },],
        'val': [{ type: Input$1 },],
        'disabled': [{ type: Input$1 },],
        'color': [{ type: Input$1 },],
        'onChangeEmitter': [{ type: Output, args: ['valueChange',] },],
        '_initElem': [{ type: ViewChild, args: ['initElement', { static: false },] },],
    };
    return MbscStepper;
}(MbscControlBase));
var MbscProgress = (function (_super) {
    __extends(MbscProgress, _super);
    function MbscProgress(hostElement, zone, _formService, control) {
        var _this = _super.call(this, hostElement, zone, control, null, null) || this;
        _this._formService = _formService;
        _this.max = undefined;
        _this.icon = undefined;
        _this.iconAlign = undefined;
        _this.val = undefined;
        _this.disabled = false;
        _this._colorClass = {};
        return _this;
    }
    Object.defineProperty(MbscProgress.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscProgress.prototype, "dataStepLabels", {
        get: function () {
            if (typeof (this.stepLabels) === 'string') {
                return this.stepLabels;
            }
            else {
                return null;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscProgress.prototype, "colorClass", {
        get: function () {
            for (var k in this._colorClass) {
                delete this._colorClass[k];
            }
            if (this.color) {
                this._colorClass['mbsc-progress-' + this.color] = true;
            }
            return this._colorClass;
        },
        enumerable: true,
        configurable: true
    });
    MbscProgress.prototype.setNewValue = function (v) {
        if (this.instance && this.instance.getVal() !== v) {
            this.instance.setVal(v, true, false);
        }
    };
    MbscProgress.prototype.ngOnInit = function () {
        this._inheritedOptions = this._formService ? this._formService.options : {};
        _super.prototype.ngOnInit.call(this);
    };
    MbscProgress.prototype.initControl = function () {
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new Progress(this._initElem.nativeElement, options);
        if (this.initialValue !== undefined) {
            this.instance.setVal(this.initialValue, true, false);
        }
    };
    MbscProgress.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-progress',
                    host: { 'class': 'mbsc-control-ng' },
                    template: "\n        <label [ngClass]=\"colorClass\">\n            <ng-content></ng-content>\n            <progress #initElement\n                [attr.data-step-labels]=\"dataStepLabels\"\n                [attr.data-icon]=\"icon ? icon : null\"\n                [attr.data-icon-align]=\"iconAlign ? iconAlign : null\"\n                [attr.data-label-style]=\"labelStyle\"\n                [attr.data-input-style]=\"inputStyle\"\n                [attr.max]=\"max !== undefined ? max : null\"\n                [attr.data-val]=\"val !== undefined ? val : null\"\n            >\n            </progress>\n        </label>\n    ",
                    exportAs: 'mobiscroll',
                    changeDetection: ChangeDetectionStrategy.OnPush
                },] },
    ];
    MbscProgress.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: NgControl, decorators: [{ type: Optional },] },
    ]; };
    MbscProgress.propDecorators = {
        'options': [{ type: Input$1, args: ['options',] },],
        'value': [{ type: Input$1 },],
        'max': [{ type: Input$1 },],
        'icon': [{ type: Input$1 },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'val': [{ type: Input$1 },],
        'disabled': [{ type: Input$1 },],
        'stepLabels': [{ type: Input$1, args: ['step-labels',] },],
        'color': [{ type: Input$1 },],
        '_initElem': [{ type: ViewChild, args: ['initElement', { static: false },] },],
    };
    return MbscProgress;
}(MbscControlBase));
var groupName = 1;
var MbscRadioService = (function () {
    function MbscRadioService() {
        this._lastValue = null;
        this._valueObservable = new Observable();
    }
    Object.defineProperty(MbscRadioService.prototype, "name", {
        get: function () {
            if (!this._name) {
                this._name = 'mbsc-radio-group-' + (groupName++);
            }
            return this._name;
        },
        set: function (n) {
            this._name = n;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscRadioService.prototype, "multiSelect", {
        get: function () {
            return this._multiSelect;
        },
        set: function (v) {
            this._multiSelect = v;
        },
        enumerable: true,
        configurable: true
    });
    MbscRadioService.prototype.onValueChanged = function () {
        return this._valueObservable;
    };
    MbscRadioService.prototype.changeValue = function (v) {
        this._valueObservable.next(v);
        this._lastValue = v;
    };
    Object.defineProperty(MbscRadioService.prototype, "getLastValue", {
        get: function () {
            return this._lastValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscRadioService.prototype, "color", {
        get: function () {
            return this._color;
        },
        set: function (v) {
            this._color = v;
        },
        enumerable: true,
        configurable: true
    });
    MbscRadioService.decorators = [
        { type: Injectable },
    ];
    MbscRadioService.ctorParameters = function () { return []; };
    return MbscRadioService;
}());
var MbscRadioGroupBase = (function (_super) {
    __extends(MbscRadioGroupBase, _super);
    function MbscRadioGroupBase(hostElement, formService, _inputService, _radioService, control, zone) {
        var _this = _super.call(this, hostElement, formService, _inputService, control, zone) || this;
        _this._radioService = _radioService;
        _this.valueObserver = _this._radioService.onValueChanged().subscribe(function (v) {
            _this.innerValue = v;
            _this.onTouch();
        });
        return _this;
    }
    Object.defineProperty(MbscRadioGroupBase.prototype, "value", {
        set: function (v) {
            this._value = v;
            this._radioService.changeValue(v);
        },
        enumerable: true,
        configurable: true
    });
    MbscRadioGroupBase.prototype.ngOnInit = function () {
        _super.prototype.ngOnInit.call(this);
        if (this.name) {
            this._radioService.name = this.name;
        }
        if (this.color) {
            this._radioService.color = this.color;
        }
    };
    MbscRadioGroupBase.prototype.writeValue = function (v) {
        this._value = v;
        this._radioService.changeValue(v);
    };
    MbscRadioGroupBase.prototype.updateOptions = function () { };
    MbscRadioGroupBase.prototype.ngOnDestroy = function () {
        this._radioService.onValueChanged().unsubscribe(this.valueObserver);
        _super.prototype.ngOnDestroy.call(this);
    };
    MbscRadioGroupBase.decorators = [
        { type: Directive, args: [{ selector: '[mbsc-rg-b]' },] },
    ];
    MbscRadioGroupBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscRadioService, },
        { type: NgControl, },
        { type: NgZone, },
    ]; };
    MbscRadioGroupBase.propDecorators = {
        'name': [{ type: Input$1 },],
        'value': [{ type: Input$1 },],
    };
    return MbscRadioGroupBase;
}(MbscFormValueBase));
var MbscRadioGroup = (function (_super) {
    __extends(MbscRadioGroup, _super);
    function MbscRadioGroup(hostElement, formService, _inputService, radioService, control, zone) {
        return _super.call(this, hostElement, formService, _inputService, radioService, control, zone) || this;
    }
    MbscRadioGroup.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-radio-group',
                    template: "<ng-content></ng-content>",
                    providers: [MbscRadioService]
                },] },
    ];
    MbscRadioGroup.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscRadioService, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: NgZone, },
    ]; };
    return MbscRadioGroup;
}(MbscRadioGroupBase));
var MbscRadio = (function (_super) {
    __extends(MbscRadio, _super);
    function MbscRadio(hostElement, formService, _radioService, zone) {
        var _this = _super.call(this, hostElement, formService, zone) || this;
        _this._radioService = _radioService;
        _this._colorClass = {};
        var v = _this._radioService.getLastValue;
        if (v !== null) {
            _this.modelValue = v;
        }
        _this.valueObserver = _this._radioService.onValueChanged().subscribe(function (v) {
            _this.modelValue = v;
        });
        return _this;
    }
    Object.defineProperty(MbscRadio.prototype, "checked", {
        get: function () {
            return this.value == this.modelValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscRadio.prototype, "colorClass", {
        get: function () {
            for (var k in this._colorClass) {
                delete this._colorClass[k];
            }
            if (this.color) {
                this._colorClass['mbsc-radio-' + this.color] = true;
            }
            if (this.error) {
                this._colorClass['mbsc-err'] = true;
            }
            return this._colorClass;
        },
        enumerable: true,
        configurable: true
    });
    MbscRadio.prototype.clicked = function (e) {
        this._radioService.changeValue(this.value);
    };
    MbscRadio.prototype.initControl = function () {
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new Radio(this._initElem.nativeElement, options);
    };
    MbscRadio.prototype.ngOnInit = function () {
        _super.prototype.ngOnInit.call(this);
        this.name = this._radioService.name;
        this.color = this._radioService.color;
    };
    MbscRadio.prototype.ngOnDestroy = function () {
        this._radioService.onValueChanged().unsubscribe(this.valueObserver);
        _super.prototype.ngOnDestroy.call(this);
    };
    MbscRadio.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-radio',
                    host: { 'class': 'mbsc-control-ng' },
                    template: "\n        <label [ngClass]=\"colorClass\">\n            <input #initElement \n                type=\"radio\" \n                [attr.name]=\"name\" \n                [attr.value]=\"value\"\n                [value]=\"value\" \n                [checked]=\"checked\"\n                [disabled]=\"disabled\"\n                (click)=\"clicked($event)\" />\n            <ng-content></ng-content>\n            <span *ngIf=\"error && errorMessage\" class=\"mbsc-err-msg\">{{errorMessage}}</span>\n        </label>\n    "
                },] },
    ];
    MbscRadio.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscRadioService, },
        { type: NgZone, },
    ]; };
    MbscRadio.propDecorators = {
        'value': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
    };
    return MbscRadio;
}(MbscFormBase));
var MbscSegmentedGroup = (function (_super) {
    __extends(MbscSegmentedGroup, _super);
    function MbscSegmentedGroup(hostElement, formService, _inputService, radioService, control, zone) {
        var _this = _super.call(this, hostElement, formService, _inputService, radioService, control, zone) || this;
        _this.select = 'single';
        return _this;
    }
    Object.defineProperty(MbscSegmentedGroup.prototype, "multiSelect", {
        get: function () {
            return this.select == 'multiple';
        },
        enumerable: true,
        configurable: true
    });
    MbscSegmentedGroup.prototype.ngOnInit = function () {
        _super.prototype.ngOnInit.call(this);
        this._radioService.multiSelect = this.multiSelect;
        if (this.color) {
            this._radioService.color = this.color;
        }
    };
    MbscSegmentedGroup.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-segmented-group',
                    template: "<div class=\"mbsc-segmented mbsc-segmented-group mbsc-no-touch\"><ng-content></ng-content></div>",
                    providers: [MbscRadioService]
                },] },
    ];
    MbscSegmentedGroup.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscRadioService, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: NgZone, },
    ]; };
    MbscSegmentedGroup.propDecorators = {
        'select': [{ type: Input$1 },],
    };
    return MbscSegmentedGroup;
}(MbscRadioGroupBase));
var MbscSegmented = (function (_super) {
    __extends(MbscSegmented, _super);
    function MbscSegmented(hostElement, formService, _radioService, zone) {
        var _this = _super.call(this, hostElement, formService, zone) || this;
        _this._radioService = _radioService;
        _this.checkedChange = new EventEmitter();
        var v = _this._radioService.getLastValue;
        if (v !== null) {
            _this.modelValue = v;
        }
        _this.valueObserver = _this._radioService.onValueChanged().subscribe(function (v) {
            _this.modelValue = v;
        });
        return _this;
    }
    Object.defineProperty(MbscSegmented.prototype, "isChecked", {
        get: function () {
            if (this.multiSelect) {
                if (this.checked !== undefined) {
                    return this.checked;
                }
                else {
                    return this.modelValue && this.modelValue.includes(this.value);
                }
            }
            else {
                return this.value == this.modelValue;
            }
        },
        enumerable: true,
        configurable: true
    });
    MbscSegmented.prototype.clicked = function (e) {
        if (this.multiSelect && this.checked !== undefined) {
            this.checkedChange.emit(!(!!this.checked));
        }
        else {
            if (this.multiSelect) {
                if (this.modelValue.includes(this.value)) {
                    var i = this.modelValue.indexOf(this.value);
                    this.modelValue.splice(i, 1);
                }
                else {
                    this.modelValue.push(this.value);
                }
                this._radioService.changeValue(this.modelValue);
            }
            else {
                this._radioService.changeValue(this.value);
            }
        }
    };
    Object.defineProperty(MbscSegmented.prototype, "cssClass", {
        get: function () {
            var cl = 'mbsc-segmented-item';
            if (this.color) {
                cl += ' mbsc-segmented-' + this.color;
            }
            return cl;
        },
        enumerable: true,
        configurable: true
    });
    MbscSegmented.prototype.initControl = function () {
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new SegmentedItem(this._initElem.nativeElement, options);
    };
    MbscSegmented.prototype.ngOnInit = function () {
        _super.prototype.ngOnInit.call(this);
        this.name = this._radioService.name;
        this.multiSelect = this._radioService.multiSelect;
        this.color = this._radioService.color;
    };
    MbscSegmented.prototype.ngOnDestroy = function () {
        this._radioService.onValueChanged().unsubscribe(this.valueObserver);
        _super.prototype.ngOnDestroy.call(this);
    };
    MbscSegmented.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-segmented',
                    host: { '[class]': 'cssClass' },
                    template: "\n        <label class=\"mbsc-segmented-item-ready\">\n            <input #initElement \n                data-role=\"segmented\"\n                [type]=\"multiSelect ? 'checkbox' : 'radio'\" \n                [value]=\"value\" \n                [checked]=\"isChecked\"\n                [disabled]=\"disabled\"\n                [attr.name]=\"name\" \n                [attr.value]=\"value\"\n                [attr.data-icon]=\"icon ? icon : null\"\n                (click)=\"clicked($event)\" />\n            <span class=\"mbsc-segmented-content\">\n                <span *ngIf=\"icon\" class=\"{{'mbsc-ic mbsc-ic-' + icon }}\"></span>\n                <ng-content></ng-content>\n            </span>\n        </label>\n    "
                },] },
    ];
    MbscSegmented.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscRadioService, },
        { type: NgZone, },
    ]; };
    MbscSegmented.propDecorators = {
        'icon': [{ type: Input$1 },],
        'value': [{ type: Input$1 },],
        'checked': [{ type: Input$1 },],
        'checkedChange': [{ type: Output },],
    };
    return MbscSegmented;
}(MbscFormBase));
var MbscSlider = (function (_super) {
    __extends(MbscSlider, _super);
    function MbscSlider(hostElement, _formService, zone, control) {
        var _this = _super.call(this, hostElement, zone, control, null, null) || this;
        _this._formService = _formService;
        _this._dummy = undefined;
        _this._needsTimeout = false;
        _this.disabled = false;
        _this._colorClass = {};
        _this.onChangeEmitter = new EventEmitter();
        return _this;
    }
    Object.defineProperty(MbscSlider.prototype, "isMulti", {
        get: function () {
            return this._lastValue instanceof Array;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscSlider.prototype, "dummyArray", {
        get: function () {
            if (!this._dummy || (this.isMulti && this._lastValue && this._lastValue.length && this._dummy.length !== this._lastValue.length)) {
                this._dummy = Array(this.isMulti ? this._lastValue.length : 1).fill(0).map(function (x, i) { return i; });
            }
            return this._dummy;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscSlider.prototype, "dataStepLabels", {
        get: function () {
            if (typeof (this.stepLabels) === 'string') {
                return this.stepLabels;
            }
            else {
                return null;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscSlider.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscSlider.prototype, "colorClass", {
        get: function () {
            for (var k in this._colorClass) {
                delete this._colorClass[k];
            }
            if (this.color) {
                this._colorClass['mbsc-slider-' + this.color] = true;
            }
            return this._colorClass;
        },
        enumerable: true,
        configurable: true
    });
    MbscSlider.prototype.reInitialize = function () {
        var _this = this;
        this.instance.destroy();
        this.setElement();
        this.inputElements.forEach(function (input, index) {
            if (index) {
                _this.handleChange(input.nativeElement);
            }
        });
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new Slider(this.inputElements.first.nativeElement, options);
    };
    MbscSlider.prototype.setNewValue = function (v) {
        var _this = this;
        this._lastValue = v;
        if (this.instance) {
            var innerValue = this.instance.getVal();
            if (this.isMulti && (!innerValue || innerValue.length != v.length)) {
                setTimeout(function () {
                    _this.reInitialize();
                    _this.instance.setVal(_this._lastValue, true, false);
                });
            }
            else {
                var changed = (this.isMulti && !deepEqualsArray(innerValue, v)) || (!this.isMulti && innerValue !== v);
                if (changed) {
                    this.instance.setVal(v, true, false);
                }
            }
        }
    };
    MbscSlider.prototype.ngOnInit = function () {
        this._inheritedOptions = this._formService ? this._formService.options : {};
        _super.prototype.ngOnInit.call(this);
    };
    MbscSlider.prototype.initControl = function () {
        var _this = this;
        this.inputElements.forEach(function (input, index) {
            if (index) {
                _this.handleChange(input.nativeElement);
            }
        });
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new Slider(this.inputElements.first.nativeElement, options);
        if (this.initialValue !== undefined && this.initialValue !== null) {
            this.instance.setVal(this.initialValue, true, false);
        }
    };
    MbscSlider.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-slider',
                    host: { 'class': 'mbsc-control-ng' },
                    template: "\n        <label [ngClass]=\"colorClass\">\n            <ng-content></ng-content>\n            <input #inputElements *ngFor=\"let v of dummyArray\" \n                type=\"range\"\n                [disabled]=\"disabled\"\n                [attr.value]=\"dummyArray.length > 1 && initialValue ? initialValue[v]: initialValue\"\n                [attr.data-step-labels]=\"dataStepLabels\"\n                [attr.data-template]=\"valueTemplate\"\n                [attr.data-tooltip]=\"tooltip ? 'true' : null\"\n                [attr.data-highlight]=\"highlight\"\n                [attr.data-live]=\"live\"\n                [attr.data-icon]=\"icon ? icon : null\"\n                [attr.data-val]=\"val ? val : null\"\n                [attr.data-label-style]=\"labelStyle\"\n                [attr.data-input-style]=\"inputStyle\"\n                [attr.name]=\"name\"\n                [attr.max]=\"max !== undefined ? max : null\"\n                [attr.min]=\"min !== undefined ? min : null\"\n                [attr.step]=\"step !== undefined ? step : null\"\n                (blur)=\"onTouch($event)\" />\n        </label>\n    ",
                    exportAs: 'mobiscroll'
                },] },
    ];
    MbscSlider.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
    ]; };
    MbscSlider.propDecorators = {
        'options': [{ type: Input$1, args: ['options',] },],
        'name': [{ type: Input$1 },],
        'tooltip': [{ type: Input$1 },],
        'highlight': [{ type: Input$1 },],
        'live': [{ type: Input$1 },],
        'valueTemplate': [{ type: Input$1, args: ['value-template',] },],
        'icon': [{ type: Input$1 },],
        'val': [{ type: Input$1 },],
        'max': [{ type: Input$1 },],
        'min': [{ type: Input$1 },],
        'step': [{ type: Input$1 },],
        'disabled': [{ type: Input$1 },],
        'stepLabels': [{ type: Input$1, args: ['step-labels',] },],
        'value': [{ type: Input$1, args: ['value',] },],
        'color': [{ type: Input$1 },],
        'onChangeEmitter': [{ type: Output, args: ['valueChange',] },],
        'inputElements': [{ type: ViewChildren, args: ['inputElements',] },],
    };
    return MbscSlider;
}(MbscControlBase));
var MbscRating = (function (_super) {
    __extends(MbscRating, _super);
    function MbscRating(hostElem, zone, formService, control) {
        var _this = _super.call(this, hostElem, zone, control, null, null) || this;
        _this.formService = formService;
        _this.min = undefined;
        _this.max = undefined;
        _this.step = undefined;
        _this.disabled = false;
        _this.val = undefined;
        _this.onChangeEmitter = new EventEmitter();
        _this._colorClass = {};
        return _this;
    }
    Object.defineProperty(MbscRating.prototype, "readonly", {
        set: function (val) {
            this._readonly = emptyOrTrue(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscRating.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscRating.prototype, "colorClass", {
        get: function () {
            for (var k in this._colorClass) {
                delete this._colorClass[k];
            }
            if (this.color) {
                this._colorClass['mbsc-rating-' + this.color] = true;
            }
            return this._colorClass;
        },
        enumerable: true,
        configurable: true
    });
    MbscRating.prototype.setNewValue = function (v) {
        if (this.instance) {
            if (this.instance.getVal() !== v) {
                this.instance.setVal(v, true, false);
            }
        }
    };
    MbscRating.prototype.ngOnInit = function () {
        this._inheritedOptions = this.formService ? this.formService.options : {};
        _super.prototype.ngOnInit.call(this);
    };
    MbscRating.prototype.initControl = function () {
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new Rating(this.element, options);
        if (this.initialValue !== undefined) {
            this.instance.setVal(this.initialValue, true, false);
        }
    };
    MbscRating.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-rating',
                    host: { 'class': 'mbsc-control-ng' },
                    template: "<label [ngClass]=\"colorClass\">\n        <ng-content></ng-content>\n        <input type=\"rating\" data-role=\"rating\" \n            [attr.name]=\"name\"\n            [attr.min]=\"min !== undefined ? min : null\"\n            [attr.max]=\"max !== undefined ? max : null\"\n            [attr.step]=\"step !== undefined ? step : null\"\n            [attr.data-val]=\"val ? val : null\"\n            [attr.data-template]=\"template ? template : null\"\n            [attr.data-empty]=\"empty\"\n            [attr.data-filled]=\"filled\"\n            [attr.data-label-style]=\"labelStyle\"\n            [attr.data-input-style]=\"inputStyle\"\n            [disabled]=\"disabled\"\n            [readonly]=\"_readonly\"\n            (blur)=\"onTouch($event)\" />\n    </label>"
                },] },
    ];
    MbscRating.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: NgControl, decorators: [{ type: Optional },] },
    ]; };
    MbscRating.propDecorators = {
        'options': [{ type: Input$1 },],
        'name': [{ type: Input$1 },],
        'min': [{ type: Input$1 },],
        'max': [{ type: Input$1 },],
        'step': [{ type: Input$1 },],
        'disabled': [{ type: Input$1 },],
        'empty': [{ type: Input$1 },],
        'filled': [{ type: Input$1 },],
        'readonly': [{ type: Input$1 },],
        'val': [{ type: Input$1 },],
        'template': [{ type: Input$1 },],
        'value': [{ type: Input$1, args: ['value',] },],
        'onChangeEmitter': [{ type: Output, args: ['valueChange',] },],
        'color': [{ type: Input$1 },],
    };
    return MbscRating;
}(MbscControlBase));
var MbscFormGroup = (function () {
    function MbscFormGroup(initialElem) {
        this.initialElem = initialElem;
        this.collapsible = null;
        this._open = false;
        this.instance = null;
        this.element = null;
        this.element = initialElem;
    }
    Object.defineProperty(MbscFormGroup.prototype, "open", {
        set: function (v) {
            if (this._open != v && this.instance) {
                if (v) {
                    this.instance.show();
                }
                else {
                    this.instance.hide();
                }
            }
            this._open = v;
        },
        enumerable: true,
        configurable: true
    });
    MbscFormGroup.prototype.emptyOrTrue = function (v) {
        return emptyOrTrue(v);
    };
    MbscFormGroup.prototype.ngAfterViewInit = function () {
        if (this.collapsible !== null) {
            this.instance = new CollapsibleBase(this.element.nativeElement, { isOpen: this._open !== false });
        }
    };
    MbscFormGroup.prototype.ngOnDestroy = function () {
        if (this.instance) {
            this.instance.destroy();
        }
    };
    MbscFormGroup.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-form-group',
                    template: '<ng-content></ng-content>',
                    host: {
                        '[class.mbsc-form-group-inset]': 'emptyOrTrue(inset)',
                        '[class.mbsc-form-group]': '!emptyOrTrue(inset)'
                    },
                    styles: [':host { display: block; }']
                },] },
    ];
    MbscFormGroup.ctorParameters = function () { return [
        { type: ElementRef, },
    ]; };
    MbscFormGroup.propDecorators = {
        'collapsible': [{ type: Input$1 },],
        'open': [{ type: Input$1 },],
        'inset': [{ type: Input$1 },],
    };
    return MbscFormGroup;
}());
var MbscFormGroupTitle = (function () {
    function MbscFormGroupTitle() {
    }
    MbscFormGroupTitle.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-form-group-title',
                    template: '<ng-content></ng-content>',
                    host: {
                        '[class.mbsc-form-group-title]': 'true'
                    },
                    styles: [':host { display: block; }']
                },] },
    ];
    MbscFormGroupTitle.ctorParameters = function () { return []; };
    return MbscFormGroupTitle;
}());
var MbscFormGroupContent = (function () {
    function MbscFormGroupContent() {
    }
    MbscFormGroupContent.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-form-group-content',
                    template: '<ng-content></ng-content>',
                    host: {
                        '[class.mbsc-form-group-content]': 'true'
                    },
                    styles: [':host { display: block; }']
                },] },
    ];
    MbscFormGroupContent.ctorParameters = function () { return []; };
    return MbscFormGroupContent;
}());
var MbscAccordion = (function () {
    function MbscAccordion() {
    }
    MbscAccordion.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-accordion',
                    template: '<ng-content></ng-content>',
                    host: {
                        '[class.mbsc-accordion]': 'true'
                    },
                    styles: [':host { display: block; }']
                },] },
    ];
    MbscAccordion.ctorParameters = function () { return []; };
    return MbscAccordion;
}());
var comp = [
    MbscForm,
    MbscTextarea,
    MbscDropdown,
    MbscButton,
    MbscCheckbox,
    MbscSwitch,
    MbscStepper,
    MbscProgress,
    MbscRadioGroup,
    MbscRadioGroupBase,
    MbscRadio,
    MbscSegmentedGroup,
    MbscSegmented,
    MbscSlider,
    MbscRating,
    MbscFormGroup,
    MbscFormGroupTitle,
    MbscFormGroupContent,
    MbscAccordion
];
var MbscFormsModule = (function () {
    function MbscFormsModule() {
    }
    MbscFormsModule.decorators = [
        { type: NgModule, args: [{
                    imports: [FormsModule, CommonModule, MbscBaseModule, MbscInputModule],
                    declarations: comp,
                    exports: [comp, MbscInputModule, MbscInput]
                },] },
    ];
    MbscFormsModule.ctorParameters = function () { return []; };
    return MbscFormsModule;
}());

// ---

var Page = function Page(el, settings) {
  var cssClass = '',
      $elm = $$1(el),
      that = this,
      s = that.settings; // Call the parent constructor

  Base.call(this, el, settings, true);
  /**
   * Page initialization.
   */

  that._init = function () {
    var ctx = s.context,
        $ctx = $$1(ctx),
        $topMenu = $ctx.find('.mbsc-ms-top .mbsc-ms'),
        $bottomMenu = $ctx.find('.mbsc-ms-bottom .mbsc-ms'),
        css = {};

    if (ctx == 'body') {
      $$1('body,html').addClass('mbsc-page-ctx');
    } else {
      $ctx.addClass('mbsc-page-ctx');
    }

    if (cssClass) {
      $elm.removeClass(cssClass);
    }

    if ($topMenu.length) {
      css.paddingTop = $topMenu[0].offsetHeight;
    }

    if ($bottomMenu.length) {
      css.paddingBottom = $bottomMenu[0].offsetHeight;
    }

    cssClass = 'mbsc-page mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : '') + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr');
    $elm.addClass(cssClass).removeClass('mbsc-cloak').css(css);
  };
  /**
   * Destroys the mobiscroll instance.
   */


  that._destroy = function () {
    $elm.removeClass(cssClass);
  }; // Constructor


  s = that.settings;
  that.init();
}; // Extend defaults

Page.prototype = {
  _hasDef: true,
  _hasTheme: true,
  _hasLang: true,
  _class: 'page',
  _defaults: {
    context: 'body'
  }
};
classes.Page = Page;
mobiscroll.themes.page.mobiscroll = {}; // ---
// Page end
// Init mbsc-page elements on page load or when mbsc-enhance event is triggeres

autoInit('[mbsc-page]', Page);

var MbscPage = (function (_super) {
    __extends(MbscPage, _super);
    function MbscPage(hostElement, optionsService, zone) {
        var _this = _super.call(this, hostElement, zone) || this;
        _this.optionsService = optionsService;
        return _this;
    }
    MbscPage.prototype.ngOnInit = function () {
        var optionsObj = extend$1({}, this.options, this.inlineOptionsObj);
        this.optionsService.options = optionsObj;
    };
    MbscPage.prototype.initControl = function () {
        var options = extend$1({}, this.options, this.inlineOptionsObj);
        this.instance = new Page(this.initElem.nativeElement, options);
    };
    MbscPage.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-page',
                    template: '<div #initElement><ng-content></ng-content></div>',
                    providers: [MbscOptionsService],
                    exportAs: 'mobiscroll'
                },] },
    ];
    MbscPage.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, },
        { type: NgZone, },
    ]; };
    MbscPage.propDecorators = {
        'options': [{ type: Input$1 },],
        'context': [{ type: Input$1 },],
        'initElem': [{ type: ViewChild, args: ['initElement', { static: false },] },],
    };
    return MbscPage;
}(MbscBase));
var MbscNote = (function () {
    function MbscNote(initialElem) {
        this.initialElem = initialElem;
        this.color = 'primary';
    }
    Object.defineProperty(MbscNote.prototype, "classNames", {
        get: function () {
            return 'mbsc-note mbsc-note-' + this.color;
        },
        enumerable: true,
        configurable: true
    });
    MbscNote.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-note',
                    template: '<ng-content></ng-content>',
                    host: {
                        '[class]': 'classNames'
                    },
                    styles: [':host { display: block; }']
                },] },
    ];
    MbscNote.ctorParameters = function () { return [
        { type: ElementRef, },
    ]; };
    MbscNote.propDecorators = {
        'color': [{ type: Input$1 },],
    };
    return MbscNote;
}());
var MbscAvatar = (function () {
    function MbscAvatar() {
        this.draggable = false;
    }
    MbscAvatar.decorators = [
        { type: Component, args: [{
                    selector: 'mbsc-avatar',
                    template: '<img class="mbsc-avatar" [src]="src" [alt]="alt" [draggable]="draggable" />'
                },] },
    ];
    MbscAvatar.ctorParameters = function () { return []; };
    MbscAvatar.propDecorators = {
        'draggable': [{ type: Input$1 },],
        'src': [{ type: Input$1 },],
        'alt': [{ type: Input$1 },],
    };
    return MbscAvatar;
}());
var MbscPageModule = (function () {
    function MbscPageModule() {
    }
    MbscPageModule.decorators = [
        { type: NgModule, args: [{
                    imports: [MbscBaseModule],
                    declarations: [MbscPage, MbscNote, MbscAvatar],
                    exports: [MbscPage, MbscNote, MbscAvatar]
                },] },
    ];
    MbscPageModule.ctorParameters = function () { return []; };
    return MbscPageModule;
}());

var MbscCommercialComponent = function (_super) {
  __extends(MbscCommercialComponent, _super);

  function MbscCommercialComponent(hostElement, optionsService, zone) {
    var _this = _super.call(this, hostElement, zone) || this;

    _this.optionsService = optionsService;
    _this.mbscOptions = {};
    _this.options = {};
    return _this;
  }

  MbscCommercialComponent.prototype.ngAfterViewInit = function () {
    if (!mobiscroll.alerted) {
      mobiscroll.confirm({
        title: 'Mobiscroll Lite doesn\'t support this functionality.',
        message: 'You can try the full toolset with a free trial. If you\'re having trouble, <a href="mailto:support@mobiscroll.com" target="_top">let us know</a>.',
        okText: 'Start Trial',
        cancelText: 'Ok',
        callback: function callback(startTrial) {
          if (startTrial) {
            window.open("//mobiscroll.com/", '_blank');
          }
        }
      });
      mobiscroll.alerted = true;
    }
  };

  MbscCommercialComponent.decorators = [{
    type: Component,
    args: [{
      selector: "\n    mbsc-calendar, [mbsc-calendar],\n    mbsc-date, [mbsc-date],\n    mbsc-time, [mbsc-time],\n    mbsc-datetime, [mbsc-datetime],\n    mbsc-eventcalendar, [mbsc-eventcalendar],\n    mbsc-card, [mbsc-card], mbsc-card-header, mbsc-card-content, mbsc-card-footer, mbsc-card-title, mbsc-card-subtitle,\n    mbsc-color, [mbsc-color],\n    mbsc-image, [mbsc-image],\n    mbsc-listview, mbsc-listview-item, mbsc-listview-header, mbsc-listview-sublist,\n    mbsc-measurement, [mbsc-measurement], mbsc-temperature, [mbsc-temperature], mbsc-distance, [mbsc-distance], mbsc-speed, [mbsc-speed], mbsc-force, [mbsc-force], mbsc-mass, [mbsc-mass],\n    mbsc-nav-item, mbsc-bottom-nav, mbsc-hamburger-nav, mbsc-tab-nav,\n    mbsc-number, [mbsc-number],\n    mbsc-numpad, [mbsc-numpad], mbsc-numpad-decimal, [mbsc-numpad-decimal], mbsc-numpad-date, [mbsc-numpad-date], mbsc-numpad-time, [mbsc-numpad-time], mbsc-numpad-timespan, [mbsc-numpad-timespan],\n    mbsc-optionlist, mbsc-option-item,\n    mbsc-range, [mbsc-range],\n    mbsc-scroller, [mbsc-scroller],\n    mbsc-scrollview, [mbsc-scrollview], mbsc-scrollview-item, [mbsc-scrollview-item],\n    mbsc-select, [mbsc-select],\n    mbsc-timer, [mbsc-timer],\n    mbsc-timespan, [mbsc-timespan],\n    mbsc-treelist, [mbsc-treelist],\n    mbsc-widget\n    ",
      template: '<ng-content></ng-content>',
      exportAs: 'mobiscroll',
      styles: [':host { display: block }']
    }]
  }];

  MbscCommercialComponent.ctorParameters = function () {
    return [{
      type: ElementRef
    }, {
      type: MbscOptionsService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: NgZone
    }];
  };

  MbscCommercialComponent.propDecorators = {
    'mbscOptions': [{
      type: Input$1,
      args: ['mbsc-options']
    }],
    'options': [{
      type: Input$1
    }],
    'data': [{
      type: Input$1
    }],
    'mbscData': [{
      type: Input$1,
      args: ['mbsc-data']
    }],
    'initElem': [{
      type: ViewChild,
      args: ['initElement', {
        static: false
      }]
    }]
  };
  return MbscCommercialComponent;
}(MbscBase);

var directives = [MbscForm, MbscRating, MbscPage, MbscNote, MbscAvatar, MbscInput, MbscDropdown, MbscTextarea, MbscButton, MbscCheckbox, MbscSwitch, MbscStepper, MbscProgress, MbscSlider, MbscRadio, MbscRadioGroup, MbscSegmentedGroup, MbscSegmented, MbscCommercialComponent, MbscFormGroup, MbscFormGroupTitle, MbscFormGroupContent];

var MbscModule = function () {
  function MbscModule() {}

  MbscModule.decorators = [{
    type: NgModule,
    args: [{
      imports: [FormsModule, CommonModule, MbscFormsModule, MbscPageModule],
      declarations: [MbscCommercialComponent],
      exports: [directives, MbscCommercialComponent, MbscFormsModule, MbscPageModule]
    }]
  }];

  MbscModule.ctorParameters = function () {
    return [];
  };

  return MbscModule;
}();

// Arabic
mobiscroll.i18n.ar = {
  // Core
  rtl: true,
  // Right to left mode
  setText: '',
  cancelText: '',
  clearText: '',
  selectedText: '{count} ',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['', '', '', '', '', '', ''],
  dayNamesShort: ['', '', '', '', '', '', ''],
  dayNamesMin: ['', '', '', '', '', '', ''],
  dayText: '',
  hourText: '',
  minuteText: '',
  monthNames: ['', '', '', '', '', '', '', '', '', '', '', ''],
  monthNamesShort: ['', '', '', '', '', '', '', '', '', '', '', ''],
  monthText: '',
  secText: '',
  amText: '',
  pmText: '',
  timeFormat: 'hh:ii A',
  yearText: '',
  nowText: '',
  // Calendar component
  firstDay: 0,
  dateText: '',
  timeText: '',
  closeText: '',
  todayText: '',
  prevMonthText: ' ',
  nextMonthText: ' ',
  prevYearText: ' ',
  nextYearText: ' ',
  allDayText: ' ',
  noEventsText: '  ',
  // Event calendar
  eventText: '',
  eventsText: '',
  moreEventsText: ' ',
  moreEventsPluralText: '  {count}',
  // Daterange component
  fromText: '',
  toText: '',
  // Measurement components
  wholeText: '',
  fractionText: '',
  unitText: '',
  // Numpad date
  delimiter: '/',
  // Numpad decimal
  decimalSeparator: '.',
  thousandsSeparator: ',',
  // Timer / Timespan component
  labels: ['', '', '', '', '', '', ''],
  labelsShort: ['', '', '', '', '', '', ''],
  // Timer component
  startText: '',
  stopText: '',
  resetText: ' ',
  lapText: '',
  hideText: '',
  // Forms
  offText: '',
  onText: '',
  // Listview
  backText: '',
  undoText: ''
};

// Bulgarian
mobiscroll.i18n.bg = {
  // Core
  setText: '',
  cancelText: '',
  clearText: '',
  selectedText: '{count} ',
  // Datetime component
  dateFormat: 'dd.mm.yy',
  dayNames: ['', '', '', '', '', '', ''],
  dayNamesShort: ['', '', '', '', '', '', ''],
  dayNamesMin: ['', '', '', '', '', '', ''],
  dayText: '',
  delimiter: '.',
  hourText: '',
  minuteText: '',
  monthNames: ['', '', '', '', '', '', '', '', '', '', '', ''],
  monthNamesShort: ['', '', '', '', '', '', '', '', '', '', '', ''],
  monthText: '',
  secText: '',
  timeFormat: 'H:ii',
  yearText: '',
  nowText: '',
  pmText: 'pm',
  amText: 'am',
  // Calendar component
  firstDay: 1,
  dateText: '',
  timeText: '',
  todayText: '',
  prevMonthText: ' ',
  nextMonthText: ' ',
  prevYearText: ' ',
  nextYearText: ' ',
  closeText: '',
  eventText: '',
  eventsText: '',
  allDayText: ' ',
  noEventsText: ' ',
  moreEventsText: ' {count}',
  // Daterange component
  fromText: '',
  toText: '',
  // Measurement components
  wholeText: '',
  fractionText: '',
  unitText: '',
  // Time / Timespan component
  labels: ['', '', '', '', '', '', ''],
  labelsShort: ['', '', '', '', '', '', ''],
  // Timer component
  startText: '',
  stopText: '',
  resetText: '',
  lapText: '',
  hideText: '',
  // Listview
  backText: '',
  undoText: '',
  // Form
  offText: '',
  onText: '',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Catal
mobiscroll.i18n.ca = {
  // Core
  setText: 'Acceptar',
  cancelText: 'Cancellar',
  clearText: 'Esborrar',
  selectedText: '{count} seleccionat',
  selectedPluralText: '{count} seleccionats',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['Diumenge', 'Dilluns', 'Dimarts', 'Dimecres', 'Dijous', 'Divendres', 'Dissabte'],
  dayNamesShort: ['Dg', 'Dl', 'Dt', 'Dc', 'Dj', 'Dv', 'Ds'],
  dayNamesMin: ['Dg', 'Dl', 'Dt', 'Dc', 'Dj', 'Dv', 'Ds'],
  dayText: 'Dia',
  hourText: 'Hores',
  minuteText: 'Minuts',
  monthNames: ['Gener', 'Febrer', 'Mar', 'Abril', 'Maig', 'Juny', 'Juliol', 'Agost', 'Setembre', 'Octubre', 'Novembre', 'Desembre'],
  monthNamesShort: ['Gen', 'Feb', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Oct', 'Nov', 'Des'],
  monthText: 'Mes',
  secText: 'Segons',
  timeFormat: 'HH:ii',
  yearText: 'Any',
  nowText: 'Ara',
  pmText: 'pm',
  amText: 'am',
  todayText: 'Avui',
  // Calendar component
  firstDay: 1,
  dateText: 'Data',
  timeText: 'Temps',
  closeText: 'Tancar',
  allDayText: 'Tot el dia',
  noEventsText: 'Cap esdeveniment',
  eventText: 'Esdeveniments',
  eventsText: 'Esdeveniments',
  moreEventsText: '{count} ms',
  // Daterange component
  fromText: 'Iniciar',
  toText: 'Final',
  // Measurement components
  wholeText: 'Sencer',
  fractionText: 'Fracci',
  unitText: 'Unitat',
  // Time / Timespan component
  labels: ['Anys', 'Mesos', 'Dies', 'Hores', 'Minuts', 'Segons', ''],
  labelsShort: ['Anys', 'Mesos', 'Dies', 'Hrs', 'Mins', 'Secs', ''],
  // Timer component
  startText: 'Iniciar',
  stopText: 'Aturar',
  resetText: 'Reiniciar',
  lapText: 'Volta',
  hideText: 'Amagar',
  // Listview
  backText: 'Enrere',
  undoText: 'Desfs',
  // Form
  offText: 'No',
  onText: 'Si'
};

// Cestina
mobiscroll.i18n.cs = {
  // Core
  setText: 'Zadej',
  cancelText: 'Storno',
  clearText: 'Vymazat',
  selectedText: 'Oznaen: {count}',
  // Datetime component
  dateFormat: 'dd.mm.yy',
  dayNames: ['Nedle', 'Pondl', 'ter', 'Steda', 'tvrtek', 'Ptek', 'Sobota'],
  dayNamesShort: ['Ne', 'Po', 't', 'St', 't', 'P', 'So'],
  dayNamesMin: ['N', 'P', '', 'S', '', 'P', 'S'],
  dayText: 'Den',
  hourText: 'Hodiny',
  minuteText: 'Minuty',
  monthNames: ['Leden', 'nor', 'Bezen', 'Duben', 'Kvten', 'erven', 'ervenec', 'Srpen', 'Z', 'jen', 'Listopad', 'Prosinec'],
  monthNamesShort: ['Led', 'no', 'Be', 'Dub', 'Kv', 'er', 'vc', 'Spr', 'Z', 'j', 'Lis', 'Pro'],
  monthText: 'Msc',
  secText: 'Sekundy',
  timeFormat: 'HH:ii',
  yearText: 'Rok',
  nowText: 'Te',
  amText: 'am',
  pmText: 'pm',
  todayText: 'Dnes',
  // Calendar component
  firstDay: 1,
  dateText: 'Datum',
  timeText: 'as',
  closeText: 'Zavt',
  allDayText: 'Cel den',
  noEventsText: 'dn udlosti',
  eventText: 'Udlost',
  eventsText: 'Udlosti',
  moreEventsText: '{count} dal',
  // Daterange component
  fromText: 'Zatek',
  toText: 'Konec',
  // Measurement components
  wholeText: 'Cel',
  fractionText: 'st',
  unitText: 'Jednotka',
  // Time / Timespan component
  labels: ['Roky', 'Msce', 'Dny', 'Hodiny', 'Minuty', 'Sekundy', ''],
  labelsShort: ['Rok', 'Ms', 'Dny', 'Hod', 'Min', 'Sec', ''],
  // Timer component
  startText: 'Start',
  stopText: 'Stop',
  resetText: 'Resetovat',
  lapText: 'Etapa',
  hideText: 'Schovat',
  // Listview
  backText: 'Zpt',
  undoText: 'Zpt',
  // Form
  offText: 'O',
  onText: 'I',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Dansk
mobiscroll.i18n.da = {
  // Core
  setText: 'St',
  cancelText: 'Annuller',
  clearText: 'Ryd',
  selectedText: '{count} valgt',
  selectedPluralText: '{count} valgt',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['Sndag', 'Mandag', 'Tirsdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lrdag'],
  dayNamesShort: ['Sn', 'Man', 'Tir', 'Ons', 'Tor', 'Fre', 'Lr'],
  dayNamesMin: ['S', 'M', 'T', 'O', 'T', 'F', 'L'],
  dayText: 'Dag',
  hourText: 'Timer',
  minuteText: 'Minutter',
  monthNames: ['Januar', 'Februar', 'Marts', 'April', 'Maj', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'December'],
  monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'Maj', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dec'],
  monthText: 'Mned',
  secText: 'Sekunder',
  amText: 'am',
  pmText: 'pm',
  timeFormat: 'HH.ii',
  yearText: 'r',
  nowText: 'Nu',
  todayText: 'I dag',
  // Calendar component
  firstDay: 1,
  dateText: 'Dato',
  timeText: 'Tid',
  closeText: 'Luk',
  allDayText: 'Hele dagen',
  noEventsText: 'Ingen begivenheder',
  eventText: 'Begivenheder',
  eventsText: 'Begivenheder',
  moreEventsText: '{count} mere',
  // Daterange component
  fromText: 'Start',
  toText: 'Slut',
  // Measurement components
  wholeText: 'Hele',
  fractionText: 'Dele',
  unitText: 'Enhed',
  // Time / Timespan component
  labels: ['r', 'Mneder', 'Dage', 'Timer', 'Minutter', 'Sekunder', ''],
  labelsShort: ['r', 'Mdr', 'Dg', 'Timer', 'Min', 'Sek', ''],
  // Timer component
  startText: 'Start',
  stopText: 'Stop',
  resetText: 'Nulstil',
  lapText: 'Omgang',
  hideText: 'Skjul',
  // Forms
  offText: 'Fra',
  onText: 'Til',
  // Listview
  backText: 'Tilbage',
  undoText: 'Fortryd'
};

// Deutsch
mobiscroll.i18n.de = {
  // Core
  setText: 'OK',
  cancelText: 'Abbrechen',
  clearText: 'Lschen',
  selectedText: '{count} ausgewhlt',
  // Datetime component
  dateFormat: 'dd.mm.yy',
  dayNames: ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'],
  dayNamesShort: ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
  dayNamesMin: ['S', 'M', 'D', 'M', 'D', 'F', 'S'],
  dayText: 'Tag',
  delimiter: '.',
  hourText: 'Stunde',
  minuteText: 'Minuten',
  monthNames: ['Januar', 'Februar', 'Mrz', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],
  monthNamesShort: ['Jan', 'Feb', 'Mr', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'],
  monthText: 'Monat',
  secText: 'Sekunden',
  timeFormat: 'HH:ii',
  yearText: 'Jahr',
  nowText: 'Jetzt',
  pmText: 'pm',
  amText: 'am',
  todayText: 'Heute',
  // Calendar component
  firstDay: 1,
  dateText: 'Datum',
  timeText: 'Zeit',
  closeText: 'Schlieen',
  allDayText: 'Ganztgig',
  noEventsText: 'Keine Ereignisse',
  eventText: 'Ereignis',
  eventsText: 'Ereignisse',
  moreEventsText: '{count} weiteres Element',
  moreEventsPluralText: '{count} weitere Elemente',
  // Daterange component
  fromText: 'Von',
  toText: 'Bis',
  // Measurement components
  wholeText: 'Ganze Zahl',
  fractionText: 'Bruchzahl',
  unitText: 'Maeinheit',
  // Time / Timespan component
  labels: ['Jahre', 'Monate', 'Tage', 'Stunden', 'Minuten', 'Sekunden', ''],
  labelsShort: ['Jahr.', 'Mon.', 'Tag.', 'Std.', 'Min.', 'Sek.', ''],
  // Timer component
  startText: 'Starten',
  stopText: 'Stoppen',
  resetText: 'Zurcksetzen',
  lapText: 'Lap',
  hideText: 'Ausblenden',
  // Listview
  backText: 'Zurck',
  undoText: 'Rckgngig machen',
  // Form
  offText: 'Aus',
  onText: 'Ein',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Greek
mobiscroll.i18n.el = {
  // Core
  setText: '',
  cancelText: '',
  clearText: '',
  selectedText: '{count} ',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['', '', '', '', '', '', ''],
  dayNamesShort: ['', '', '', '', '', '', ''],
  dayNamesMin: ['', '', '', '', '', '', ''],
  dayText: '',
  delimiter: '/',
  hourText: '',
  minuteText: '',
  monthNames: ['', '', '', '', '', '', '', '', '', '', '', ''],
  monthNamesShort: ['', '', '', '', '', '', '', '', '', '', '', ''],
  monthText: '',
  secText: '',
  timeFormat: 'H:ii',
  yearText: '',
  nowText: '',
  pmText: '',
  amText: '',
  // Calendar component
  firstDay: 1,
  dateText: '',
  timeText: '',
  todayText: '',
  prevMonthText: ' ',
  nextMonthText: ' ',
  prevYearText: ' ',
  nextYearText: ' ',
  closeText: '',
  eventText: '',
  eventsText: '',
  allDayText: '',
  noEventsText: '  ',
  moreEventsText: '{count} ',
  // Daterange component
  fromText: '',
  toText: '',
  // Measurement components
  wholeText: '',
  fractionText: '',
  unitText: '',
  // Time / Timespan component
  labels: ['', '', '', '', '', '', ''],
  labelsShort: ['', '', '', '', '', '', ''],
  // Timer component
  startText: '',
  stopText: '',
  resetText: '',
  lapText: '',
  hideText: '',
  // Listview
  backText: '',
  undoText: '',
  // Form
  offText: '',
  onText: '',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// English (UK)
mobiscroll.i18n['en-GB'] = mobiscroll.i18n['en-UK'] = {
  dateFormat: 'dd/mm/yy',
  timeFormat: 'HH:ii'
};

// Espaol
mobiscroll.i18n.es = {
  // Core
  setText: 'Aceptar',
  cancelText: 'Cancelar',
  clearText: 'Borrar',
  selectedText: '{count} seleccionado',
  selectedPluralText: '{count} seleccionados',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['Domingo', 'Lunes', 'Martes', 'Mircoles', 'Jueves', 'Viernes', 'Sbado'],
  dayNamesShort: ['Do', 'Lu', 'Ma', 'Mi', 'Ju', 'Vi', 'S'],
  dayNamesMin: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
  dayText: 'Da',
  hourText: 'Horas',
  minuteText: 'Minutos',
  monthNames: ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'],
  monthNamesShort: ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'],
  monthText: 'Mes',
  secText: 'Segundos',
  timeFormat: 'HH:ii',
  yearText: 'A&ntilde;o',
  nowText: 'Ahora',
  pmText: 'pm',
  amText: 'am',
  todayText: 'Hoy',
  // Calendar component
  firstDay: 1,
  dateText: 'Fecha',
  timeText: 'Tiempo',
  closeText: 'Cerrar',
  allDayText: 'Todo el da',
  noEventsText: 'No hay eventos',
  eventText: 'Evento',
  eventsText: 'Eventos',
  moreEventsText: '{count} ms',
  // Daterange component
  fromText: 'Iniciar',
  toText: 'Final',
  // Measurement components
  wholeText: 'Entero',
  fractionText: 'Fraccin',
  unitText: 'Unidad',
  // Time / Timespan component
  labels: ['Aos', 'Meses', 'Das', 'Horas', 'Minutos', 'Segundos', ''],
  labelsShort: ['Ao', 'Mes', 'Da', 'Hora', 'Min', 'Seg', ''],
  // Timer component
  startText: 'Iniciar',
  stopText: 'Detngase',
  resetText: 'Reinicializar',
  lapText: 'Lap',
  hideText: 'Esconder',
  // Listview
  backText: 'Atrs',
  undoText: 'Deshacer',
  // Form
  offText: 'No',
  onText: 'S',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// 
mobiscroll.i18n.fa = {
  // Core
  setText: '',
  cancelText: '',
  clearText: ' ',
  selectedText: '{count} ',
  // Datetime component
  calendarSystem: 'jalali',
  dateFormat: 'yy/mm/dd',
  dayNames: ['', '', '', '', '', '', ''],
  dayNamesShort: ['', '', '', '', '', '', ''],
  dayNamesMin: ['', '', '', '', '', '', ''],
  dayText: '',
  hourText: '',
  minuteText: '',
  monthNames: ['', '', '', '', '', '', '', '', '', '', '', ''],
  monthNamesShort: ['', '', '', '', '', '', '', '', '', '', '', ''],
  monthText: '',
  secText: '',
  timeFormat: 'HH:ii',
  timeWheels: 'iiHH',
  // Need this for correct RTL display
  yearText: '',
  nowText: '',
  amText: '',
  pmText: '',
  todayText: '',
  //getNumber: function (n) {
  //    var i,
  //        nums = ["", "", "", "", "", "", "", "", "", ""],
  //        res = '';
  //    n = n + '';
  //    for (i = 0; i < n.length; i++) {
  //        res += nums[+n[i]];
  //    }
  //    return res;
  //},
  // Calendar component
  firstDay: 6,
  rtl: true,
  dateText: ' ',
  timeText: ' ',
  closeText: '',
  allDayText: ' ',
  noEventsText: ' ',
  eventText: '',
  eventsText: '',
  moreEventsText: '{count}  ',
  // Daterange component
  fromText: ' ',
  toText: '',
  // Measurement components
  wholeText: '',
  fractionText: '',
  unitText: '',
  // Time / Timespan component
  labels: ['', '', '', '', '', '', ''],
  labelsShort: ['', '', '', '', '', '', ''],
  // Timer component
  startText: '',
  stopText: '',
  resetText: ' ',
  lapText: 'Lap',
  hideText: ' ',
  // Listview
  backText: '',
  undoText: ''
};

// Suomi
mobiscroll.i18n.fi = {
  // Core
  setText: 'Aseta',
  cancelText: 'Peruuta',
  clearText: 'Tyhjenn',
  selectedText: '{count} valita',
  // Datetime component
  dateFormat: 'd. MM yy',
  dayNames: ['Sunnuntai', 'Maanantai', 'Tiistai', 'Keskiviiko', 'Torstai', 'Perjantai', 'Lauantai'],
  dayNamesShort: ['Su', 'Ma', 'Ti', 'Ke', 'To', 'Pe', 'La'],
  dayNamesMin: ['S', 'M', 'T', 'K', 'T', 'P', 'L'],
  dayText: 'Piv',
  delimiter: '.',
  hourText: 'Tuntia',
  minuteText: 'Minuutti',
  monthNames: ['Tammikuu', 'Helmikuu', 'Maaliskuu', 'Huhtikuu', 'Toukokuu', 'Keskuu', 'Heinkuu', 'Elokuu', 'Syyskuu', 'Lokakuu', 'Marraskuu', 'Joulukuu'],
  monthNamesShort: ['Tam', 'Hel', 'Maa', 'Huh', 'Tou', 'Kes', 'Hei', 'Elo', 'Syy', 'Lok', 'Mar', 'Jou'],
  monthText: 'Kuukausi',
  secText: 'Sekunda',
  timeFormat: 'H:ii',
  yearText: 'Vuosi',
  nowText: 'Nyt',
  pmText: 'pm',
  amText: 'am',
  // Calendar component
  firstDay: 1,
  dateText: 'Pivys',
  timeText: 'Aika',
  todayText: 'Tnn',
  prevMonthText: 'Edellinen kuukausi',
  nextMonthText: 'Ensi kuussa',
  prevYearText: 'Edellinen vuosi',
  nextYearText: 'Ensi vuosi',
  closeText: 'Sulje',
  eventText: 'Tapahtumia',
  eventsText: 'Tapahtumia',
  allDayText: 'Koko piv',
  noEventsText: 'Ei tapahtumia',
  moreEventsText: '{count} muu',
  moreEventsPluralText: '{count} muuta',
  // Daterange component
  fromText: 'Alkaa',
  toText: 'Pttyy',
  // Measurement components
  wholeText: 'Kokonainen',
  fractionText: 'Murtoluku',
  unitText: 'Yksikk',
  // Time / Timespan component
  labels: ['Vuosi', 'Kuukausi', 'Piv', 'Tunnin', 'Minuutti', 'sekuntia', ''],
  labelsShort: ['Vuo', 'Kuu', 'Pi', 'Tun', 'Min', 'Sek', ''],
  // Timer component
  startText: 'Kynnistys',
  stopText: 'Seis',
  resetText: 'Aseta uudelleen',
  lapText: 'Kierros',
  hideText: 'Vuota',
  // Listview
  backText: 'Edellinen',
  undoText: 'Kumoa',
  // Form
  offText: 'Pois',
  onText: 'Pll',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Franais
mobiscroll.i18n.fr = {
  // Core
  setText: 'Terminer',
  cancelText: 'Annuler',
  clearText: 'Effacer',
  selectedText: '{count} slectionn',
  selectedPluralText: '{count} slectionns',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'],
  dayNamesShort: ['Dim.', 'Lun.', 'Mar.', 'Mer.', 'Jeu.', 'Ven.', 'Sam.'],
  dayNamesMin: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
  dayText: 'Jour',
  monthText: 'Mois',
  monthNames: ['Janvier', 'Fvrier', 'Mars', 'Avril', 'Mai', 'Juin', 'Juillet', 'Aot', 'Septembre', 'Octobre', 'Novembre', 'Dcembre'],
  monthNamesShort: ['Janv.', 'Fvr.', 'Mars', 'Avril', 'Mai', 'Juin', 'Juil.', 'Aot', 'Sept.', 'Oct.', 'Nov.', 'Dc.'],
  hourText: 'Heures',
  minuteText: 'Minutes',
  secText: 'Secondes',
  timeFormat: 'HH:ii',
  yearText: 'Anne',
  nowText: 'Maintenant',
  pmText: 'pm',
  amText: 'am',
  todayText: "Aujourd'hui",
  // Calendar component
  firstDay: 1,
  dateText: 'Date',
  timeText: 'Heure',
  closeText: 'Fermer',
  allDayText: 'Toute la journe',
  noEventsText: 'Aucun vnement',
  eventText: 'vnement',
  eventsText: 'vnements',
  moreEventsText: '{count} autre',
  moreEventsPluralText: '{count} autres',
  // Daterange component
  fromText: 'Dmarrer',
  toText: 'Fin',
  // Measurement components
  wholeText: 'Entier',
  fractionText: 'Fraction',
  unitText: 'Unit',
  // Time / Timespan component
  labels: ['Ans', 'Mois', 'Jours', 'Heures', 'Minutes', 'Secondes', ''],
  labelsShort: ['Ans', 'Mois', 'Jours', 'Hrs', 'Min', 'Sec', ''],
  // Timer component
  startText: 'Dmarrer',
  stopText: 'Arrter',
  resetText: 'Rinitialiser',
  lapText: 'Lap',
  hideText: 'Cachez',
  // Listview
  backText: 'Retour',
  undoText: 'Annuler',
  // Form
  offText: 'Non',
  onText: 'Oui',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Hebrew
mobiscroll.i18n.he = {
  // Core
  rtl: true,
  // Right to left mode
  setText: '',
  cancelText: '',
  clearText: '',
  selectedText: '{count} ',
  selectedPluralText: '{count} ',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['', '', '', '', '', '', ''],
  dayNamesShort: ["'", "'", "'", "'", "'", "'", "'"],
  dayNamesMin: ['', '', '', '', '', '', ''],
  dayText: '',
  hourText: '',
  minuteText: '',
  monthNames: ['', '', '', '', '', '', '', '', '', '', '', ''],
  monthNamesShort: ["", "", "", "", "", "", "", "", "", "", "", ""],
  monthText: '',
  secText: '',
  amText: 'am',
  pmText: 'pm',
  timeFormat: 'HH:ii',
  timeWheels: 'iiHH',
  // Need this for correct RTL display
  yearText: '',
  nowText: '',
  // Calendar component
  firstDay: 0,
  dateText: '',
  timeText: '',
  closeText: '',
  todayText: '',
  allDayText: ' ',
  noEventsText: ' ',
  // Event calendar
  eventText: '',
  eventsText: '',
  moreEventsText: '  ',
  moreEventsPluralText: '{count}  ',
  // Daterange component
  fromText: '',
  toText: '',
  // Measurement components
  wholeText: '',
  fractionText: '',
  unitText: '',
  // Time / Timespan component
  labels: ['', '', '', '', '', '', ''],
  labelsShort: ['', '', '', '', '', '', ''],
  // Timer component
  startText: '',
  stopText: '',
  resetText: '',
  lapText: '',
  hideText: '',
  // Forms
  offText: '',
  onText: '',
  // Listview
  backText: '',
  undoText: ' '
};

// Hindi
mobiscroll.i18n.hi = {
  // Core
  setText: ' ',
  cancelText: ' ',
  clearText: ' ',
  selectedText: '{count} ',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['', '', '', '', '', '', ''],
  dayNamesShort: ['', '', '', '', '', '', ''],
  dayNamesMin: ['', '', '', '', '', '', ''],
  dayText: '',
  delimiter: '.',
  hourText: '',
  minuteText: '',
  monthNames: [' ', '', '', '', '', '', '', ' ', '', '', '', ''],
  monthNamesShort: ['', '', '', '', '', '', '', '', '', '', '', ''],
  monthText: '',
  secText: '',
  timeFormat: 'H:ii',
  yearText: '',
  nowText: '',
  pmText: '',
  amText: '',
  // Calendar component
  firstDay: 1,
  dateText: '',
  timeText: '',
  todayText: '',
  prevMonthText: ' ',
  nextMonthText: ' ',
  prevYearText: ' ',
  nextYearText: ' ',
  closeText: '',
  eventText: '',
  eventsText: '',
  allDayText: ' ',
  noEventsText: 'Ei tapahtumia',
  moreEventsText: '{count} ',
  // Daterange component
  fromText: '',
  toText: '',
  // Measurement components
  wholeText: '',
  fractionText: '',
  unitText: '',
  // Time / Timespan component
  labels: ['', '', '', '', '', '', ''],
  labelsShort: ['', '', '', '', '', '', ''],
  // Timer component
  startText: '',
  stopText: '',
  resetText: ' ',
  lapText: '',
  hideText: '',
  // Listview
  backText: '',
  // check
  undoText: ' ',
  // Form
  offText: '',
  onText: '',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Croatian
mobiscroll.i18n.hr = {
  // Core
  setText: 'Postavi',
  cancelText: 'Izlaz',
  clearText: 'Izbrii',
  selectedText: '{count} odabran',
  // Datetime component
  dateFormat: 'dd.mm.yy',
  dayNames: ['Nedjelja', 'Ponedjeljak', 'Utorak', 'Srijeda', 'etvrtak', 'Petak', 'Subota'],
  dayNamesShort: ['Ned', 'Pon', 'Uto', 'Sri', 'et', 'Pet', 'Sub'],
  dayNamesMin: ['Ne', 'Po', 'Ut', 'Sr', 'e', 'Pe', 'Su'],
  dayText: 'Dan',
  delimiter: '.',
  hourText: 'Sat',
  minuteText: 'Minuta',
  monthNames: ['Sijeanj', 'Veljaa', 'Oujak', 'Travanj', 'Svibanj', 'Lipanj', 'Srpanj', 'Kolovoz', 'Rujan', 'Listopad', 'Studeni', 'Prosinac'],
  monthNamesShort: ['Sij', 'Velj', 'Ou', 'Tra', 'Svi', 'Lip', 'Srp', 'Kol', 'Ruj', 'Lis', 'Stu', 'Pro'],
  monthText: 'Mjesec',
  secText: 'Sekunda',
  timeFormat: 'H:ii',
  yearText: 'Godina',
  nowText: 'Sada',
  pmText: 'pm',
  amText: 'am',
  // Calendar component
  firstDay: 1,
  dateText: 'Datum',
  timeText: 'Vrijeme',
  todayText: 'Danas',
  prevMonthText: 'Prethodni mjesec',
  nextMonthText: 'Sljedei mjesec',
  prevYearText: 'Prethodni godina',
  nextYearText: 'Slijedee godine',
  closeText: 'Zatvori',
  eventText: 'Dogaaj',
  eventsText: 'dogaaja',
  allDayText: 'Cijeli dan',
  noEventsText: 'Bez dogaaja',
  moreEventsText: 'Jo {count}',
  // Daterange component
  fromText: 'Poinje',
  toText: 'Zavrava',
  // Measurement components
  wholeText: 'Cjelina',
  fractionText: 'Frakcija',
  unitText: 'Jedinica',
  // Time / Timespan component
  labels: ['godina', 'mjesec', 'dan', 'sat', 'minuta', 'sekunda', ''],
  labelsShort: ['god', 'mje', 'dan', 'sat', 'min', 'sec', ''],
  // Timer component
  startText: 'Poetak',
  stopText: 'Prekid',
  resetText: 'Resetiraj',
  lapText: 'Ciklus',
  hideText: 'Sakriti',
  // Listview
  backText: 'Natrag',
  undoText: 'Ponitavanje',
  // Form
  offText: 'Uklj.',
  onText: 'Isklj.',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Magyar
mobiscroll.i18n.hu = {
  // Core
  setText: 'OK',
  cancelText: 'Mgse',
  clearText: 'Trls',
  selectedText: '{count} kivlasztva',
  // Datetime component
  dateFormat: 'yy.mm.dd.',
  dayNames: ['Vasrnap', 'Htf', 'Kedd', 'Szerda', 'Cstrtk', 'Pntek', 'Szombat'],
  dayNamesShort: ['Va', 'H', 'Ke', 'Sze', 'Cs', 'P', 'Szo'],
  dayNamesMin: ['V', 'H', 'K', 'Sz', 'Cs', 'P', 'Sz'],
  dayText: 'Nap',
  delimiter: '.',
  hourText: 'ra',
  minuteText: 'Perc',
  monthNames: ['Janur', 'Februr', 'Mrcius', 'prilis', 'Mjus', 'Jnius', 'Jlius', 'Augusztus', 'Szeptember', 'Oktber', 'November', 'December'],
  monthNamesShort: ['Jan', 'Feb', 'Mr', 'pr', 'Mj', 'Jn', 'Jl', 'Aug', 'Szep', 'Okt', 'Nov', 'Dec'],
  monthText: 'Hnap',
  secText: 'Msodperc',
  timeFormat: 'H:ii',
  yearText: 'v',
  nowText: 'Most',
  pmText: 'pm',
  amText: 'am',
  // Calendar component
  firstDay: 1,
  dateText: 'Dtum',
  timeText: 'Id',
  todayText: 'Ma',
  prevMonthText: 'Elz hnap',
  nextMonthText: 'Kvetkez hnap',
  prevYearText: 'Elz v',
  nextYearText: 'Kvetkez v',
  closeText: 'Bezr',
  eventText: 'esemny',
  eventsText: 'esemny',
  allDayText: 'Egsz nap',
  noEventsText: 'Nincs esemny',
  moreEventsText: '{count} tovbbi',
  // Daterange component
  fromText: 'Eleje',
  toText: 'Vge',
  // Measurement components
  wholeText: 'Egsz',
  fractionText: 'Trt',
  unitText: 'Egysg',
  // Time / Timespan component
  labels: ['v', 'Hnap', 'Nap', 'ra', 'Perc', 'Msodperc', ''],
  labelsShort: ['v', 'H.', 'Nap', 'ra', 'Perc', 'Mp.', ''],
  // Timer component
  startText: 'Indt',
  stopText: 'Megllt',
  resetText: 'Visszallt',
  lapText: 'Lap',
  hideText: 'Elrejt',
  // Listview
  backText: 'Vissza',
  undoText: 'Visszavon',
  // Form
  offText: 'Ki',
  onText: 'Be',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Italiano 
mobiscroll.i18n.it = {
  // Core
  setText: 'OK',
  cancelText: 'Annulla',
  clearText: 'Chiarire',
  selectedText: '{count} selezionato',
  selectedPluralText: '{count} selezionati',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['Domenica', 'Luned', 'Marted', 'Mercoled', 'Gioved', 'Venerd', 'Sabato'],
  dayNamesShort: ['Do', 'Lu', 'Ma', 'Me', 'Gi', 'Ve', 'Sa'],
  dayNamesMin: ['D', 'L', 'M', 'M', 'G', 'V', 'S'],
  dayText: 'Giorno',
  hourText: 'Ore',
  minuteText: 'Minuti',
  monthNames: ['Gennaio', 'Febbraio', 'Marzo', 'Aprile', 'Maggio', 'Giugno', 'Luglio', 'Agosto', 'Settembre', 'Ottobre', 'Novembre', 'Dicembre'],
  monthNamesShort: ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'],
  monthText: 'Mese',
  secText: 'Secondi',
  timeFormat: 'HH:ii',
  yearText: 'Anno',
  nowText: 'Ora',
  pmText: 'pm',
  amText: 'am',
  todayText: 'Oggi',
  // Calendar component
  firstDay: 1,
  dateText: 'Data',
  timeText: 'Volta',
  closeText: 'Chiudere',
  allDayText: 'Tutto il giorno',
  noEventsText: 'Nessun evento',
  eventText: 'Evento',
  eventsText: 'Eventi',
  moreEventsText: '{count} altro',
  moreEventsPluralText: 'altri {count}',
  // Daterange component
  fromText: 'Inizio',
  toText: 'Fine',
  // Measurement components
  wholeText: 'Intero',
  fractionText: 'Frazione',
  unitText: 'Unit',
  // Time / Timespan component
  labels: ['Anni', 'Mesi', 'Giorni', 'Ore', 'Minuti', 'Secondi', ''],
  labelsShort: ['Anni', 'Mesi', 'Gio', 'Ore', 'Min', 'Sec', ''],
  // Timer component
  startText: 'Inizio',
  stopText: 'Arresto',
  resetText: 'Ripristina',
  lapText: 'Lap',
  hideText: 'Nascondi',
  // Listview
  backText: 'Indietro',
  undoText: 'Annulla',
  // Form
  offText: 'Via',
  onText: 'Su',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

//  - Japanese
mobiscroll.i18n.ja = {
  // Core
  setText: '',
  cancelText: '',
  clearText: '',
  selectedText: '{count} ',
  // Datetime component
  dateFormat: 'yymmdd',
  dayNames: ['', '', '', '', '', '', ''],
  dayNamesShort: ['', '', '', '', '', '', ''],
  dayNamesMin: ['', '', '', '', '', '', ''],
  dayText: '',
  hourText: '',
  minuteText: '',
  monthNames: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
  monthNamesShort: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
  monthText: '',
  secText: '',
  timeFormat: 'HH:ii',
  yearText: '',
  nowText: '',
  pmText: '',
  amText: '',
  yearSuffix: '',
  monthSuffix: '',
  daySuffix: '',
  todayText: '',
  // Calendar component
  dateText: '',
  timeText: '',
  closeText: '',
  allDayText: '',
  noEventsText: '',
  eventText: '',
  eventsText: '',
  moreEventsText: ' {count} ',
  // Daterange component
  fromText: '',
  toText: '',
  // Measurement components
  wholeText: '',
  fractionText: '',
  unitText: '',
  // Time / Timespan component
  labels: ['', '', '', '', '', '', ''],
  labelsShort: ['', '', '', '', '', '', ''],
  // Timer component
  startText: '',
  stopText: '',
  resetText: '',
  lapText: '',
  hideText: '',
  // Listview
  backText: '',
  undoText: ''
};

// Korean
mobiscroll.i18n.ko = {
  // Core
  setText: '',
  cancelText: '',
  clearText: '',
  selectedText: '{count} ',
  // Datetime component
  dateFormat: 'yymmdd',
  dayNames: ['', '', '', '', '', '', ''],
  dayNamesShort: ['', '', '', '', '', '', ''],
  dayNamesMin: ['', '', '', '', '', '', ''],
  dayText: '',
  delimiter: '-',
  hourText: '',
  minuteText: '',
  monthNames: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
  monthNamesShort: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
  monthText: '',
  secText: '',
  timeFormat: 'H:ii',
  yearText: '',
  nowText: '',
  pmText: '',
  amText: '',
  yearSuffix: '',
  monthSuffix: '',
  daySuffix: '',
  // Calendar component
  firstDay: 0,
  dateText: '',
  timeText: '',
  todayText: '',
  prevMonthText: ' ',
  nextMonthText: ' ',
  prevYearText: ' ',
  nextYearText: ' ',
  closeText: '',
  eventText: '',
  eventsText: '',
  allDayText: '',
  noEventsText: ' ',
  moreEventsText: '{count} ',
  // Daterange component
  fromText: '',
  toText: '',
  // Measurement components
  wholeText: '',
  fractionText: '',
  unitText: '',
  // Time / Timespan component
  labels: ['', '', '', '', '', '', ''],
  labelsShort: ['', '', '', '', '', '', ''],
  // Timer component
  startText: '',
  stopText: ' ',
  resetText: '',
  lapText: '',
  hideText: ' ',
  // Listview
  backText: '',
  undoText: '',
  // Form
  offText: '',
  onText: '',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Lietuvi
mobiscroll.i18n.lt = {
  // Core
  setText: 'OK',
  cancelText: 'Ataukti',
  clearText: 'Ivalyti',
  selectedText: 'Pasirinktas {count}',
  selectedPluralText: 'Pasirinkti {count}',
  // Datetime component
  dateFormat: 'yy-mm-dd',
  dayNames: ['Sekmadienis', 'Pirmadienis', 'Antradienis', 'Treiadienis', 'Ketvirtadienis', 'Penktadienis', 'etadienis'],
  dayNamesShort: ['S', 'Pr', 'A', 'T', 'K', 'Pn', ''],
  dayNamesMin: ['S', 'Pr', 'A', 'T', 'K', 'Pn', ''],
  dayText: 'Diena',
  hourText: 'Valanda',
  minuteText: 'Minutes',
  monthNames: ['Sausis', 'Vasaris', 'Kovas', 'Balandis', 'Gegu', 'Birelis', 'Liepa', 'Rugpjtis', 'Rugsjis', 'Spalis', 'Lapkritis', 'Gruodis'],
  monthNamesShort: ['Sau', 'Vas', 'Kov', 'Bal', 'Geg', 'Bir', 'Lie', 'Rugp', 'Rugs', 'Spa', 'Lap', 'Gruo'],
  monthText: 'Mnuo',
  secText: 'Sekundes',
  amText: 'am',
  pmText: 'pm',
  timeFormat: 'HH:ii',
  yearText: 'Metai',
  nowText: 'Dabar',
  todayText: 'iandien',
  // Calendar component
  firstDay: 1,
  dateText: 'Data',
  timeText: 'Laikas',
  closeText: 'Udaryti',
  allDayText: 'Vis dien',
  noEventsText: 'Nra vyki',
  eventText: 'vyki',
  eventsText: 'vykiai',
  moreEventsText: 'Dar {count}',
  // Daterange component
  fromText: 'Nuo',
  toText: 'Iki',
  // Measurement components
  wholeText: 'Visas',
  fractionText: 'Frakcija',
  unitText: 'Vienetas',
  // Time / Timespan component
  labels: ['Metai', 'Mnesiai', 'Dienos', 'Valandos', 'Minutes', 'Sekundes', ''],
  labelsShort: ['m', 'mn.', 'd', 'h', 'min', 's', ''],
  // Timer component
  startText: 'Pradti',
  stopText: 'Sustabdyti',
  resetText: 'Inaujo',
  lapText: 'Ratas',
  hideText: 'Slpti',
  // Listview
  backText: 'Atgal',
  undoText: 'Anuliuoti',
  // Form
  offText: 'Ij.',
  onText: 'j.',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Nederlands
mobiscroll.i18n.nl = {
  // Core
  setText: 'Instellen',
  cancelText: 'Annuleren',
  clearText: 'Leegmaken',
  selectedText: '{count} gekozen',
  // Datetime component
  dateFormat: 'dd-mm-yy',
  dayNames: ['Zondag', 'Maandag', 'Dinsdag', 'Woensdag', 'Donderdag', 'Vrijdag', 'Zaterdag'],
  dayNamesShort: ['zo', 'ma', 'di', 'wo', 'do', 'vr', 'za'],
  dayNamesMin: ['z', 'm', 'd', 'w', 'd', 'v', 'z'],
  dayText: 'Dag',
  hourText: 'Uur',
  minuteText: 'Minuten',
  monthNames: ['januari', 'februari', 'maart', 'april', 'mei', 'juni', 'juli', 'augustus', 'september', 'oktober', 'november', 'december'],
  monthNamesShort: ['jan', 'feb', 'mrt', 'apr', 'mei', 'jun', 'jul', 'aug', 'sep', 'okt', 'nov', 'dec'],
  monthText: 'Maand',
  secText: 'Seconden',
  timeFormat: 'HH:ii',
  yearText: 'Jaar',
  nowText: 'Nu',
  pmText: 'pm',
  amText: 'am',
  todayText: 'Vandaag',
  // Calendar component
  firstDay: 1,
  dateText: 'Datum',
  timeText: 'Tijd',
  closeText: 'Sluiten',
  allDayText: 'Hele dag',
  noEventsText: 'Geen activiteiten',
  eventText: 'Activiteit',
  eventsText: 'Activiteiten',
  moreEventsText: 'nog {count}',
  // Daterange component
  fromText: 'Start',
  toText: 'Einde',
  // Measurement components
  wholeText: 'geheel',
  fractionText: 'fractie',
  unitText: 'eenheid',
  // Time / Timespan component
  labels: ['Jaren', 'Maanden', 'Dagen', 'Uren', 'Minuten', 'Seconden', ''],
  labelsShort: ['j', 'm', 'd', 'u', 'min', 'sec', ''],
  // Timer component
  startText: 'Start',
  stopText: 'Stop',
  resetText: 'Reset',
  lapText: 'Ronde',
  hideText: 'Verbergen',
  // Listview
  backText: 'Terug',
  undoText: 'Onged. maken',
  // Form
  offText: 'Uit',
  onText: 'Aan',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Norsk
mobiscroll.i18n.no = {
  // Core
  setText: 'OK',
  cancelText: 'Avbryt',
  clearText: 'Tmme',
  selectedText: '{count} valgt',
  // Datetime component
  dateFormat: 'dd.mm.yy',
  dayNames: ['Sndag', 'Mandag', 'Tirsdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lrdag'],
  dayNamesShort: ['S', 'Ma', 'Ti', 'On', 'To', 'Fr', 'L'],
  dayNamesMin: ['S', 'M', 'T', 'O', 'T', 'F', 'L'],
  dayText: 'Dag',
  delimiter: '.',
  hourText: 'Time',
  minuteText: 'Minutt',
  monthNames: ['Januar', 'Februar', 'Mars', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Desember'],
  monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Des'],
  monthText: 'Mned',
  secText: 'Sekund',
  timeFormat: 'HH:ii',
  yearText: 'r',
  nowText: 'N',
  pmText: 'pm',
  amText: 'am',
  todayText: 'I dag',
  // Calendar component
  firstDay: 1,
  dateText: 'Dato',
  timeText: 'Tid',
  closeText: 'Lukk',
  allDayText: 'Hele dagen',
  noEventsText: 'Ingen hendelser',
  eventText: 'Hendelse',
  eventsText: 'Hendelser',
  moreEventsText: '{count} mere',
  // Daterange component
  fromText: 'Start',
  toText: 'End',
  // Measurement components
  wholeText: 'Hele',
  fractionText: 'Fraksjon',
  unitText: 'Enhet',
  // Time / Timespan component
  labels: ['r', 'Mneder', 'Dager', 'Timer', 'Minutter', 'Sekunder', ''],
  labelsShort: ['r', 'Mn', 'Dag', 'Time', 'Min', 'Sek', ''],
  // Timer component
  startText: 'Start',
  stopText: 'Stopp',
  resetText: 'Tilbakestille',
  lapText: 'Runde',
  hideText: 'Skjul',
  // Listview
  backText: 'Tilbake',
  undoText: 'Angre',
  // Form
  offText: 'Av',
  onText: 'P',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Polski
mobiscroll.i18n.pl = {
  // Core
  setText: 'Zestaw',
  cancelText: 'Anuluj',
  clearText: 'Oczyci',
  selectedText: 'Wybr: {count}',
  // Datetime component
  dateFormat: 'yy-mm-dd',
  dayNames: ['Niedziela', 'Poniedziaek', 'Wtorek', 'roda', 'Czwartek', 'Pitek', 'Sobota'],
  dayNamesShort: ['Niedz.', 'Pon.', 'Wt.', 'r.', 'Czw.', 'Pt.', 'Sob.'],
  dayNamesMin: ['N', 'P', 'W', '', 'C', 'P', 'S'],
  dayText: 'Dzie',
  hourText: 'Godziny',
  minuteText: 'Minuty',
  monthNames: ['Stycze', 'Luty', 'Marzec', 'Kwiecie', 'Maj', 'Czerwiec', 'Lipiec', 'Sierpie', 'Wrzesie', 'Padziernik', 'Listopad', 'Grudzie'],
  monthNamesShort: ['Sty', 'Lut', 'Mar', 'Kwi', 'Maj', 'Cze', 'Lip', 'Sie', 'Wrz', 'Pa', 'Lis', 'Gru'],
  monthText: 'Miesic',
  secText: 'Sekundy',
  timeFormat: 'HH:ii',
  yearText: 'Rok',
  nowText: 'Teraz',
  amText: 'am',
  pmText: 'pm',
  todayText: 'Dzisiaj',
  // Calendar component
  firstDay: 1,
  dateText: 'Data',
  timeText: 'Czas',
  closeText: 'Zakoczenie',
  allDayText: 'Cay dzie',
  noEventsText: 'Brak wydarze',
  eventText: 'Wydarze',
  eventsText: 'Wydarzenia',
  moreEventsText: 'Jeszcze {count}',
  // Daterange component
  fromText: 'Rozpoczcie',
  toText: 'Koniec',
  // Measurement components
  wholeText: 'Cay',
  fractionText: 'Uamek',
  unitText: 'Jednostka',
  // Time / Timespan component
  labels: ['Lata', 'Miesic', 'Dni', 'Godziny', 'Minuty', 'Sekundy', ''],
  labelsShort: ['R', 'M', 'Dz', 'Godz', 'Min', 'Sek', ''],
  // Timer component
  startText: 'Rozpoczcie',
  stopText: 'Zatrzyma',
  resetText: 'Zresetowa',
  lapText: 'Zakadka',
  hideText: 'Ukry',
  // Listview
  backText: 'Wr',
  undoText: 'Cofnij',
  // Form
  offText: 'Wy',
  onText: 'W',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Portugus Brasileiro
mobiscroll.i18n['pt-BR'] = {
  // Core
  setText: 'Selecionar',
  cancelText: 'Cancelar',
  clearText: 'Claro',
  selectedText: '{count} selecionado',
  selectedPluralText: '{count} selecionados',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['Domingo', 'Segunda-feira', 'Tera-feira', 'Quarta-feira', 'Quinta-feira', 'Sexta-feira', 'Sbado'],
  dayNamesShort: ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sb'],
  dayNamesMin: ['D', 'S', 'T', 'Q', 'Q', 'S', 'S'],
  dayText: 'Dia',
  hourText: 'Hora',
  minuteText: 'Minutos',
  monthNames: ['Janeiro', 'Fevereiro', 'Maro', 'Abril', 'Maio', 'Junho', 'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'],
  monthNamesShort: ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'],
  monthText: 'Ms',
  secText: 'Segundo',
  timeFormat: 'HH:ii',
  yearText: 'Ano',
  nowText: 'Agora',
  pmText: 'pm',
  amText: 'am',
  todayText: 'Hoje',
  // Calendar component
  dateText: 'Data',
  timeText: 'Tempo',
  closeText: 'Fechar',
  allDayText: 'Dia inteiro',
  noEventsText: 'Nenhum evento',
  eventText: 'Evento',
  eventsText: 'Eventos',
  moreEventsText: 'Mais {count}',
  // Daterange component
  fromText: 'In&iacute;cio',
  toText: 'Fim',
  // Measurement components
  wholeText: 'Inteiro',
  fractionText: 'Frao',
  unitText: 'Unidade',
  // Time / Timespan component
  labels: ['Anos', 'Meses', 'Dias', 'Horas', 'Minutos', 'Segundos', ''],
  labelsShort: ['Ano', 'M&ecirc;s', 'Dia', 'Hora', 'Min', 'Seg', ''],
  // Timer component
  startText: 'Comear',
  stopText: 'Pare',
  resetText: 'Reinicializar',
  lapText: 'Lap',
  hideText: 'Esconder',
  // Listview
  backText: 'Anterior',
  undoText: 'Desfazer',
  // Form
  offText: 'Desl',
  onText: 'Lig',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Portugus Europeu
mobiscroll.i18n['pt-PT'] = {
  // Core
  setText: 'Seleccionar',
  cancelText: 'Cancelar',
  clearText: 'Claro',
  selectedText: '{count} selecionado',
  selectedPluralText: '{count} selecionados',
  // Datetime component
  dateFormat: 'dd-mm-yy',
  dayNames: ['Domingo', 'Segunda-feira', 'Tera-feira', 'Quarta-feira', 'Quinta-feira', 'Sexta-feira', 'Sbado'],
  dayNamesShort: ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sb'],
  dayNamesMin: ['D', 'S', 'T', 'Q', 'Q', 'S', 'S'],
  dayText: 'Dia',
  hourText: 'Horas',
  minuteText: 'Minutos',
  monthNames: ['Janeiro', 'Fevereiro', 'Maro', 'Abril', 'Maio', 'Junho', 'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'],
  monthNamesShort: ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'],
  monthText: 'Ms',
  secText: 'Segundo',
  timeFormat: 'HH:ii',
  yearText: 'Ano',
  nowText: 'Actualizar',
  pmText: 'pm',
  amText: 'am',
  todayText: 'Hoy',
  // Calendar component
  firstDay: 1,
  dateText: 'Data',
  timeText: 'Tempo',
  closeText: 'Fechar',
  allDayText: 'Todo o dia',
  noEventsText: 'Nenhum evento',
  eventText: 'Evento',
  eventsText: 'Eventos',
  moreEventsText: 'mais {count}',
  // Daterange component
  fromText: 'Incio',
  toText: 'Fim',
  // Measurement components
  wholeText: 'Inteiro',
  fractionText: 'Fraco',
  unitText: 'Unidade',
  // Time / Timespan component
  labels: ['Anos', 'Meses', 'Dias', 'Horas', 'Minutos', 'Segundos', ''],
  labelsShort: ['Ano', 'Ms', 'Dia', 'Hora', 'Min', 'Seg', ''],
  // Timer component
  startText: 'Comear',
  stopText: 'Parar',
  resetText: 'Reinicializar',
  lapText: 'Lap',
  hideText: 'Esconder',
  // Listview
  backText: 'Anterior',
  undoText: 'Anular',
  // Form
  offText: 'Desl',
  onText: 'Lig',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Romn
mobiscroll.i18n.ro = {
  // Core
  setText: 'Setare',
  cancelText: 'Anulare',
  clearText: 'tergere',
  selectedText: '{count} selectat',
  selectedPluralText: '{count} selectate',
  // Datetime component
  dateFormat: 'dd.mm.yy',
  dayNames: ['Duminic', 'Luni', 'Mari', 'Miercuri', 'Joi', 'Vineri', 'Smbt'],
  dayNamesShort: ['Du', 'Lu', 'Ma', 'Mi', 'Jo', 'Vi', 'S'],
  dayNamesMin: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
  dayText: ' Ziua',
  delimiter: '.',
  hourText: ' Ore ',
  minuteText: 'Minute',
  monthNames: ['Ianuarie', 'Februarie', 'Martie', 'Aprilie', 'Mai', 'Iunie', 'Iulie', 'August', 'Septembrie', 'Octombrie', 'Noiembrie', 'Decembrie'],
  monthNamesShort: ['Ian.', 'Feb.', 'Mar.', 'Apr.', 'Mai', 'Iun.', 'Iul.', 'Aug.', 'Sept.', 'Oct.', 'Nov.', 'Dec.'],
  monthText: 'Luna',
  secText: 'Secunde',
  timeFormat: 'HH:ii',
  yearText: 'Anul',
  nowText: 'Acum',
  amText: 'am',
  pmText: 'pm',
  todayText: 'Astzi',
  prevMonthText: 'Luna anterioar',
  nextMonthText: 'Luna urmtoare',
  prevYearText: 'Anul anterior',
  nextYearText: 'Anul urmtor',
  eventText: 'Eveniment',
  eventsText: 'Evenimente',
  allDayText: 'Toat ziua',
  noEventsText: 'Niciun eveniment',
  moreEventsText: 'nc unul',
  moreEventsPluralText: 'nc {count}',
  // Calendar component
  firstDay: 1,
  dateText: 'Data',
  timeText: 'Ora',
  closeText: 'nchidere',
  // Daterange component
  fromText: 'Start',
  toText: 'Final',
  // Measurement components
  wholeText: 'Complet',
  fractionText: 'Parial',
  unitText: 'Unitate',
  // Time / Timespan component
  labels: ['Ani', 'Luni', 'Zile', 'Ore', 'Minute', 'Secunde', ''],
  labelsShort: ['Ani', 'Luni', 'Zile', 'Ore', 'Min.', 'Sec.', ''],
  // Timer component
  startText: 'Start',
  stopText: 'Stop',
  resetText: 'Resetare',
  lapText: 'Tur',
  hideText: 'Ascundere',
  // Listview
  backText: 'napoi',
  undoText: 'Anuleaz',
  // Form
  offText: 'Nu',
  onText: 'Da',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

//  (UA)
mobiscroll.i18n['ru-UA'] = {
  // Core
  setText: '',
  cancelText: '',
  clearText: 'r',
  selectedText: '{count} ',
  // Datetime component
  dateFormat: 'dd.mm.yy',
  dayNames: ['', '', '', '', '', '', ''],
  dayNamesShort: ['', '', '', '', '', '', ''],
  dayNamesMin: ['', '', '', '', '', '', ''],
  dayText: '',
  delimiter: '.',
  hourText: '',
  minuteText: '',
  monthNames: ['', '', '', '', '', '', '', '', '', '', '', ''],
  monthNamesShort: ['.', '.', '', '.', '', '', '', '.', '.', '.', '.', '.'],
  monthText: '',
  secText: '',
  timeFormat: 'HH:ii',
  yearText: '',
  nowText: '',
  amText: 'am',
  pmText: 'pm',
  todayText: 'C',
  // Calendar component
  firstDay: 1,
  dateText: '',
  timeText: '',
  closeText: '',
  allDayText: ' ',
  noEventsText: ' ',
  eventText: '',
  eventsText: '',
  moreEventsText: ' {count}',
  // Daterange component
  fromText: '',
  toText: '',
  // Measurement components
  wholeText: '',
  fractionText: '',
  unitText: '',
  // Time / Timespan component
  labels: ['', '  ', '  ', '  ', '  ', ' ', ''],
  labelsShort: ['', '.', '.', '.', '.', '.', ''],
  // Timer component
  startText: '',
  stopText: '',
  resetText: '  ',
  lapText: '  ',
  hideText: '  ',
  // Listview
  backText: '',
  undoText: '',
  // Form
  offText: 'O',
  onText: 'I',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// 
mobiscroll.i18n['ru-RU'] = mobiscroll.i18n.ru = {
  // Core
  setText: '',
  cancelText: '',
  clearText: '',
  selectedText: '{count} ',
  // Datetime component
  dateFormat: 'dd.mm.yy',
  dayNames: ['', '', '', '', '', '', ''],
  dayNamesShort: ['', '', '', '', '', '', ''],
  dayNamesMin: ['', '', '', '', '', '', ''],
  dayText: '',
  delimiter: '.',
  hourText: '',
  minuteText: '',
  monthNames: ['', '', '', '', '', '', '', '', '', '', '', ''],
  monthNamesShort: ['', '', '', '', '', '', '', '', '', '', '', ''],
  monthText: '',
  secText: '',
  timeFormat: 'HH:ii',
  yearText: '',
  nowText: '',
  amText: 'am',
  pmText: 'pm',
  todayText: 'C',
  // Calendar component
  firstDay: 1,
  dateText: '',
  timeText: '',
  closeText: '',
  allDayText: ' ',
  noEventsText: ' ',
  eventText: '',
  eventsText: '',
  moreEventsText: ' {count}',
  // Daterange component
  fromText: '',
  toText: '',
  // Measurement components
  wholeText: '',
  fractionText: '',
  unitText: '',
  // Time / Timespan component
  labels: ['', '', '', '', '', '', ''],
  labelsShort: ['', '', '', '', '', '', ''],
  // Timer component
  startText: '',
  stopText: '',
  resetText: '',
  lapText: '',
  hideText: '',
  // Listview
  backText: '',
  undoText: '',
  // Form
  offText: 'O',
  onText: 'I',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Slovencina
mobiscroll.i18n.sk = {
  // Core
  setText: 'Zadaj',
  cancelText: 'Zrui',
  clearText: 'Vymaza',
  selectedText: 'Oznaen: {count}',
  // Datetime component
  dateFormat: 'd.m.yy',
  dayNames: ['Nedea', 'Pondelok', 'Utorok', 'Streda', 'tvrtok', 'Piatok', 'Sobota'],
  dayNamesShort: ['Ne', 'Po', 'Ut', 'St', 't', 'Pi', 'So'],
  dayNamesMin: ['N', 'P', 'U', 'S', '', 'P', 'S'],
  dayText: 'e',
  hourText: 'Hodiny',
  minuteText: 'Minty',
  monthNames: ['Janur', 'Februr', 'Marec', 'Aprl', 'Mj', 'Jn', 'Jl', 'August', 'September', 'Oktber', 'November', 'December'],
  monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'Mj', 'Jn', 'Jl', 'Aug', 'Sep', 'Okt', 'Nov', 'Dec'],
  monthText: 'Mesiac',
  secText: 'Sekundy',
  timeFormat: 'H:ii',
  yearText: 'Rok',
  nowText: 'Teraz',
  amText: 'am',
  pmText: 'pm',
  todayText: 'Dnes',
  // Calendar component
  firstDay: 1,
  dateText: 'Datum',
  timeText: 'as',
  closeText: 'Zavrie',
  allDayText: 'Cel de',
  noEventsText: 'iadne udalosti',
  eventText: 'Udalost',
  eventsText: 'Udalosti',
  moreEventsText: '{count} alia',
  moreEventsPluralText: '{count} alie',
  // Daterange component
  fromText: 'Zaiatok',
  toText: 'Koniec',
  // Measurement components
  wholeText: 'Cel',
  fractionText: 'as',
  unitText: 'Jednotka',
  // Time / Timespan component
  labels: ['Roky', 'Mesiace', 'Dni', 'Hodiny', 'Minty', 'Sekundy', ''],
  labelsShort: ['Rok', 'Mes', 'Dni', 'Hod', 'Min', 'Sec', ''],
  // Timer component
  startText: 'Start',
  stopText: 'Stop',
  resetText: 'Resetova',
  lapText: 'Etapa',
  hideText: 'Schova',
  // Listview
  backText: 'Sp',
  undoText: 'Sp',
  // Form
  offText: 'O',
  onText: 'I',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Serbian
mobiscroll.i18n.sr = {
  // Core
  setText: '',
  cancelText: '',
  clearText: '',
  selectedText: '{count} ',
  // Datetime component
  dateFormat: 'dd.mm.yy',
  dayNames: ['', '', '', '', '', '', ''],
  dayNamesShort: ['', '', '', '', '', '', ''],
  dayNamesMin: ['', '', '', '', '', '', ''],
  dayText: '',
  delimiter: '.',
  hourText: '',
  minuteText: '',
  monthNames: ['', '', '', '', '', '', '', '', '', '', '', ''],
  monthNamesShort: ['', '', '', '', '', '', '', '', '', '', '', ''],
  monthText: '',
  secText: '',
  timeFormat: 'H:ii',
  yearText: '',
  nowText: '',
  pmText: 'pm',
  amText: 'am',
  // Calendar component
  firstDay: 1,
  dateText: '',
  timeText: '',
  todayText: '',
  prevMonthText: ' ',
  nextMonthText: ' ',
  prevYearText: ' ',
  nextYearText: ' ',
  closeText: '',
  eventText: '',
  eventsText: '',
  allDayText: ' ',
  noEventsText: ' ',
  moreEventsText: ' {count}',
  // Daterange component
  fromText: '',
  toText: '',
  // Measurement components
  wholeText: '',
  fractionText: '',
  unitText: '',
  // Time / Timespan component
  labels: ['', '', '', '', '', '', ''],
  labelsShort: ['', '', '', '', '', '', ''],
  // Timer component
  startText: '',
  stopText: '',
  resetText: '',
  lapText: '',
  hideText: '',
  // Listview
  backText: '',
  undoText: '',
  // Form
  offText: 'e',
  onText: '',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Svenska
mobiscroll.i18n.sv = {
  // Core
  setText: 'OK',
  cancelText: 'Avbryt',
  clearText: 'Klara',
  selectedText: '{count} vald',
  // Datetime component
  dateFormat: 'yy-mm-dd',
  dayNames: ['Sndag', 'Mndag', 'Tisdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lrdag'],
  dayNamesShort: ['S', 'M', 'Ti', 'On', 'To', 'Fr', 'L'],
  dayNamesMin: ['S', 'M', 'T', 'O', 'T', 'F', 'L'],
  dayText: 'Dag',
  hourText: 'Timme',
  minuteText: 'Minut',
  monthNames: ['Januari', 'Februari', 'Mars', 'April', 'Maj', 'Juni', 'Juli', 'Augusti', 'September', 'Oktober', 'November', 'December'],
  monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'Maj', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dec'],
  monthText: 'Mnad',
  secText: 'Sekund',
  timeFormat: 'HH:ii',
  yearText: 'r',
  nowText: 'Nu',
  pmText: 'pm',
  amText: 'am',
  todayText: 'I dag',
  // Calendar component
  firstDay: 1,
  dateText: 'Datum',
  timeText: 'Tid',
  closeText: 'Stng',
  allDayText: 'Heldag',
  noEventsText: 'Inga aktiviteter',
  eventText: 'Hndelse',
  eventsText: 'Hndelser',
  moreEventsText: '{count} till',
  // Daterange component
  fromText: 'Start',
  toText: 'Slut',
  // Measurement components
  wholeText: 'Hela',
  fractionText: 'Brk',
  unitText: 'Enhet',
  // Time / Timespan component
  labels: ['r', 'Mnader', 'Dagar', 'Timmar', 'Minuter', 'Sekunder', ''],
  labelsShort: ['r', 'Mn', 'Dag', 'Tim', 'Min', 'Sek', ''],
  // Timer component
  startText: 'Start',
  stopText: 'Stopp',
  resetText: 'terstll',
  lapText: 'Varv',
  hideText: 'Dlj',
  // Listview
  backText: 'Tillbaka',
  undoText: 'ngra',
  // Form
  offText: 'Av',
  onText: 'P'
};

// Trke
mobiscroll.i18n.tr = {
  // Core
  setText: 'Se',
  cancelText: 'ptal',
  clearText: 'Temizleyin',
  selectedText: '{count} seilmi',
  // Datetime component
  dateFormat: 'dd.mm.yy',
  dayNames: ['Pazar', 'Pazartesi', 'Sal', 'aramba', 'Perembe', 'Cuma', 'Cumartesi'],
  dayNamesShort: ['Paz', 'Pzt', 'Sal', 'ar', 'Per', 'Cum', 'Cmt'],
  dayNamesMin: ['P', 'P', 'S', '', 'P', 'C', 'C'],
  dayText: 'Gn',
  delimiter: '.',
  hourText: 'Saat',
  minuteText: 'Dakika',
  monthNames: ['Ocak', 'ubat', 'Mart', 'Nisan', 'Mays', 'Haziran', 'Temmuz', 'Austos', 'Eyll', 'Ekim', 'Kasm', 'Aralk'],
  monthNamesShort: ['Oca', 'ub', 'Mar', 'Nis', 'May', 'Haz', 'Tem', 'Au', 'Eyl', 'Eki', 'Kas', 'Ara'],
  monthText: 'Ay',
  secText: 'Saniye',
  timeFormat: 'HH:ii',
  yearText: 'Yl',
  nowText: 'imdi',
  pmText: 'pm',
  amText: 'am',
  todayText: 'Bugn',
  // Calendar component
  firstDay: 1,
  dateText: 'Tarih',
  timeText: 'Zaman',
  closeText: 'Kapatmak',
  allDayText: 'Tm gn',
  noEventsText: 'Etkinlik Yok',
  eventText: 'Etkinlik',
  eventsText: 'Etkinlikler',
  moreEventsText: '{count} tane daha',
  // Daterange component
  fromText: 'Bala',
  toText: 'Son',
  // Measurement components
  wholeText: 'Tam',
  fractionText: 'Kesir',
  unitText: 'Birim',
  // Time / Timespan component
  labels: ['Yl', 'Ay', 'Gn', 'Saat', 'Dakika', 'Saniye', ''],
  labelsShort: ['Yl', 'Ay', 'Gn', 'Sa', 'Dak', 'Sn', ''],
  // Timer component
  startText: 'Bala',
  stopText: 'Durdur',
  resetText: 'Sfrla',
  lapText: 'Tur',
  hideText: 'Gizle',
  // Listview
  backText: 'Geri',
  undoText: 'Geri Al',
  // Form
  offText: 'O',
  onText: 'I',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: '.'
};

// Vietnamese 
mobiscroll.i18n.vi = {
  // Core
  setText: 't',
  cancelText: 'Hy b',
  clearText: 'Xa',
  selectedText: '{count} chn',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['Ch Nht', 'Th Hai', 'Th Ba', 'Th T', 'Th Nm', 'Th Su', 'Th By'],
  dayNamesShort: ['CN', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7'],
  dayNamesMin: ['CN', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7'],
  dayText: '',
  delimiter: '/',
  hourText: 'Gi',
  minuteText: 'Pht',
  monthNames: ['Thng Mt', 'Thng Hai', 'Thng Ba', 'Thng T', 'Thng Nm', 'Thng Su', 'Thng By', 'Thng Tm', 'Thng Chn', 'Thng Mi', 'Thng Mi Mt', 'Thng Mi Hai'],
  monthNamesShort: ['Thng 1', 'Thng 2', 'Thng 3', 'Thng 4', 'Thng 5', 'Thng 6', 'Thng 7', 'Thng 8', 'Thng 9', 'Thng 10', 'Thng 11', 'Thng 12'],
  monthText: 'Thng',
  secText: 'Giy',
  timeFormat: 'H:ii',
  yearText: 'Nm',
  nowText: 'By gi',
  pmText: 'pm',
  amText: 'am',
  // Calendar component
  firstDay: 0,
  dateText: 'Ngy',
  timeText: 'Hi',
  todayText: 'Hm nay',
  prevMonthText: 'Thng trc',
  nextMonthText: 'Thng ti',
  prevYearText: 'Mm trc',
  nextYearText: 'Nm ti',
  closeText: 'ng',
  eventText: 'S kin',
  eventsText: 'S kin',
  allDayText: 'C ngy',
  noEventsText: 'Khng c s kin',
  moreEventsText: '{count} th khc',
  // Daterange component
  fromText: 'T',
  toText: 'Ti',
  // Measurement components
  wholeText: 'Ton th',
  fractionText: 'Phn s',
  unitText: 'n v',
  // Time / Timespan component
  labels: ['Nm', 'Thng', 'Ngy', 'Gi', 'Pht', 'Giy', ''],
  labelsShort: ['Nm', 'Thng', 'Ngy', 'Gi', 'Pht', 'Giy', ''],
  // Timer component
  startText: 'Bt u',
  stopText: 'Dng',
  resetText: 't li',
  lapText: 'Vng',
  hideText: 'Giu',
  // Listview
  backText: 'Quay li',
  undoText: 'Hon tc',
  // Form
  offText: 'Tt',
  onText: 'Bt',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Chinese
mobiscroll.i18n.zh = {
  // Core
  setText: '',
  cancelText: '',
  clearText: '',
  selectedText: '{count} ',
  // Datetime component
  dateFormat: 'yymmd',
  dayNames: ['', '', '', '', '', '', ''],
  dayNamesShort: ['', '', '', '', '', '', ''],
  dayNamesMin: ['', '', '', '', '', '', ''],
  dayText: '',
  hourText: '',
  minuteText: '',
  monthNames: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
  monthNamesShort: ['', '', '', '', '', '', '', '', '', '', '', ''],
  monthText: '',
  secText: '',
  timeFormat: 'HH:ii',
  yearText: '',
  nowText: '',
  pmText: '',
  amText: '',
  yearSuffix: '',
  monthSuffix: '',
  daySuffix: '',
  todayText: '',
  // Calendar component
  dateText: '',
  timeText: '',
  closeText: '',
  allDayText: '',
  noEventsText: '',
  eventText: '',
  eventsText: '',
  moreEventsText: ' {count} ',
  // Daterange component
  fromText: '',
  toText: '',
  // Measurement components
  wholeText: '',
  fractionText: '',
  unitText: '',
  // Time / Timespan component
  labels: ['', '', '', '', '', '', ''],
  labelsShort: ['', '', '', '', '', '', ''],
  // Timer component
  startText: '',
  stopText: '',
  resetText: '',
  lapText: '',
  hideText: '',
  // Listview
  backText: '',
  undoText: '',
  // Form
  offText: '',
  onText: '',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

var themes$1 = mobiscroll.themes;
themes$1.frame.ios = {
  display: 'bottom',
  // frame
  headerText: false,
  // frame
  btnWidth: false,
  // frame
  deleteIcon: 'ios-backspace',
  // numpad
  scroll3d: os != 'wp' && (os != 'android' || majorVersion > 7)
};
themes$1.scroller.ios = extend$1({}, themes$1.frame.ios, {
  rows: 5,
  // scroller
  height: 34,
  // scroller
  minWidth: 55,
  // scroller
  selectedLineHeight: true,
  // scroller
  selectedLineBorder: 1,
  // scroller
  showLabel: false,
  // scroller
  useShortLabels: true,
  // timespan/timer
  btnPlusClass: 'mbsc-ic mbsc-ic-arrow-down5',
  // scroller
  btnMinusClass: 'mbsc-ic mbsc-ic-arrow-up5',
  // scroller
  checkIcon: 'ion-ios7-checkmark-empty',
  // select
  filterClearIcon: 'ion-close-circled',
  // select
  dateDisplay: 'MMdyy',
  // date
  btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left5',
  // calendar
  btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right5' // calendar

});
themes$1.listview.ios = {
  leftArrowClass: 'mbsc-ic-ion-ios7-arrow-back',
  rightArrowClass: 'mbsc-ic-ion-ios7-arrow-forward'
};
themes$1.form.ios = {};

function _addRipple($control, ev) {
  var x = getCoord(ev, 'X', true),
      y = getCoord(ev, 'Y', true),
      control = $control[0],
      rect = $control.offset(),
      left = x - rect.left,
      top = y - rect.top,
      width = Math.max(left, control.offsetWidth - left),
      height = Math.max(top, control.offsetHeight - top),
      size = 2 * Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));

  _removeRipple($ripple);

  $ripple = $$1('<span class="mbsc-ripple"></span>').css({
    backgroundColor: getComputedStyle(control).color,
    width: size,
    height: size,
    top: y - rect.top - size / 2,
    left: x - rect.left - size / 2
  }).appendTo($control);
  setTimeout(function () {
    $ripple.addClass('mbsc-ripple-scaled mbsc-ripple-visible');
  }, 10);
}

function _removeRipple($r) {
  setTimeout(function () {
    if ($r) {
      $r.removeClass('mbsc-ripple-visible');
      setTimeout(function () {
        $r.remove();
      }, 2000);
    }
  }, 100);
}

function initRipple($markup, selector, disabled, nohl) {
  var startX,
      startY,
      markup = $markup[0];

  function onStart(ev) {
    var target = closest(markup, ev.target, selector);

    if (target && testTouch(ev, target)) {
      startX = getCoord(ev, 'X');
      startY = getCoord(ev, 'Y');
      $active$1 = $$1(target);

      if (!$active$1.hasClass(disabled) && !$active$1.hasClass(nohl)) {
        _addRipple($active$1, ev);
      } else {
        $active$1 = null;
      }
    }
  }

  function onMove(ev) {
    if ($active$1 && Math.abs(getCoord(ev, 'X') - startX) > 9 || Math.abs(getCoord(ev, 'Y') - startY) > 9) {
      _removeRipple($ripple);

      $active$1 = null;
    }
  }

  function onEnd() {
    if ($active$1) {
      setTimeout(function () {
        _removeRipple($ripple);
      }, 100);
      $active$1 = null;
    }
  }

  if (markup) {
    if (markup.__mbscRippleOff) {
      markup.__mbscRippleOff();
    }

    listen(markup, 'touchstart', onStart, {
      passive: true
    });
    listen(markup, 'mousedown', onStart);
    listen(markup, 'touchmove', onMove, {
      passive: true
    });
    listen(markup, 'mousemove', onMove);
    listen(markup, 'touchend', onEnd);
    listen(markup, 'touchcancel', onEnd);
    listen(markup, 'mouseleave', onEnd);
    listen(markup, 'mouseup', onEnd);

    markup.__mbscRippleOff = function () {
      unlisten(markup, 'touchstart', onStart, {
        passive: true
      });
      unlisten(markup, 'mousedown', onStart);
      unlisten(markup, 'touchmove', onMove, {
        passive: true
      });
      unlisten(markup, 'mousemove', onMove);
      unlisten(markup, 'touchend', onEnd);
      unlisten(markup, 'touchcancel', onEnd);
      unlisten(markup, 'mouseleave', onEnd);
      unlisten(markup, 'mouseup', onEnd);
      delete markup.__mbscRippleOff;
    };
  }
}

var $active$1,
    $ripple,
    themes$2 = mobiscroll.themes;
themes$2.frame.material = {
  headerText: false,
  btnWidth: false,
  deleteIcon: 'material-backspace',
  onMarkupReady: function onMarkupReady(ev) {
    initRipple($$1(ev.target), '.mbsc-fr-btn-e', 'mbsc-disabled', 'mbsc-fr-btn-nhl');
  }
};
themes$2.scroller.material = extend$1({}, themes$2.frame.material, {
  showLabel: false,
  selectedLineBorder: 2,
  weekDays: 'min',
  icon: {
    filled: 'material-star',
    empty: 'material-star-outline'
  },
  checkIcon: 'material-check',
  btnPlusClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-down',
  btnMinusClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-up',
  btnCalPrevClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-left',
  btnCalNextClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-right'
});
themes$2.listview.material = {
  leftArrowClass: 'mbsc-ic-material-keyboard-arrow-left',
  rightArrowClass: 'mbsc-ic-material-keyboard-arrow-right',
  onItemActivate: function onItemActivate(ev) {
    _addRipple($$1(ev.target), ev.domEvent);
  },
  onItemDeactivate: function onItemDeactivate() {
    _removeRipple($ripple);
  },
  onSlideStart: function onSlideStart(ev) {
    $$1('.mbsc-ripple', ev.target).remove();
  },
  onSortStart: function onSortStart(ev) {
    $$1('.mbsc-ripple', ev.target).remove();
  }
};
themes$2.navigation.material = {
  onInit: function onInit() {
    initRipple($$1(this), '.mbsc-ms-item.mbsc-btn-e', 'mbsc-disabled', 'mbsc-btn-nhl');
  },
  onMarkupInit: function onMarkupInit() {
    $$1('.mbsc-ripple', this).remove();
  },
  onDestroy: function onDestroy() {
    if (this.__mbscRippleOff) {
      this.__mbscRippleOff();
    }
  }
};
themes$2.form.material = {
  addRipple: function addRipple(elm, ev) {
    _addRipple(elm, ev);
  },
  removeRipple: function removeRipple() {
    _removeRipple($ripple);
  }
};

var themes$3 = mobiscroll.themes;
themes$3.frame.windows = {
  headerText: false,
  deleteIcon: 'backspace4',
  //setIcon: 'material-check',
  //cancelIcon: 'material-close',
  //closeIcon: 'material-close',
  //clearIcon: 'material-close',
  //okIcon: 'material-check',
  //nowIcon: 'loop2',
  //startIcon: 'play3',
  //stopIcon: 'pause2',
  //resetIcon: 'stop2',
  //lapIcon: 'loop2',
  //btnWidth: false,
  btnReverse: true
};
themes$3.scroller.windows = extend$1({}, themes$3.frame.windows, {
  rows: 6,
  // scroller
  minWidth: 88,
  height: 44,
  btnPlusClass: 'mbsc-ic mbsc-ic-arrow-down5',
  btnMinusClass: 'mbsc-ic mbsc-ic-arrow-up5',
  checkIcon: 'material-check',
  dateDisplay: 'MMdyy',
  // date
  showLabel: false,
  showScrollArrows: true,
  btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left5',
  // calendar
  btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right5',
  // calendar
  dayNamesShort: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
  useShortLabels: true // timespan/timer

});
themes$3.form.windows = {};

mobiscroll.customTheme('ios-dark', 'ios');

mobiscroll.customTheme('material-dark', 'material');

mobiscroll.customTheme('mobiscroll-dark', 'mobiscroll');

mobiscroll.customTheme('windows-dark', 'windows');

var themes$4 = mobiscroll.themes;
var theme = 'mobiscroll';

if (os == 'android') {
  theme = 'material';
} else if (os == 'ios') {
  theme = 'ios';
} else if (os == 'wp') {
  theme = 'windows';
}

$$1.each(themes$4.frame, function (key, settings) {
  // Stop at the first custom theme with the OS base theme
  if (theme && settings.baseTheme == theme && key != theme + '-dark') {
    mobiscroll.autoTheme = key;
    return false;
  } else if (key == theme) {
    mobiscroll.autoTheme = key;
  }
});

export { MbscAvatar, MbscButton, MbscCheckbox, MbscCommercialComponent, MbscDropdown, MbscForm, MbscFormsModule, MbscInput, MbscInputModule, MbscModule, MbscNote, MbscPage, MbscPageModule, MbscProgress, MbscRadio, MbscRadioGroup, MbscRating, MbscSegmented, MbscSegmentedGroup, MbscSlider, MbscStepper, MbscSwitch, MbscTextarea, mobiscroll, MbscOptionsService as a, MbscInputService as b, MbscBase as c, MbscValueBase as d, MbscCloneBase as e, MbscControlBase as f, MbscBaseModule as g, MbscFormBase as h, MbscFormValueBase as i, MbscInputBase as j, MbscRadioService as k, MbscRadioGroupBase as l, MbscFormGroup as m, MbscFormGroupTitle as n, MbscFormGroupContent as o, MbscAccordion as p };
